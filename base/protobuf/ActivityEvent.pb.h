// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ActivityEvent.proto

#ifndef PROTOBUF_ActivityEvent_2eproto__INCLUDED
#define PROTOBUF_ActivityEvent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "xCmd.pb.h"
#include "SceneItem.pb.h"
#include "GuildCmd.pb.h"
#include "SessionShop.pb.h"
// @@protoc_insertion_point(includes)

namespace Cmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ActivityEvent_2eproto();
void protobuf_AssignDesc_ActivityEvent_2eproto();
void protobuf_ShutdownFile_ActivityEvent_2eproto();

class AEReward;
class AEMapPos;
class AEMap;
class AEFreeTransferInfo;
class AESummonInfo;
class AERewardExtraInfo;
class AERewardMultipleInfo;
class AERewardInfo;
class AELotteryDiscount;
class AELotteryNpc;
class AEUrl;
class AELotteryBanner;
class AEGuildBuildingSubmitInfo;
class AEShopInfo;
class ActivityEventInfo;
class AEResetInfo;
class AERewardItem;
class ActivityEvent;
class ActivityEventNtf;
class ActivityEventUserDataNtf;
class ActivityEventCnt;
class ActivityEventNtfEventCntCmd;

enum ActivityEventParam {
  ACTIVITYEVENTPARAM_NTF = 1,
  ACTIVITYEVENTPARAM_USER_DATA_NTF = 2,
  ACTIVITYEVENTPARAM_NTF_EVENT_CNT = 3
};
bool ActivityEventParam_IsValid(int value);
const ActivityEventParam ActivityEventParam_MIN = ACTIVITYEVENTPARAM_NTF;
const ActivityEventParam ActivityEventParam_MAX = ACTIVITYEVENTPARAM_NTF_EVENT_CNT;
const int ActivityEventParam_ARRAYSIZE = ActivityEventParam_MAX + 1;

const ::google::protobuf::EnumDescriptor* ActivityEventParam_descriptor();
inline const ::std::string& ActivityEventParam_Name(ActivityEventParam value) {
  return ::google::protobuf::internal::NameOfEnum(
    ActivityEventParam_descriptor(), value);
}
inline bool ActivityEventParam_Parse(
    const ::std::string& name, ActivityEventParam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ActivityEventParam>(
    ActivityEventParam_descriptor(), name, value);
}
enum EAERewardMode {
  EAEREWARDMODE_MIN = 0,
  EAEREWARDMODE_LABORATORY = 1,
  EAEREWARDMODE_WANTEDQUEST = 2,
  EAEREWARDMODE_SEAL = 3,
  EAEREWARDMODE_GUILD_DONATE = 4,
  EAEREWARDMODE_TOWER = 5,
  EAEREWARDMODE_GUILDRAID = 6,
  EAEREWARDMODE_GUILDDOJO = 7,
  EAEREWARDMODE_PVECARD = 8
};
bool EAERewardMode_IsValid(int value);
const EAERewardMode EAERewardMode_MIN = EAEREWARDMODE_MIN;
const EAERewardMode EAERewardMode_MAX = EAEREWARDMODE_PVECARD;
const int EAERewardMode_ARRAYSIZE = EAERewardMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* EAERewardMode_descriptor();
inline const ::std::string& EAERewardMode_Name(EAERewardMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    EAERewardMode_descriptor(), value);
}
inline bool EAERewardMode_Parse(
    const ::std::string& name, EAERewardMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EAERewardMode>(
    EAERewardMode_descriptor(), name, value);
}
enum ECoinType {
  ECoinType_Min = 0,
  ECoinType_Coin = 1,
  ECoinType_Ticket = 2
};
bool ECoinType_IsValid(int value);
const ECoinType ECoinType_MIN = ECoinType_Min;
const ECoinType ECoinType_MAX = ECoinType_Ticket;
const int ECoinType_ARRAYSIZE = ECoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ECoinType_descriptor();
inline const ::std::string& ECoinType_Name(ECoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ECoinType_descriptor(), value);
}
inline bool ECoinType_Parse(
    const ::std::string& name, ECoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ECoinType>(
    ECoinType_descriptor(), name, value);
}
enum EUserType {
  EUserType_Char = 1,
  EUserType_Acc = 2
};
bool EUserType_IsValid(int value);
const EUserType EUserType_MIN = EUserType_Char;
const EUserType EUserType_MAX = EUserType_Acc;
const int EUserType_ARRAYSIZE = EUserType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EUserType_descriptor();
inline const ::std::string& EUserType_Name(EUserType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EUserType_descriptor(), value);
}
inline bool EUserType_Parse(
    const ::std::string& name, EUserType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EUserType>(
    EUserType_descriptor(), name, value);
}
enum EActivityEventType {
  EACTIVITYEVENTTYPE_MIN = 0,
  EACTIVITYEVENTTYPE_FREE_TRANSFER = 1,
  EACTIVITYEVENTTYPE_SUMMON = 2,
  EACTIVITYEVENTTYPE_REWARD = 3,
  EACTIVITYEVENTTYPE_RESETTIME = 4,
  EACTIVITYEVENTTYPE_LOTTERY_DISCOUNT = 5,
  EACTIVITYEVENTTYPE_LOTTERY_NPC = 6,
  EACTIVITYEVENTTYPE_LOTTERY_BANNER = 7,
  EACTIVITYEVENTTYPE_GUILD_BUILDING_SUBMIT = 8,
  EACTIVITYEVENTTYPE_SHOP = 9,
  EACTIVITYEVENTTYPE_MAX = 10
};
bool EActivityEventType_IsValid(int value);
const EActivityEventType EActivityEventType_MIN = EACTIVITYEVENTTYPE_MIN;
const EActivityEventType EActivityEventType_MAX = EACTIVITYEVENTTYPE_MAX;
const int EActivityEventType_ARRAYSIZE = EActivityEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EActivityEventType_descriptor();
inline const ::std::string& EActivityEventType_Name(EActivityEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EActivityEventType_descriptor(), value);
}
inline bool EActivityEventType_Parse(
    const ::std::string& name, EActivityEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EActivityEventType>(
    EActivityEventType_descriptor(), name, value);
}
// ===================================================================

class AEReward : public ::google::protobuf::Message {
 public:
  AEReward();
  virtual ~AEReward();

  AEReward(const AEReward& from);

  inline AEReward& operator=(const AEReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEReward& default_instance();

  void Swap(AEReward* other);

  // implements Message ----------------------------------------------

  AEReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEReward& from);
  void MergeFrom(const AEReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 count = 2 [default = 0];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 weight = 3 [default = 0];
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline ::google::protobuf::uint32 weight() const;
  inline void set_weight(::google::protobuf::uint32 value);

  // optional uint32 minlayer = 4 [default = 0];
  inline bool has_minlayer() const;
  inline void clear_minlayer();
  static const int kMinlayerFieldNumber = 4;
  inline ::google::protobuf::uint32 minlayer() const;
  inline void set_minlayer(::google::protobuf::uint32 value);

  // optional uint32 maxlayer = 5 [default = 0];
  inline bool has_maxlayer() const;
  inline void clear_maxlayer();
  static const int kMaxlayerFieldNumber = 5;
  inline ::google::protobuf::uint32 maxlayer() const;
  inline void set_maxlayer(::google::protobuf::uint32 value);

  // repeated uint32 difficultys = 6;
  inline int difficultys_size() const;
  inline void clear_difficultys();
  static const int kDifficultysFieldNumber = 6;
  inline ::google::protobuf::uint32 difficultys(int index) const;
  inline void set_difficultys(int index, ::google::protobuf::uint32 value);
  inline void add_difficultys(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      difficultys() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_difficultys();

  // @@protoc_insertion_point(class_scope:Cmd.AEReward)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_minlayer();
  inline void clear_has_minlayer();
  inline void set_has_maxlayer();
  inline void clear_has_maxlayer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 weight_;
  ::google::protobuf::uint32 minlayer_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > difficultys_;
  ::google::protobuf::uint32 maxlayer_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEReward* default_instance_;
};
// -------------------------------------------------------------------

class AEMapPos : public ::google::protobuf::Message {
 public:
  AEMapPos();
  virtual ~AEMapPos();

  AEMapPos(const AEMapPos& from);

  inline AEMapPos& operator=(const AEMapPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEMapPos& default_instance();

  void Swap(AEMapPos* other);

  // implements Message ----------------------------------------------

  AEMapPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEMapPos& from);
  void MergeFrom(const AEMapPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float pos = 1;
  inline int pos_size() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline float pos(int index) const;
  inline void set_pos(int index, float value);
  inline void add_pos(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      pos() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_pos();

  // optional float range = 2 [default = 0];
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline float range() const;
  inline void set_range(float value);

  // @@protoc_insertion_point(class_scope:Cmd.AEMapPos)
 private:
  inline void set_has_range();
  inline void clear_has_range();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > pos_;
  float range_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEMapPos* default_instance_;
};
// -------------------------------------------------------------------

class AEMap : public ::google::protobuf::Message {
 public:
  AEMap();
  virtual ~AEMap();

  AEMap(const AEMap& from);

  inline AEMap& operator=(const AEMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEMap& default_instance();

  void Swap(AEMap* other);

  // implements Message ----------------------------------------------

  AEMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEMap& from);
  void MergeFrom(const AEMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // repeated .Cmd.AEMapPos coord = 3;
  inline int coord_size() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 3;
  inline const ::Cmd::AEMapPos& coord(int index) const;
  inline ::Cmd::AEMapPos* mutable_coord(int index);
  inline ::Cmd::AEMapPos* add_coord();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMapPos >&
      coord() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMapPos >*
      mutable_coord();

  // @@protoc_insertion_point(class_scope:Cmd.AEMap)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* desc_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEMapPos > coord_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEMap* default_instance_;
};
// -------------------------------------------------------------------

class AEFreeTransferInfo : public ::google::protobuf::Message {
 public:
  AEFreeTransferInfo();
  virtual ~AEFreeTransferInfo();

  AEFreeTransferInfo(const AEFreeTransferInfo& from);

  inline AEFreeTransferInfo& operator=(const AEFreeTransferInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEFreeTransferInfo& default_instance();

  void Swap(AEFreeTransferInfo* other);

  // implements Message ----------------------------------------------

  AEFreeTransferInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEFreeTransferInfo& from);
  void MergeFrom(const AEFreeTransferInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 mapids = 1;
  inline int mapids_size() const;
  inline void clear_mapids();
  static const int kMapidsFieldNumber = 1;
  inline ::google::protobuf::uint32 mapids(int index) const;
  inline void set_mapids(int index, ::google::protobuf::uint32 value);
  inline void add_mapids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      mapids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_mapids();

  // optional bool allfree = 2 [default = false];
  inline bool has_allfree() const;
  inline void clear_allfree();
  static const int kAllfreeFieldNumber = 2;
  inline bool allfree() const;
  inline void set_allfree(bool value);

  // repeated uint32 teammapids = 3;
  inline int teammapids_size() const;
  inline void clear_teammapids();
  static const int kTeammapidsFieldNumber = 3;
  inline ::google::protobuf::uint32 teammapids(int index) const;
  inline void set_teammapids(int index, ::google::protobuf::uint32 value);
  inline void add_teammapids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      teammapids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_teammapids();

  // optional bool teamallfree = 4 [default = false];
  inline bool has_teamallfree() const;
  inline void clear_teamallfree();
  static const int kTeamallfreeFieldNumber = 4;
  inline bool teamallfree() const;
  inline void set_teamallfree(bool value);

  // optional bool storefree = 5 [default = false];
  inline bool has_storefree() const;
  inline void clear_storefree();
  static const int kStorefreeFieldNumber = 5;
  inline bool storefree() const;
  inline void set_storefree(bool value);

  // @@protoc_insertion_point(class_scope:Cmd.AEFreeTransferInfo)
 private:
  inline void set_has_allfree();
  inline void clear_has_allfree();
  inline void set_has_teamallfree();
  inline void clear_has_teamallfree();
  inline void set_has_storefree();
  inline void clear_has_storefree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > mapids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > teammapids_;
  bool allfree_;
  bool teamallfree_;
  bool storefree_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEFreeTransferInfo* default_instance_;
};
// -------------------------------------------------------------------

class AESummonInfo : public ::google::protobuf::Message {
 public:
  AESummonInfo();
  virtual ~AESummonInfo();

  AESummonInfo(const AESummonInfo& from);

  inline AESummonInfo& operator=(const AESummonInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AESummonInfo& default_instance();

  void Swap(AESummonInfo* other);

  // implements Message ----------------------------------------------

  AESummonInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AESummonInfo& from);
  void MergeFrom(const AESummonInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monsterid = 1 [default = 0];
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsteridFieldNumber = 1;
  inline ::google::protobuf::uint32 monsterid() const;
  inline void set_monsterid(::google::protobuf::uint32 value);

  // optional uint32 count = 2 [default = 0];
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional bool revive = 3 [default = false];
  inline bool has_revive() const;
  inline void clear_revive();
  static const int kReviveFieldNumber = 3;
  inline bool revive() const;
  inline void set_revive(bool value);

  // optional bool iscreate = 4 [default = false];
  inline bool has_iscreate() const;
  inline void clear_iscreate();
  static const int kIscreateFieldNumber = 4;
  inline bool iscreate() const;
  inline void set_iscreate(bool value);

  // optional string namezh = 5;
  inline bool has_namezh() const;
  inline void clear_namezh();
  static const int kNamezhFieldNumber = 5;
  inline const ::std::string& namezh() const;
  inline void set_namezh(const ::std::string& value);
  inline void set_namezh(const char* value);
  inline void set_namezh(const char* value, size_t size);
  inline ::std::string* mutable_namezh();
  inline ::std::string* release_namezh();
  inline void set_allocated_namezh(::std::string* namezh);

  // optional string nameen = 6;
  inline bool has_nameen() const;
  inline void clear_nameen();
  static const int kNameenFieldNumber = 6;
  inline const ::std::string& nameen() const;
  inline void set_nameen(const ::std::string& value);
  inline void set_nameen(const char* value);
  inline void set_nameen(const char* value, size_t size);
  inline ::std::string* mutable_nameen();
  inline ::std::string* release_nameen();
  inline void set_allocated_nameen(::std::string* nameen);

  // optional string icon = 7;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 7;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string type = 8;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 8;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string zone = 9;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 9;
  inline const ::std::string& zone() const;
  inline void set_zone(const ::std::string& value);
  inline void set_zone(const char* value);
  inline void set_zone(const char* value, size_t size);
  inline ::std::string* mutable_zone();
  inline ::std::string* release_zone();
  inline void set_allocated_zone(::std::string* zone);

  // optional string race = 10;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 10;
  inline const ::std::string& race() const;
  inline void set_race(const ::std::string& value);
  inline void set_race(const char* value);
  inline void set_race(const char* value, size_t size);
  inline ::std::string* mutable_race();
  inline ::std::string* release_race();
  inline void set_allocated_race(::std::string* race);

  // optional string nature = 11;
  inline bool has_nature() const;
  inline void clear_nature();
  static const int kNatureFieldNumber = 11;
  inline const ::std::string& nature() const;
  inline void set_nature(const ::std::string& value);
  inline void set_nature(const char* value);
  inline void set_nature(const char* value, size_t size);
  inline ::std::string* mutable_nature();
  inline ::std::string* release_nature();
  inline void set_allocated_nature(::std::string* nature);

  // optional string shape = 12;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 12;
  inline const ::std::string& shape() const;
  inline void set_shape(const ::std::string& value);
  inline void set_shape(const char* value);
  inline void set_shape(const char* value, size_t size);
  inline ::std::string* mutable_shape();
  inline ::std::string* release_shape();
  inline void set_allocated_shape(::std::string* shape);

  // optional uint32 body = 13 [default = 0];
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 13;
  inline ::google::protobuf::uint32 body() const;
  inline void set_body(::google::protobuf::uint32 value);

  // optional uint32 jobexp = 14 [default = 0];
  inline bool has_jobexp() const;
  inline void clear_jobexp();
  static const int kJobexpFieldNumber = 14;
  inline ::google::protobuf::uint32 jobexp() const;
  inline void set_jobexp(::google::protobuf::uint32 value);

  // optional uint32 baseexp = 15 [default = 0];
  inline bool has_baseexp() const;
  inline void clear_baseexp();
  static const int kBaseexpFieldNumber = 15;
  inline ::google::protobuf::uint32 baseexp() const;
  inline void set_baseexp(::google::protobuf::uint32 value);

  // optional float str = 16 [default = 0];
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 16;
  inline float str() const;
  inline void set_str(float value);

  // optional float dex = 17 [default = 0];
  inline bool has_dex() const;
  inline void clear_dex();
  static const int kDexFieldNumber = 17;
  inline float dex() const;
  inline void set_dex(float value);

  // optional float inte = 18 [default = 0];
  inline bool has_inte() const;
  inline void clear_inte();
  static const int kInteFieldNumber = 18;
  inline float inte() const;
  inline void set_inte(float value);

  // optional float vit = 19 [default = 0];
  inline bool has_vit() const;
  inline void clear_vit();
  static const int kVitFieldNumber = 19;
  inline float vit() const;
  inline void set_vit(float value);

  // optional float agi = 20 [default = 0];
  inline bool has_agi() const;
  inline void clear_agi();
  static const int kAgiFieldNumber = 20;
  inline float agi() const;
  inline void set_agi(float value);

  // optional float luk = 21 [default = 0];
  inline bool has_luk() const;
  inline void clear_luk();
  static const int kLukFieldNumber = 21;
  inline float luk() const;
  inline void set_luk(float value);

  // optional float atk = 22 [default = 0];
  inline bool has_atk() const;
  inline void clear_atk();
  static const int kAtkFieldNumber = 22;
  inline float atk() const;
  inline void set_atk(float value);

  // optional float matk = 23 [default = 0];
  inline bool has_matk() const;
  inline void clear_matk();
  static const int kMatkFieldNumber = 23;
  inline float matk() const;
  inline void set_matk(float value);

  // optional float def = 24 [default = 0];
  inline bool has_def() const;
  inline void clear_def();
  static const int kDefFieldNumber = 24;
  inline float def() const;
  inline void set_def(float value);

  // optional float mdef = 25 [default = 0];
  inline bool has_mdef() const;
  inline void clear_mdef();
  static const int kMdefFieldNumber = 25;
  inline float mdef() const;
  inline void set_mdef(float value);

  // optional float hp = 26 [default = 0];
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 26;
  inline float hp() const;
  inline void set_hp(float value);

  // optional float hit = 27 [default = 0];
  inline bool has_hit() const;
  inline void clear_hit();
  static const int kHitFieldNumber = 27;
  inline float hit() const;
  inline void set_hit(float value);

  // optional float flee = 28 [default = 0];
  inline bool has_flee() const;
  inline void clear_flee();
  static const int kFleeFieldNumber = 28;
  inline float flee() const;
  inline void set_flee(float value);

  // optional float movespd = 29 [default = 0];
  inline bool has_movespd() const;
  inline void clear_movespd();
  static const int kMovespdFieldNumber = 29;
  inline float movespd() const;
  inline void set_movespd(float value);

  // optional float movespdrate = 30 [default = 0];
  inline bool has_movespdrate() const;
  inline void clear_movespdrate();
  static const int kMovespdrateFieldNumber = 30;
  inline float movespdrate() const;
  inline void set_movespdrate(float value);

  // optional float scale = 31 [default = 0];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 31;
  inline float scale() const;
  inline void set_scale(float value);

  // optional uint32 normalskill = 32 [default = 0];
  inline bool has_normalskill() const;
  inline void clear_normalskill();
  static const int kNormalskillFieldNumber = 32;
  inline ::google::protobuf::uint32 normalskill() const;
  inline void set_normalskill(::google::protobuf::uint32 value);

  // optional uint32 rewardid = 33 [default = 0];
  inline bool has_rewardid() const;
  inline void clear_rewardid();
  static const int kRewardidFieldNumber = 33;
  inline ::google::protobuf::uint32 rewardid() const;
  inline void set_rewardid(::google::protobuf::uint32 value);

  // repeated .Cmd.AEReward rewards = 34;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 34;
  inline const ::Cmd::AEReward& rewards(int index) const;
  inline ::Cmd::AEReward* mutable_rewards(int index);
  inline ::Cmd::AEReward* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >*
      mutable_rewards();

  // repeated .Cmd.AEMap map = 35;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 35;
  inline const ::Cmd::AEMap& map(int index) const;
  inline ::Cmd::AEMap* mutable_map(int index);
  inline ::Cmd::AEMap* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >*
      mutable_map();

  // @@protoc_insertion_point(class_scope:Cmd.AESummonInfo)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_revive();
  inline void clear_has_revive();
  inline void set_has_iscreate();
  inline void clear_has_iscreate();
  inline void set_has_namezh();
  inline void clear_has_namezh();
  inline void set_has_nameen();
  inline void clear_has_nameen();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_zone();
  inline void clear_has_zone();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_nature();
  inline void clear_has_nature();
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_jobexp();
  inline void clear_has_jobexp();
  inline void set_has_baseexp();
  inline void clear_has_baseexp();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_dex();
  inline void clear_has_dex();
  inline void set_has_inte();
  inline void clear_has_inte();
  inline void set_has_vit();
  inline void clear_has_vit();
  inline void set_has_agi();
  inline void clear_has_agi();
  inline void set_has_luk();
  inline void clear_has_luk();
  inline void set_has_atk();
  inline void clear_has_atk();
  inline void set_has_matk();
  inline void clear_has_matk();
  inline void set_has_def();
  inline void clear_has_def();
  inline void set_has_mdef();
  inline void clear_has_mdef();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_hit();
  inline void clear_has_hit();
  inline void set_has_flee();
  inline void clear_has_flee();
  inline void set_has_movespd();
  inline void clear_has_movespd();
  inline void set_has_movespdrate();
  inline void clear_has_movespdrate();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_normalskill();
  inline void clear_has_normalskill();
  inline void set_has_rewardid();
  inline void clear_has_rewardid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[2];
  ::google::protobuf::uint32 monsterid_;
  ::google::protobuf::uint32 count_;
  ::std::string* namezh_;
  ::std::string* nameen_;
  bool revive_;
  bool iscreate_;
  ::google::protobuf::uint32 body_;
  ::std::string* icon_;
  ::std::string* type_;
  ::std::string* zone_;
  ::std::string* race_;
  ::std::string* nature_;
  ::std::string* shape_;
  ::google::protobuf::uint32 jobexp_;
  ::google::protobuf::uint32 baseexp_;
  float str_;
  float dex_;
  float inte_;
  float vit_;
  float agi_;
  float luk_;
  float atk_;
  float matk_;
  float def_;
  float mdef_;
  float hp_;
  float hit_;
  float flee_;
  float movespd_;
  float movespdrate_;
  float scale_;
  ::google::protobuf::uint32 normalskill_;
  ::google::protobuf::uint32 rewardid_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward > rewards_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap > map_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AESummonInfo* default_instance_;
};
// -------------------------------------------------------------------

class AERewardExtraInfo : public ::google::protobuf::Message {
 public:
  AERewardExtraInfo();
  virtual ~AERewardExtraInfo();

  AERewardExtraInfo(const AERewardExtraInfo& from);

  inline AERewardExtraInfo& operator=(const AERewardExtraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AERewardExtraInfo& default_instance();

  void Swap(AERewardExtraInfo* other);

  // implements Message ----------------------------------------------

  AERewardExtraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AERewardExtraInfo& from);
  void MergeFrom(const AERewardExtraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.AEReward rewards = 1;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 1;
  inline const ::Cmd::AEReward& rewards(int index) const;
  inline ::Cmd::AEReward* mutable_rewards(int index);
  inline ::Cmd::AEReward* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >*
      mutable_rewards();

  // optional uint32 finishcount = 2 [default = 0];
  inline bool has_finishcount() const;
  inline void clear_finishcount();
  static const int kFinishcountFieldNumber = 2;
  inline ::google::protobuf::uint32 finishcount() const;
  inline void set_finishcount(::google::protobuf::uint32 value);

  // optional uint32 daylimit = 3 [default = 0];
  inline bool has_daylimit() const;
  inline void clear_daylimit();
  static const int kDaylimitFieldNumber = 3;
  inline ::google::protobuf::uint32 daylimit() const;
  inline void set_daylimit(::google::protobuf::uint32 value);

  // optional bool acclimit = 4 [default = false];
  inline bool has_acclimit() const;
  inline void clear_acclimit();
  static const int kAcclimitFieldNumber = 4;
  inline bool acclimit() const;
  inline void set_acclimit(bool value);

  // @@protoc_insertion_point(class_scope:Cmd.AERewardExtraInfo)
 private:
  inline void set_has_finishcount();
  inline void clear_has_finishcount();
  inline void set_has_daylimit();
  inline void clear_has_daylimit();
  inline void set_has_acclimit();
  inline void clear_has_acclimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward > rewards_;
  ::google::protobuf::uint32 finishcount_;
  ::google::protobuf::uint32 daylimit_;
  bool acclimit_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AERewardExtraInfo* default_instance_;
};
// -------------------------------------------------------------------

class AERewardMultipleInfo : public ::google::protobuf::Message {
 public:
  AERewardMultipleInfo();
  virtual ~AERewardMultipleInfo();

  AERewardMultipleInfo(const AERewardMultipleInfo& from);

  inline AERewardMultipleInfo& operator=(const AERewardMultipleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AERewardMultipleInfo& default_instance();

  void Swap(AERewardMultipleInfo* other);

  // implements Message ----------------------------------------------

  AERewardMultipleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AERewardMultipleInfo& from);
  void MergeFrom(const AERewardMultipleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 multiple = 1 [default = 1];
  inline bool has_multiple() const;
  inline void clear_multiple();
  static const int kMultipleFieldNumber = 1;
  inline ::google::protobuf::uint32 multiple() const;
  inline void set_multiple(::google::protobuf::uint32 value);

  // optional uint32 finishcount = 2 [default = 0];
  inline bool has_finishcount() const;
  inline void clear_finishcount();
  static const int kFinishcountFieldNumber = 2;
  inline ::google::protobuf::uint32 finishcount() const;
  inline void set_finishcount(::google::protobuf::uint32 value);

  // optional uint32 daylimit = 3 [default = 0];
  inline bool has_daylimit() const;
  inline void clear_daylimit();
  static const int kDaylimitFieldNumber = 3;
  inline ::google::protobuf::uint32 daylimit() const;
  inline void set_daylimit(::google::protobuf::uint32 value);

  // optional bool acclimit = 4 [default = false];
  inline bool has_acclimit() const;
  inline void clear_acclimit();
  static const int kAcclimitFieldNumber = 4;
  inline bool acclimit() const;
  inline void set_acclimit(bool value);

  // @@protoc_insertion_point(class_scope:Cmd.AERewardMultipleInfo)
 private:
  inline void set_has_multiple();
  inline void clear_has_multiple();
  inline void set_has_finishcount();
  inline void clear_has_finishcount();
  inline void set_has_daylimit();
  inline void clear_has_daylimit();
  inline void set_has_acclimit();
  inline void clear_has_acclimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 multiple_;
  ::google::protobuf::uint32 finishcount_;
  ::google::protobuf::uint32 daylimit_;
  bool acclimit_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AERewardMultipleInfo* default_instance_;
};
// -------------------------------------------------------------------

class AERewardInfo : public ::google::protobuf::Message {
 public:
  AERewardInfo();
  virtual ~AERewardInfo();

  AERewardInfo(const AERewardInfo& from);

  inline AERewardInfo& operator=(const AERewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AERewardInfo& default_instance();

  void Swap(AERewardInfo* other);

  // implements Message ----------------------------------------------

  AERewardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AERewardInfo& from);
  void MergeFrom(const AERewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::Cmd::EAERewardMode mode() const;
  inline void set_mode(::Cmd::EAERewardMode value);

  // optional .Cmd.AERewardExtraInfo extrareward = 2;
  inline bool has_extrareward() const;
  inline void clear_extrareward();
  static const int kExtrarewardFieldNumber = 2;
  inline const ::Cmd::AERewardExtraInfo& extrareward() const;
  inline ::Cmd::AERewardExtraInfo* mutable_extrareward();
  inline ::Cmd::AERewardExtraInfo* release_extrareward();
  inline void set_allocated_extrareward(::Cmd::AERewardExtraInfo* extrareward);

  // optional .Cmd.AERewardMultipleInfo multiplereward = 3;
  inline bool has_multiplereward() const;
  inline void clear_multiplereward();
  static const int kMultiplerewardFieldNumber = 3;
  inline const ::Cmd::AERewardMultipleInfo& multiplereward() const;
  inline ::Cmd::AERewardMultipleInfo* mutable_multiplereward();
  inline ::Cmd::AERewardMultipleInfo* release_multiplereward();
  inline void set_allocated_multiplereward(::Cmd::AERewardMultipleInfo* multiplereward);

  // optional uint32 extratimes = 4 [default = 0];
  inline bool has_extratimes() const;
  inline void clear_extratimes();
  static const int kExtratimesFieldNumber = 4;
  inline ::google::protobuf::uint32 extratimes() const;
  inline void set_extratimes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.AERewardInfo)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_extrareward();
  inline void clear_has_extrareward();
  inline void set_has_multiplereward();
  inline void clear_has_multiplereward();
  inline void set_has_extratimes();
  inline void clear_has_extratimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Cmd::AERewardExtraInfo* extrareward_;
  int mode_;
  ::google::protobuf::uint32 extratimes_;
  ::Cmd::AERewardMultipleInfo* multiplereward_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AERewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class AELotteryDiscount : public ::google::protobuf::Message {
 public:
  AELotteryDiscount();
  virtual ~AELotteryDiscount();

  AELotteryDiscount(const AELotteryDiscount& from);

  inline AELotteryDiscount& operator=(const AELotteryDiscount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AELotteryDiscount& default_instance();

  void Swap(AELotteryDiscount* other);

  // implements Message ----------------------------------------------

  AELotteryDiscount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELotteryDiscount& from);
  void MergeFrom(const AELotteryDiscount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.ELotteryType lotterytype = 1;
  inline bool has_lotterytype() const;
  inline void clear_lotterytype();
  static const int kLotterytypeFieldNumber = 1;
  inline ::Cmd::ELotteryType lotterytype() const;
  inline void set_lotterytype(::Cmd::ELotteryType value);

  // optional .Cmd.ECoinType cointype = 2;
  inline bool has_cointype() const;
  inline void clear_cointype();
  static const int kCointypeFieldNumber = 2;
  inline ::Cmd::ECoinType cointype() const;
  inline void set_cointype(::Cmd::ECoinType value);

  // optional .Cmd.EUserType usertype = 3;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUsertypeFieldNumber = 3;
  inline ::Cmd::EUserType usertype() const;
  inline void set_usertype(::Cmd::EUserType value);

  // optional uint32 discount = 4;
  inline bool has_discount() const;
  inline void clear_discount();
  static const int kDiscountFieldNumber = 4;
  inline ::google::protobuf::uint32 discount() const;
  inline void set_discount(::google::protobuf::uint32 value);

  // optional uint32 count = 5;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 5;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 yearmonth = 7;
  inline bool has_yearmonth() const;
  inline void clear_yearmonth();
  static const int kYearmonthFieldNumber = 7;
  inline ::google::protobuf::uint32 yearmonth() const;
  inline void set_yearmonth(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.AELotteryDiscount)
 private:
  inline void set_has_lotterytype();
  inline void clear_has_lotterytype();
  inline void set_has_cointype();
  inline void clear_has_cointype();
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_discount();
  inline void clear_has_discount();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_yearmonth();
  inline void clear_has_yearmonth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int lotterytype_;
  int cointype_;
  int usertype_;
  ::google::protobuf::uint32 discount_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 yearmonth_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AELotteryDiscount* default_instance_;
};
// -------------------------------------------------------------------

class AELotteryNpc : public ::google::protobuf::Message {
 public:
  AELotteryNpc();
  virtual ~AELotteryNpc();

  AELotteryNpc(const AELotteryNpc& from);

  inline AELotteryNpc& operator=(const AELotteryNpc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AELotteryNpc& default_instance();

  void Swap(AELotteryNpc* other);

  // implements Message ----------------------------------------------

  AELotteryNpc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELotteryNpc& from);
  void MergeFrom(const AELotteryNpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.ELotteryType lotterytype = 1;
  inline bool has_lotterytype() const;
  inline void clear_lotterytype();
  static const int kLotterytypeFieldNumber = 1;
  inline ::Cmd::ELotteryType lotterytype() const;
  inline void set_lotterytype(::Cmd::ELotteryType value);

  // repeated .Cmd.AEMap map = 2;
  inline int map_size() const;
  inline void clear_map();
  static const int kMapFieldNumber = 2;
  inline const ::Cmd::AEMap& map(int index) const;
  inline ::Cmd::AEMap* mutable_map(int index);
  inline ::Cmd::AEMap* add_map();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >&
      map() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >*
      mutable_map();

  // @@protoc_insertion_point(class_scope:Cmd.AELotteryNpc)
 private:
  inline void set_has_lotterytype();
  inline void clear_has_lotterytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap > map_;
  int lotterytype_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AELotteryNpc* default_instance_;
};
// -------------------------------------------------------------------

class AEUrl : public ::google::protobuf::Message {
 public:
  AEUrl();
  virtual ~AEUrl();

  AEUrl(const AEUrl& from);

  inline AEUrl& operator=(const AEUrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEUrl& default_instance();

  void Swap(AEUrl* other);

  // implements Message ----------------------------------------------

  AEUrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEUrl& from);
  void MergeFrom(const AEUrl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 language = 1 [default = 0];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline ::google::protobuf::uint32 language() const;
  inline void set_language(::google::protobuf::uint32 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:Cmd.AEUrl)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* url_;
  ::google::protobuf::uint32 language_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEUrl* default_instance_;
};
// -------------------------------------------------------------------

class AELotteryBanner : public ::google::protobuf::Message {
 public:
  AELotteryBanner();
  virtual ~AELotteryBanner();

  AELotteryBanner(const AELotteryBanner& from);

  inline AELotteryBanner& operator=(const AELotteryBanner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AELotteryBanner& default_instance();

  void Swap(AELotteryBanner* other);

  // implements Message ----------------------------------------------

  AELotteryBanner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AELotteryBanner& from);
  void MergeFrom(const AELotteryBanner& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.ELotteryType lotterytype = 1;
  inline bool has_lotterytype() const;
  inline void clear_lotterytype();
  static const int kLotterytypeFieldNumber = 1;
  inline ::Cmd::ELotteryType lotterytype() const;
  inline void set_lotterytype(::Cmd::ELotteryType value);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // repeated .Cmd.AEUrl urls = 3;
  inline int urls_size() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 3;
  inline const ::Cmd::AEUrl& urls(int index) const;
  inline ::Cmd::AEUrl* mutable_urls(int index);
  inline ::Cmd::AEUrl* add_urls();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEUrl >&
      urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEUrl >*
      mutable_urls();

  // @@protoc_insertion_point(class_scope:Cmd.AELotteryBanner)
 private:
  inline void set_has_lotterytype();
  inline void clear_has_lotterytype();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEUrl > urls_;
  int lotterytype_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AELotteryBanner* default_instance_;
};
// -------------------------------------------------------------------

class AEGuildBuildingSubmitInfo : public ::google::protobuf::Message {
 public:
  AEGuildBuildingSubmitInfo();
  virtual ~AEGuildBuildingSubmitInfo();

  AEGuildBuildingSubmitInfo(const AEGuildBuildingSubmitInfo& from);

  inline AEGuildBuildingSubmitInfo& operator=(const AEGuildBuildingSubmitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEGuildBuildingSubmitInfo& default_instance();

  void Swap(AEGuildBuildingSubmitInfo* other);

  // implements Message ----------------------------------------------

  AEGuildBuildingSubmitInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEGuildBuildingSubmitInfo& from);
  void MergeFrom(const AEGuildBuildingSubmitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.EGuildBuilding types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline ::Cmd::EGuildBuilding types(int index) const;
  inline void set_types(int index, ::Cmd::EGuildBuilding value);
  inline void add_types(::Cmd::EGuildBuilding value);
  inline const ::google::protobuf::RepeatedField<int>& types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_types();

  // optional uint32 minlv = 2 [default = 0];
  inline bool has_minlv() const;
  inline void clear_minlv();
  static const int kMinlvFieldNumber = 2;
  inline ::google::protobuf::uint32 minlv() const;
  inline void set_minlv(::google::protobuf::uint32 value);

  // optional uint32 maxlv = 3 [default = 0];
  inline bool has_maxlv() const;
  inline void clear_maxlv();
  static const int kMaxlvFieldNumber = 3;
  inline ::google::protobuf::uint32 maxlv() const;
  inline void set_maxlv(::google::protobuf::uint32 value);

  // optional uint32 submitinc = 4 [default = 0];
  inline bool has_submitinc() const;
  inline void clear_submitinc();
  static const int kSubmitincFieldNumber = 4;
  inline ::google::protobuf::uint32 submitinc() const;
  inline void set_submitinc(::google::protobuf::uint32 value);

  // optional uint32 rewardinc = 5 [default = 0];
  inline bool has_rewardinc() const;
  inline void clear_rewardinc();
  static const int kRewardincFieldNumber = 5;
  inline ::google::protobuf::uint32 rewardinc() const;
  inline void set_rewardinc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.AEGuildBuildingSubmitInfo)
 private:
  inline void set_has_minlv();
  inline void clear_has_minlv();
  inline void set_has_maxlv();
  inline void clear_has_maxlv();
  inline void set_has_submitinc();
  inline void clear_has_submitinc();
  inline void set_has_rewardinc();
  inline void clear_has_rewardinc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> types_;
  ::google::protobuf::uint32 minlv_;
  ::google::protobuf::uint32 maxlv_;
  ::google::protobuf::uint32 submitinc_;
  ::google::protobuf::uint32 rewardinc_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEGuildBuildingSubmitInfo* default_instance_;
};
// -------------------------------------------------------------------

class AEShopInfo : public ::google::protobuf::Message {
 public:
  AEShopInfo();
  virtual ~AEShopInfo();

  AEShopInfo(const AEShopInfo& from);

  inline AEShopInfo& operator=(const AEShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEShopInfo& default_instance();

  void Swap(AEShopInfo* other);

  // implements Message ----------------------------------------------

  AEShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEShopInfo& from);
  void MergeFrom(const AEShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Cmd.ShopItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Cmd::ShopItem& items(int index) const;
  inline ::Cmd::ShopItem* mutable_items(int index);
  inline ::Cmd::ShopItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ShopItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::ShopItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Cmd.AEShopInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::ShopItem > items_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEventInfo : public ::google::protobuf::Message {
 public:
  ActivityEventInfo();
  virtual ~ActivityEventInfo();

  ActivityEventInfo(const ActivityEventInfo& from);

  inline ActivityEventInfo& operator=(const ActivityEventInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEventInfo& default_instance();

  void Swap(ActivityEventInfo* other);

  // implements Message ----------------------------------------------

  ActivityEventInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEventInfo& from);
  void MergeFrom(const ActivityEventInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint64 begintime = 2 [default = 0];
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 2;
  inline ::google::protobuf::uint64 begintime() const;
  inline void set_begintime(::google::protobuf::uint64 value);

  // optional uint64 endtime = 3 [default = 0];
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional .Cmd.EActivityEventType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::Cmd::EActivityEventType type() const;
  inline void set_type(::Cmd::EActivityEventType value);

  // optional .Cmd.AEFreeTransferInfo freetransferinfo = 5;
  inline bool has_freetransferinfo() const;
  inline void clear_freetransferinfo();
  static const int kFreetransferinfoFieldNumber = 5;
  inline const ::Cmd::AEFreeTransferInfo& freetransferinfo() const;
  inline ::Cmd::AEFreeTransferInfo* mutable_freetransferinfo();
  inline ::Cmd::AEFreeTransferInfo* release_freetransferinfo();
  inline void set_allocated_freetransferinfo(::Cmd::AEFreeTransferInfo* freetransferinfo);

  // optional .Cmd.AESummonInfo summoninfo = 6;
  inline bool has_summoninfo() const;
  inline void clear_summoninfo();
  static const int kSummoninfoFieldNumber = 6;
  inline const ::Cmd::AESummonInfo& summoninfo() const;
  inline ::Cmd::AESummonInfo* mutable_summoninfo();
  inline ::Cmd::AESummonInfo* release_summoninfo();
  inline void set_allocated_summoninfo(::Cmd::AESummonInfo* summoninfo);

  // optional .Cmd.AERewardInfo rewardinfo = 7;
  inline bool has_rewardinfo() const;
  inline void clear_rewardinfo();
  static const int kRewardinfoFieldNumber = 7;
  inline const ::Cmd::AERewardInfo& rewardinfo() const;
  inline ::Cmd::AERewardInfo* mutable_rewardinfo();
  inline ::Cmd::AERewardInfo* release_rewardinfo();
  inline void set_allocated_rewardinfo(::Cmd::AERewardInfo* rewardinfo);

  // optional .Cmd.AEResetInfo resetinfo = 8;
  inline bool has_resetinfo() const;
  inline void clear_resetinfo();
  static const int kResetinfoFieldNumber = 8;
  inline const ::Cmd::AEResetInfo& resetinfo() const;
  inline ::Cmd::AEResetInfo* mutable_resetinfo();
  inline ::Cmd::AEResetInfo* release_resetinfo();
  inline void set_allocated_resetinfo(::Cmd::AEResetInfo* resetinfo);

  // optional .Cmd.AELotteryDiscount lotterydiscount = 9;
  inline bool has_lotterydiscount() const;
  inline void clear_lotterydiscount();
  static const int kLotterydiscountFieldNumber = 9;
  inline const ::Cmd::AELotteryDiscount& lotterydiscount() const;
  inline ::Cmd::AELotteryDiscount* mutable_lotterydiscount();
  inline ::Cmd::AELotteryDiscount* release_lotterydiscount();
  inline void set_allocated_lotterydiscount(::Cmd::AELotteryDiscount* lotterydiscount);

  // optional .Cmd.AELotteryNpc lotterynpc = 10;
  inline bool has_lotterynpc() const;
  inline void clear_lotterynpc();
  static const int kLotterynpcFieldNumber = 10;
  inline const ::Cmd::AELotteryNpc& lotterynpc() const;
  inline ::Cmd::AELotteryNpc* mutable_lotterynpc();
  inline ::Cmd::AELotteryNpc* release_lotterynpc();
  inline void set_allocated_lotterynpc(::Cmd::AELotteryNpc* lotterynpc);

  // optional .Cmd.AELotteryBanner lotterybanner = 11;
  inline bool has_lotterybanner() const;
  inline void clear_lotterybanner();
  static const int kLotterybannerFieldNumber = 11;
  inline const ::Cmd::AELotteryBanner& lotterybanner() const;
  inline ::Cmd::AELotteryBanner* mutable_lotterybanner();
  inline ::Cmd::AELotteryBanner* release_lotterybanner();
  inline void set_allocated_lotterybanner(::Cmd::AELotteryBanner* lotterybanner);

  // optional .Cmd.AEGuildBuildingSubmitInfo gbuildingsubmitinfo = 12;
  inline bool has_gbuildingsubmitinfo() const;
  inline void clear_gbuildingsubmitinfo();
  static const int kGbuildingsubmitinfoFieldNumber = 12;
  inline const ::Cmd::AEGuildBuildingSubmitInfo& gbuildingsubmitinfo() const;
  inline ::Cmd::AEGuildBuildingSubmitInfo* mutable_gbuildingsubmitinfo();
  inline ::Cmd::AEGuildBuildingSubmitInfo* release_gbuildingsubmitinfo();
  inline void set_allocated_gbuildingsubmitinfo(::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmitinfo);

  // optional .Cmd.AEShopInfo shopinfo = 13;
  inline bool has_shopinfo() const;
  inline void clear_shopinfo();
  static const int kShopinfoFieldNumber = 13;
  inline const ::Cmd::AEShopInfo& shopinfo() const;
  inline ::Cmd::AEShopInfo* mutable_shopinfo();
  inline ::Cmd::AEShopInfo* release_shopinfo();
  inline void set_allocated_shopinfo(::Cmd::AEShopInfo* shopinfo);

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEventInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_freetransferinfo();
  inline void clear_has_freetransferinfo();
  inline void set_has_summoninfo();
  inline void clear_has_summoninfo();
  inline void set_has_rewardinfo();
  inline void clear_has_rewardinfo();
  inline void set_has_resetinfo();
  inline void clear_has_resetinfo();
  inline void set_has_lotterydiscount();
  inline void clear_has_lotterydiscount();
  inline void set_has_lotterynpc();
  inline void clear_has_lotterynpc();
  inline void set_has_lotterybanner();
  inline void clear_has_lotterybanner();
  inline void set_has_gbuildingsubmitinfo();
  inline void clear_has_gbuildingsubmitinfo();
  inline void set_has_shopinfo();
  inline void clear_has_shopinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 begintime_;
  ::google::protobuf::uint64 endtime_;
  ::Cmd::AEFreeTransferInfo* freetransferinfo_;
  ::Cmd::AESummonInfo* summoninfo_;
  ::Cmd::AERewardInfo* rewardinfo_;
  ::Cmd::AEResetInfo* resetinfo_;
  ::Cmd::AELotteryDiscount* lotterydiscount_;
  ::Cmd::AELotteryNpc* lotterynpc_;
  ::Cmd::AELotteryBanner* lotterybanner_;
  ::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmitinfo_;
  ::Cmd::AEShopInfo* shopinfo_;
  int type_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEventInfo* default_instance_;
};
// -------------------------------------------------------------------

class AEResetInfo : public ::google::protobuf::Message {
 public:
  AEResetInfo();
  virtual ~AEResetInfo();

  AEResetInfo(const AEResetInfo& from);

  inline AEResetInfo& operator=(const AEResetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AEResetInfo& default_instance();

  void Swap(AEResetInfo* other);

  // implements Message ----------------------------------------------

  AEResetInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AEResetInfo& from);
  void MergeFrom(const AEResetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::Cmd::EAERewardMode mode() const;
  inline void set_mode(::Cmd::EAERewardMode value);

  // optional uint32 times = 2 [default = 0];
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::uint32 times() const;
  inline void set_times(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.AEResetInfo)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 times_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AEResetInfo* default_instance_;
};
// -------------------------------------------------------------------

class AERewardItem : public ::google::protobuf::Message {
 public:
  AERewardItem();
  virtual ~AERewardItem();

  AERewardItem(const AERewardItem& from);

  inline AERewardItem& operator=(const AERewardItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AERewardItem& default_instance();

  void Swap(AERewardItem* other);

  // implements Message ----------------------------------------------

  AERewardItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AERewardItem& from);
  void MergeFrom(const AERewardItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 1;
  inline ::Cmd::EAERewardMode mode() const;
  inline void set_mode(::Cmd::EAERewardMode value);

  // optional uint32 daycount = 2 [default = 0];
  inline bool has_daycount() const;
  inline void clear_daycount();
  static const int kDaycountFieldNumber = 2;
  inline ::google::protobuf::uint32 daycount() const;
  inline void set_daycount(::google::protobuf::uint32 value);

  // optional uint64 acclimitcharid = 3 [default = 0];
  inline bool has_acclimitcharid() const;
  inline void clear_acclimitcharid();
  static const int kAcclimitcharidFieldNumber = 3;
  inline ::google::protobuf::uint64 acclimitcharid() const;
  inline void set_acclimitcharid(::google::protobuf::uint64 value);

  // optional uint32 multipledaycount = 4 [default = 0];
  inline bool has_multipledaycount() const;
  inline void clear_multipledaycount();
  static const int kMultipledaycountFieldNumber = 4;
  inline ::google::protobuf::uint32 multipledaycount() const;
  inline void set_multipledaycount(::google::protobuf::uint32 value);

  // optional uint64 multipleacclimitcharid = 5 [default = 0];
  inline bool has_multipleacclimitcharid() const;
  inline void clear_multipleacclimitcharid();
  static const int kMultipleacclimitcharidFieldNumber = 5;
  inline ::google::protobuf::uint64 multipleacclimitcharid() const;
  inline void set_multipleacclimitcharid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Cmd.AERewardItem)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_daycount();
  inline void clear_has_daycount();
  inline void set_has_acclimitcharid();
  inline void clear_has_acclimitcharid();
  inline void set_has_multipledaycount();
  inline void clear_has_multipledaycount();
  inline void set_has_multipleacclimitcharid();
  inline void clear_has_multipleacclimitcharid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 daycount_;
  ::google::protobuf::uint64 acclimitcharid_;
  ::google::protobuf::uint64 multipleacclimitcharid_;
  ::google::protobuf::uint32 multipledaycount_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static AERewardItem* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEvent : public ::google::protobuf::Message {
 public:
  ActivityEvent();
  virtual ~ActivityEvent();

  ActivityEvent(const ActivityEvent& from);

  inline ActivityEvent& operator=(const ActivityEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEvent& default_instance();

  void Swap(ActivityEvent* other);

  // implements Message ----------------------------------------------

  ActivityEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEvent& from);
  void MergeFrom(const ActivityEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.EActivityEventType type = 1 [default = EACTIVITYEVENTTYPE_MIN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Cmd::EActivityEventType type() const;
  inline void set_type(::Cmd::EActivityEventType value);

  // optional uint64 begintime = 2 [default = 0];
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBegintimeFieldNumber = 2;
  inline ::google::protobuf::uint64 begintime() const;
  inline void set_begintime(::google::protobuf::uint64 value);

  // optional uint64 endtime = 3 [default = 0];
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline ::google::protobuf::uint64 endtime() const;
  inline void set_endtime(::google::protobuf::uint64 value);

  // optional .Cmd.AEFreeTransferInfo freetransfer = 4;
  inline bool has_freetransfer() const;
  inline void clear_freetransfer();
  static const int kFreetransferFieldNumber = 4;
  inline const ::Cmd::AEFreeTransferInfo& freetransfer() const;
  inline ::Cmd::AEFreeTransferInfo* mutable_freetransfer();
  inline ::Cmd::AEFreeTransferInfo* release_freetransfer();
  inline void set_allocated_freetransfer(::Cmd::AEFreeTransferInfo* freetransfer);

  // repeated .Cmd.AERewardInfo reward = 5;
  inline int reward_size() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 5;
  inline const ::Cmd::AERewardInfo& reward(int index) const;
  inline ::Cmd::AERewardInfo* mutable_reward(int index);
  inline ::Cmd::AERewardInfo* add_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardInfo >&
      reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardInfo >*
      mutable_reward();

  // repeated .Cmd.AEResetInfo resetinfo = 6;
  inline int resetinfo_size() const;
  inline void clear_resetinfo();
  static const int kResetinfoFieldNumber = 6;
  inline const ::Cmd::AEResetInfo& resetinfo(int index) const;
  inline ::Cmd::AEResetInfo* mutable_resetinfo(int index);
  inline ::Cmd::AEResetInfo* add_resetinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEResetInfo >&
      resetinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEResetInfo >*
      mutable_resetinfo();

  // optional .Cmd.AELotteryDiscount lotterydiscount = 7;
  inline bool has_lotterydiscount() const;
  inline void clear_lotterydiscount();
  static const int kLotterydiscountFieldNumber = 7;
  inline const ::Cmd::AELotteryDiscount& lotterydiscount() const;
  inline ::Cmd::AELotteryDiscount* mutable_lotterydiscount();
  inline ::Cmd::AELotteryDiscount* release_lotterydiscount();
  inline void set_allocated_lotterydiscount(::Cmd::AELotteryDiscount* lotterydiscount);

  // optional .Cmd.AELotteryBanner lotterybanner = 8;
  inline bool has_lotterybanner() const;
  inline void clear_lotterybanner();
  static const int kLotterybannerFieldNumber = 8;
  inline const ::Cmd::AELotteryBanner& lotterybanner() const;
  inline ::Cmd::AELotteryBanner* mutable_lotterybanner();
  inline ::Cmd::AELotteryBanner* release_lotterybanner();
  inline void set_allocated_lotterybanner(::Cmd::AELotteryBanner* lotterybanner);

  // optional uint64 id = 9;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 9;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional .Cmd.AEGuildBuildingSubmitInfo gbuildingsubmit = 10;
  inline bool has_gbuildingsubmit() const;
  inline void clear_gbuildingsubmit();
  static const int kGbuildingsubmitFieldNumber = 10;
  inline const ::Cmd::AEGuildBuildingSubmitInfo& gbuildingsubmit() const;
  inline ::Cmd::AEGuildBuildingSubmitInfo* mutable_gbuildingsubmit();
  inline ::Cmd::AEGuildBuildingSubmitInfo* release_gbuildingsubmit();
  inline void set_allocated_gbuildingsubmit(::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmit);

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEvent)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_freetransfer();
  inline void clear_has_freetransfer();
  inline void set_has_lotterydiscount();
  inline void clear_has_lotterydiscount();
  inline void set_has_lotterybanner();
  inline void clear_has_lotterybanner();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gbuildingsubmit();
  inline void clear_has_gbuildingsubmit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 begintime_;
  ::google::protobuf::uint64 endtime_;
  ::Cmd::AEFreeTransferInfo* freetransfer_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardInfo > reward_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AEResetInfo > resetinfo_;
  ::Cmd::AELotteryDiscount* lotterydiscount_;
  ::Cmd::AELotteryBanner* lotterybanner_;
  ::google::protobuf::uint64 id_;
  ::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmit_;
  int type_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEvent* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEventNtf : public ::google::protobuf::Message {
 public:
  ActivityEventNtf();
  virtual ~ActivityEventNtf();

  ActivityEventNtf(const ActivityEventNtf& from);

  inline ActivityEventNtf& operator=(const ActivityEventNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEventNtf& default_instance();

  void Swap(ActivityEventNtf* other);

  // implements Message ----------------------------------------------

  ActivityEventNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEventNtf& from);
  void MergeFrom(const ActivityEventNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_NTF];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::ActivityEventParam param() const;
  inline void set_param(::Cmd::ActivityEventParam value);

  // repeated .Cmd.ActivityEvent events = 3;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 3;
  inline const ::Cmd::ActivityEvent& events(int index) const;
  inline ::Cmd::ActivityEvent* mutable_events(int index);
  inline ::Cmd::ActivityEvent* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEvent >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEvent >*
      mutable_events();

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEventNtf)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEvent > events_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEventNtf* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEventUserDataNtf : public ::google::protobuf::Message {
 public:
  ActivityEventUserDataNtf();
  virtual ~ActivityEventUserDataNtf();

  ActivityEventUserDataNtf(const ActivityEventUserDataNtf& from);

  inline ActivityEventUserDataNtf& operator=(const ActivityEventUserDataNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEventUserDataNtf& default_instance();

  void Swap(ActivityEventUserDataNtf* other);

  // implements Message ----------------------------------------------

  ActivityEventUserDataNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEventUserDataNtf& from);
  void MergeFrom(const ActivityEventUserDataNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_USER_DATA_NTF];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::ActivityEventParam param() const;
  inline void set_param(::Cmd::ActivityEventParam value);

  // repeated .Cmd.AERewardItem rewarditems = 3;
  inline int rewarditems_size() const;
  inline void clear_rewarditems();
  static const int kRewarditemsFieldNumber = 3;
  inline const ::Cmd::AERewardItem& rewarditems(int index) const;
  inline ::Cmd::AERewardItem* mutable_rewarditems(int index);
  inline ::Cmd::AERewardItem* add_rewarditems();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardItem >&
      rewarditems() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardItem >*
      mutable_rewarditems();

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEventUserDataNtf)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardItem > rewarditems_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEventUserDataNtf* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEventCnt : public ::google::protobuf::Message {
 public:
  ActivityEventCnt();
  virtual ~ActivityEventCnt();

  ActivityEventCnt(const ActivityEventCnt& from);

  inline ActivityEventCnt& operator=(const ActivityEventCnt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEventCnt& default_instance();

  void Swap(ActivityEventCnt* other);

  // implements Message ----------------------------------------------

  ActivityEventCnt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEventCnt& from);
  void MergeFrom(const ActivityEventCnt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.EActivityEventType type = 1 [default = EACTIVITYEVENTTYPE_MIN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Cmd::EActivityEventType type() const;
  inline void set_type(::Cmd::EActivityEventType value);

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEventCnt)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  int type_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEventCnt* default_instance_;
};
// -------------------------------------------------------------------

class ActivityEventNtfEventCntCmd : public ::google::protobuf::Message {
 public:
  ActivityEventNtfEventCntCmd();
  virtual ~ActivityEventNtfEventCntCmd();

  ActivityEventNtfEventCntCmd(const ActivityEventNtfEventCntCmd& from);

  inline ActivityEventNtfEventCntCmd& operator=(const ActivityEventNtfEventCntCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityEventNtfEventCntCmd& default_instance();

  void Swap(ActivityEventNtfEventCntCmd* other);

  // implements Message ----------------------------------------------

  ActivityEventNtfEventCntCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityEventNtfEventCntCmd& from);
  void MergeFrom(const ActivityEventNtfEventCntCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_NTF_EVENT_CNT];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::ActivityEventParam param() const;
  inline void set_param(::Cmd::ActivityEventParam value);

  // repeated .Cmd.ActivityEventCnt cnt = 3;
  inline int cnt_size() const;
  inline void clear_cnt();
  static const int kCntFieldNumber = 3;
  inline const ::Cmd::ActivityEventCnt& cnt(int index) const;
  inline ::Cmd::ActivityEventCnt* mutable_cnt(int index);
  inline ::Cmd::ActivityEventCnt* add_cnt();
  inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEventCnt >&
      cnt() const;
  inline ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEventCnt >*
      mutable_cnt();

  // @@protoc_insertion_point(class_scope:Cmd.ActivityEventNtfEventCntCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEventCnt > cnt_;
  friend void  protobuf_AddDesc_ActivityEvent_2eproto();
  friend void protobuf_AssignDesc_ActivityEvent_2eproto();
  friend void protobuf_ShutdownFile_ActivityEvent_2eproto();

  void InitAsDefaultInstance();
  static ActivityEventNtfEventCntCmd* default_instance_;
};
// ===================================================================


// ===================================================================

// AEReward

// optional uint32 id = 1 [default = 0];
inline bool AEReward::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEReward::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEReward::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEReward::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AEReward::id() const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.id)
  return id_;
}
inline void AEReward::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEReward.id)
}

// optional uint32 count = 2 [default = 0];
inline bool AEReward::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEReward::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEReward::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEReward::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 AEReward::count() const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.count)
  return count_;
}
inline void AEReward::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEReward.count)
}

// optional uint32 weight = 3 [default = 0];
inline bool AEReward::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEReward::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEReward::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEReward::clear_weight() {
  weight_ = 0u;
  clear_has_weight();
}
inline ::google::protobuf::uint32 AEReward::weight() const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.weight)
  return weight_;
}
inline void AEReward::set_weight(::google::protobuf::uint32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEReward.weight)
}

// optional uint32 minlayer = 4 [default = 0];
inline bool AEReward::has_minlayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEReward::set_has_minlayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEReward::clear_has_minlayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEReward::clear_minlayer() {
  minlayer_ = 0u;
  clear_has_minlayer();
}
inline ::google::protobuf::uint32 AEReward::minlayer() const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.minlayer)
  return minlayer_;
}
inline void AEReward::set_minlayer(::google::protobuf::uint32 value) {
  set_has_minlayer();
  minlayer_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEReward.minlayer)
}

// optional uint32 maxlayer = 5 [default = 0];
inline bool AEReward::has_maxlayer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEReward::set_has_maxlayer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEReward::clear_has_maxlayer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEReward::clear_maxlayer() {
  maxlayer_ = 0u;
  clear_has_maxlayer();
}
inline ::google::protobuf::uint32 AEReward::maxlayer() const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.maxlayer)
  return maxlayer_;
}
inline void AEReward::set_maxlayer(::google::protobuf::uint32 value) {
  set_has_maxlayer();
  maxlayer_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEReward.maxlayer)
}

// repeated uint32 difficultys = 6;
inline int AEReward::difficultys_size() const {
  return difficultys_.size();
}
inline void AEReward::clear_difficultys() {
  difficultys_.Clear();
}
inline ::google::protobuf::uint32 AEReward::difficultys(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEReward.difficultys)
  return difficultys_.Get(index);
}
inline void AEReward::set_difficultys(int index, ::google::protobuf::uint32 value) {
  difficultys_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.AEReward.difficultys)
}
inline void AEReward::add_difficultys(::google::protobuf::uint32 value) {
  difficultys_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.AEReward.difficultys)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AEReward::difficultys() const {
  // @@protoc_insertion_point(field_list:Cmd.AEReward.difficultys)
  return difficultys_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AEReward::mutable_difficultys() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEReward.difficultys)
  return &difficultys_;
}

// -------------------------------------------------------------------

// AEMapPos

// repeated float pos = 1;
inline int AEMapPos::pos_size() const {
  return pos_.size();
}
inline void AEMapPos::clear_pos() {
  pos_.Clear();
}
inline float AEMapPos::pos(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEMapPos.pos)
  return pos_.Get(index);
}
inline void AEMapPos::set_pos(int index, float value) {
  pos_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.AEMapPos.pos)
}
inline void AEMapPos::add_pos(float value) {
  pos_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.AEMapPos.pos)
}
inline const ::google::protobuf::RepeatedField< float >&
AEMapPos::pos() const {
  // @@protoc_insertion_point(field_list:Cmd.AEMapPos.pos)
  return pos_;
}
inline ::google::protobuf::RepeatedField< float >*
AEMapPos::mutable_pos() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEMapPos.pos)
  return &pos_;
}

// optional float range = 2 [default = 0];
inline bool AEMapPos::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEMapPos::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEMapPos::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEMapPos::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline float AEMapPos::range() const {
  // @@protoc_insertion_point(field_get:Cmd.AEMapPos.range)
  return range_;
}
inline void AEMapPos::set_range(float value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEMapPos.range)
}

// -------------------------------------------------------------------

// AEMap

// optional uint32 id = 1 [default = 0];
inline bool AEMap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEMap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEMap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEMap::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AEMap::id() const {
  // @@protoc_insertion_point(field_get:Cmd.AEMap.id)
  return id_;
}
inline void AEMap::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEMap.id)
}

// optional string desc = 2;
inline bool AEMap::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEMap::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEMap::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEMap::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& AEMap::desc() const {
  // @@protoc_insertion_point(field_get:Cmd.AEMap.desc)
  return *desc_;
}
inline void AEMap::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AEMap.desc)
}
inline void AEMap::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AEMap.desc)
}
inline void AEMap::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AEMap.desc)
}
inline ::std::string* AEMap::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AEMap.desc)
  return desc_;
}
inline ::std::string* AEMap::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AEMap::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AEMap.desc)
}

// repeated .Cmd.AEMapPos coord = 3;
inline int AEMap::coord_size() const {
  return coord_.size();
}
inline void AEMap::clear_coord() {
  coord_.Clear();
}
inline const ::Cmd::AEMapPos& AEMap::coord(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEMap.coord)
  return coord_.Get(index);
}
inline ::Cmd::AEMapPos* AEMap::mutable_coord(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AEMap.coord)
  return coord_.Mutable(index);
}
inline ::Cmd::AEMapPos* AEMap::add_coord() {
  // @@protoc_insertion_point(field_add:Cmd.AEMap.coord)
  return coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMapPos >&
AEMap::coord() const {
  // @@protoc_insertion_point(field_list:Cmd.AEMap.coord)
  return coord_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMapPos >*
AEMap::mutable_coord() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEMap.coord)
  return &coord_;
}

// -------------------------------------------------------------------

// AEFreeTransferInfo

// repeated uint32 mapids = 1;
inline int AEFreeTransferInfo::mapids_size() const {
  return mapids_.size();
}
inline void AEFreeTransferInfo::clear_mapids() {
  mapids_.Clear();
}
inline ::google::protobuf::uint32 AEFreeTransferInfo::mapids(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEFreeTransferInfo.mapids)
  return mapids_.Get(index);
}
inline void AEFreeTransferInfo::set_mapids(int index, ::google::protobuf::uint32 value) {
  mapids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.AEFreeTransferInfo.mapids)
}
inline void AEFreeTransferInfo::add_mapids(::google::protobuf::uint32 value) {
  mapids_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.AEFreeTransferInfo.mapids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AEFreeTransferInfo::mapids() const {
  // @@protoc_insertion_point(field_list:Cmd.AEFreeTransferInfo.mapids)
  return mapids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AEFreeTransferInfo::mutable_mapids() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEFreeTransferInfo.mapids)
  return &mapids_;
}

// optional bool allfree = 2 [default = false];
inline bool AEFreeTransferInfo::has_allfree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEFreeTransferInfo::set_has_allfree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEFreeTransferInfo::clear_has_allfree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEFreeTransferInfo::clear_allfree() {
  allfree_ = false;
  clear_has_allfree();
}
inline bool AEFreeTransferInfo::allfree() const {
  // @@protoc_insertion_point(field_get:Cmd.AEFreeTransferInfo.allfree)
  return allfree_;
}
inline void AEFreeTransferInfo::set_allfree(bool value) {
  set_has_allfree();
  allfree_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEFreeTransferInfo.allfree)
}

// repeated uint32 teammapids = 3;
inline int AEFreeTransferInfo::teammapids_size() const {
  return teammapids_.size();
}
inline void AEFreeTransferInfo::clear_teammapids() {
  teammapids_.Clear();
}
inline ::google::protobuf::uint32 AEFreeTransferInfo::teammapids(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEFreeTransferInfo.teammapids)
  return teammapids_.Get(index);
}
inline void AEFreeTransferInfo::set_teammapids(int index, ::google::protobuf::uint32 value) {
  teammapids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.AEFreeTransferInfo.teammapids)
}
inline void AEFreeTransferInfo::add_teammapids(::google::protobuf::uint32 value) {
  teammapids_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.AEFreeTransferInfo.teammapids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AEFreeTransferInfo::teammapids() const {
  // @@protoc_insertion_point(field_list:Cmd.AEFreeTransferInfo.teammapids)
  return teammapids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AEFreeTransferInfo::mutable_teammapids() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEFreeTransferInfo.teammapids)
  return &teammapids_;
}

// optional bool teamallfree = 4 [default = false];
inline bool AEFreeTransferInfo::has_teamallfree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEFreeTransferInfo::set_has_teamallfree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEFreeTransferInfo::clear_has_teamallfree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEFreeTransferInfo::clear_teamallfree() {
  teamallfree_ = false;
  clear_has_teamallfree();
}
inline bool AEFreeTransferInfo::teamallfree() const {
  // @@protoc_insertion_point(field_get:Cmd.AEFreeTransferInfo.teamallfree)
  return teamallfree_;
}
inline void AEFreeTransferInfo::set_teamallfree(bool value) {
  set_has_teamallfree();
  teamallfree_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEFreeTransferInfo.teamallfree)
}

// optional bool storefree = 5 [default = false];
inline bool AEFreeTransferInfo::has_storefree() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEFreeTransferInfo::set_has_storefree() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEFreeTransferInfo::clear_has_storefree() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEFreeTransferInfo::clear_storefree() {
  storefree_ = false;
  clear_has_storefree();
}
inline bool AEFreeTransferInfo::storefree() const {
  // @@protoc_insertion_point(field_get:Cmd.AEFreeTransferInfo.storefree)
  return storefree_;
}
inline void AEFreeTransferInfo::set_storefree(bool value) {
  set_has_storefree();
  storefree_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEFreeTransferInfo.storefree)
}

// -------------------------------------------------------------------

// AESummonInfo

// optional uint32 monsterid = 1 [default = 0];
inline bool AESummonInfo::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AESummonInfo::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AESummonInfo::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AESummonInfo::clear_monsterid() {
  monsterid_ = 0u;
  clear_has_monsterid();
}
inline ::google::protobuf::uint32 AESummonInfo::monsterid() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.monsterid)
  return monsterid_;
}
inline void AESummonInfo::set_monsterid(::google::protobuf::uint32 value) {
  set_has_monsterid();
  monsterid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.monsterid)
}

// optional uint32 count = 2 [default = 0];
inline bool AESummonInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AESummonInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AESummonInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AESummonInfo::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 AESummonInfo::count() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.count)
  return count_;
}
inline void AESummonInfo::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.count)
}

// optional bool revive = 3 [default = false];
inline bool AESummonInfo::has_revive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AESummonInfo::set_has_revive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AESummonInfo::clear_has_revive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AESummonInfo::clear_revive() {
  revive_ = false;
  clear_has_revive();
}
inline bool AESummonInfo::revive() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.revive)
  return revive_;
}
inline void AESummonInfo::set_revive(bool value) {
  set_has_revive();
  revive_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.revive)
}

// optional bool iscreate = 4 [default = false];
inline bool AESummonInfo::has_iscreate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AESummonInfo::set_has_iscreate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AESummonInfo::clear_has_iscreate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AESummonInfo::clear_iscreate() {
  iscreate_ = false;
  clear_has_iscreate();
}
inline bool AESummonInfo::iscreate() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.iscreate)
  return iscreate_;
}
inline void AESummonInfo::set_iscreate(bool value) {
  set_has_iscreate();
  iscreate_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.iscreate)
}

// optional string namezh = 5;
inline bool AESummonInfo::has_namezh() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AESummonInfo::set_has_namezh() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AESummonInfo::clear_has_namezh() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AESummonInfo::clear_namezh() {
  if (namezh_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namezh_->clear();
  }
  clear_has_namezh();
}
inline const ::std::string& AESummonInfo::namezh() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.namezh)
  return *namezh_;
}
inline void AESummonInfo::set_namezh(const ::std::string& value) {
  set_has_namezh();
  if (namezh_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namezh_ = new ::std::string;
  }
  namezh_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.namezh)
}
inline void AESummonInfo::set_namezh(const char* value) {
  set_has_namezh();
  if (namezh_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namezh_ = new ::std::string;
  }
  namezh_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.namezh)
}
inline void AESummonInfo::set_namezh(const char* value, size_t size) {
  set_has_namezh();
  if (namezh_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namezh_ = new ::std::string;
  }
  namezh_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.namezh)
}
inline ::std::string* AESummonInfo::mutable_namezh() {
  set_has_namezh();
  if (namezh_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    namezh_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.namezh)
  return namezh_;
}
inline ::std::string* AESummonInfo::release_namezh() {
  clear_has_namezh();
  if (namezh_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = namezh_;
    namezh_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_namezh(::std::string* namezh) {
  if (namezh_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete namezh_;
  }
  if (namezh) {
    set_has_namezh();
    namezh_ = namezh;
  } else {
    clear_has_namezh();
    namezh_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.namezh)
}

// optional string nameen = 6;
inline bool AESummonInfo::has_nameen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AESummonInfo::set_has_nameen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AESummonInfo::clear_has_nameen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AESummonInfo::clear_nameen() {
  if (nameen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nameen_->clear();
  }
  clear_has_nameen();
}
inline const ::std::string& AESummonInfo::nameen() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.nameen)
  return *nameen_;
}
inline void AESummonInfo::set_nameen(const ::std::string& value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.nameen)
}
inline void AESummonInfo::set_nameen(const char* value) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.nameen)
}
inline void AESummonInfo::set_nameen(const char* value, size_t size) {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nameen_ = new ::std::string;
  }
  nameen_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.nameen)
}
inline ::std::string* AESummonInfo::mutable_nameen() {
  set_has_nameen();
  if (nameen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nameen_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.nameen)
  return nameen_;
}
inline ::std::string* AESummonInfo::release_nameen() {
  clear_has_nameen();
  if (nameen_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nameen_;
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_nameen(::std::string* nameen) {
  if (nameen_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nameen_;
  }
  if (nameen) {
    set_has_nameen();
    nameen_ = nameen;
  } else {
    clear_has_nameen();
    nameen_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.nameen)
}

// optional string icon = 7;
inline bool AESummonInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AESummonInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AESummonInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AESummonInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& AESummonInfo::icon() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.icon)
  return *icon_;
}
inline void AESummonInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.icon)
}
inline void AESummonInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.icon)
}
inline void AESummonInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.icon)
}
inline ::std::string* AESummonInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    icon_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.icon)
  return icon_;
}
inline ::std::string* AESummonInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.icon)
}

// optional string type = 8;
inline bool AESummonInfo::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AESummonInfo::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AESummonInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AESummonInfo::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& AESummonInfo::type() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.type)
  return *type_;
}
inline void AESummonInfo::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.type)
}
inline void AESummonInfo::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.type)
}
inline void AESummonInfo::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.type)
}
inline ::std::string* AESummonInfo::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.type)
  return type_;
}
inline ::std::string* AESummonInfo::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.type)
}

// optional string zone = 9;
inline bool AESummonInfo::has_zone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AESummonInfo::set_has_zone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AESummonInfo::clear_has_zone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AESummonInfo::clear_zone() {
  if (zone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zone_->clear();
  }
  clear_has_zone();
}
inline const ::std::string& AESummonInfo::zone() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.zone)
  return *zone_;
}
inline void AESummonInfo::set_zone(const ::std::string& value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.zone)
}
inline void AESummonInfo::set_zone(const char* value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.zone)
}
inline void AESummonInfo::set_zone(const char* value, size_t size) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zone_ = new ::std::string;
  }
  zone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.zone)
}
inline ::std::string* AESummonInfo::mutable_zone() {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    zone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.zone)
  return zone_;
}
inline ::std::string* AESummonInfo::release_zone() {
  clear_has_zone();
  if (zone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = zone_;
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_zone(::std::string* zone) {
  if (zone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete zone_;
  }
  if (zone) {
    set_has_zone();
    zone_ = zone;
  } else {
    clear_has_zone();
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.zone)
}

// optional string race = 10;
inline bool AESummonInfo::has_race() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AESummonInfo::set_has_race() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AESummonInfo::clear_has_race() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AESummonInfo::clear_race() {
  if (race_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    race_->clear();
  }
  clear_has_race();
}
inline const ::std::string& AESummonInfo::race() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.race)
  return *race_;
}
inline void AESummonInfo::set_race(const ::std::string& value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    race_ = new ::std::string;
  }
  race_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.race)
}
inline void AESummonInfo::set_race(const char* value) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    race_ = new ::std::string;
  }
  race_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.race)
}
inline void AESummonInfo::set_race(const char* value, size_t size) {
  set_has_race();
  if (race_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    race_ = new ::std::string;
  }
  race_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.race)
}
inline ::std::string* AESummonInfo::mutable_race() {
  set_has_race();
  if (race_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    race_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.race)
  return race_;
}
inline ::std::string* AESummonInfo::release_race() {
  clear_has_race();
  if (race_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = race_;
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_race(::std::string* race) {
  if (race_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete race_;
  }
  if (race) {
    set_has_race();
    race_ = race;
  } else {
    clear_has_race();
    race_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.race)
}

// optional string nature = 11;
inline bool AESummonInfo::has_nature() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AESummonInfo::set_has_nature() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AESummonInfo::clear_has_nature() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AESummonInfo::clear_nature() {
  if (nature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nature_->clear();
  }
  clear_has_nature();
}
inline const ::std::string& AESummonInfo::nature() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.nature)
  return *nature_;
}
inline void AESummonInfo::set_nature(const ::std::string& value) {
  set_has_nature();
  if (nature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nature_ = new ::std::string;
  }
  nature_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.nature)
}
inline void AESummonInfo::set_nature(const char* value) {
  set_has_nature();
  if (nature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nature_ = new ::std::string;
  }
  nature_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.nature)
}
inline void AESummonInfo::set_nature(const char* value, size_t size) {
  set_has_nature();
  if (nature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nature_ = new ::std::string;
  }
  nature_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.nature)
}
inline ::std::string* AESummonInfo::mutable_nature() {
  set_has_nature();
  if (nature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nature_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.nature)
  return nature_;
}
inline ::std::string* AESummonInfo::release_nature() {
  clear_has_nature();
  if (nature_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nature_;
    nature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_nature(::std::string* nature) {
  if (nature_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nature_;
  }
  if (nature) {
    set_has_nature();
    nature_ = nature;
  } else {
    clear_has_nature();
    nature_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.nature)
}

// optional string shape = 12;
inline bool AESummonInfo::has_shape() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AESummonInfo::set_has_shape() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AESummonInfo::clear_has_shape() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AESummonInfo::clear_shape() {
  if (shape_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shape_->clear();
  }
  clear_has_shape();
}
inline const ::std::string& AESummonInfo::shape() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.shape)
  return *shape_;
}
inline void AESummonInfo::set_shape(const ::std::string& value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.shape)
}
inline void AESummonInfo::set_shape(const char* value) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shape_ = new ::std::string;
  }
  shape_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AESummonInfo.shape)
}
inline void AESummonInfo::set_shape(const char* value, size_t size) {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shape_ = new ::std::string;
  }
  shape_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AESummonInfo.shape)
}
inline ::std::string* AESummonInfo::mutable_shape() {
  set_has_shape();
  if (shape_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    shape_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.shape)
  return shape_;
}
inline ::std::string* AESummonInfo::release_shape() {
  clear_has_shape();
  if (shape_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = shape_;
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AESummonInfo::set_allocated_shape(::std::string* shape) {
  if (shape_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete shape_;
  }
  if (shape) {
    set_has_shape();
    shape_ = shape;
  } else {
    clear_has_shape();
    shape_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AESummonInfo.shape)
}

// optional uint32 body = 13 [default = 0];
inline bool AESummonInfo::has_body() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AESummonInfo::set_has_body() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AESummonInfo::clear_has_body() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AESummonInfo::clear_body() {
  body_ = 0u;
  clear_has_body();
}
inline ::google::protobuf::uint32 AESummonInfo::body() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.body)
  return body_;
}
inline void AESummonInfo::set_body(::google::protobuf::uint32 value) {
  set_has_body();
  body_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.body)
}

// optional uint32 jobexp = 14 [default = 0];
inline bool AESummonInfo::has_jobexp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AESummonInfo::set_has_jobexp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AESummonInfo::clear_has_jobexp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AESummonInfo::clear_jobexp() {
  jobexp_ = 0u;
  clear_has_jobexp();
}
inline ::google::protobuf::uint32 AESummonInfo::jobexp() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.jobexp)
  return jobexp_;
}
inline void AESummonInfo::set_jobexp(::google::protobuf::uint32 value) {
  set_has_jobexp();
  jobexp_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.jobexp)
}

// optional uint32 baseexp = 15 [default = 0];
inline bool AESummonInfo::has_baseexp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AESummonInfo::set_has_baseexp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AESummonInfo::clear_has_baseexp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AESummonInfo::clear_baseexp() {
  baseexp_ = 0u;
  clear_has_baseexp();
}
inline ::google::protobuf::uint32 AESummonInfo::baseexp() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.baseexp)
  return baseexp_;
}
inline void AESummonInfo::set_baseexp(::google::protobuf::uint32 value) {
  set_has_baseexp();
  baseexp_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.baseexp)
}

// optional float str = 16 [default = 0];
inline bool AESummonInfo::has_str() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AESummonInfo::set_has_str() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AESummonInfo::clear_has_str() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AESummonInfo::clear_str() {
  str_ = 0;
  clear_has_str();
}
inline float AESummonInfo::str() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.str)
  return str_;
}
inline void AESummonInfo::set_str(float value) {
  set_has_str();
  str_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.str)
}

// optional float dex = 17 [default = 0];
inline bool AESummonInfo::has_dex() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AESummonInfo::set_has_dex() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AESummonInfo::clear_has_dex() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AESummonInfo::clear_dex() {
  dex_ = 0;
  clear_has_dex();
}
inline float AESummonInfo::dex() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.dex)
  return dex_;
}
inline void AESummonInfo::set_dex(float value) {
  set_has_dex();
  dex_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.dex)
}

// optional float inte = 18 [default = 0];
inline bool AESummonInfo::has_inte() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AESummonInfo::set_has_inte() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AESummonInfo::clear_has_inte() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AESummonInfo::clear_inte() {
  inte_ = 0;
  clear_has_inte();
}
inline float AESummonInfo::inte() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.inte)
  return inte_;
}
inline void AESummonInfo::set_inte(float value) {
  set_has_inte();
  inte_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.inte)
}

// optional float vit = 19 [default = 0];
inline bool AESummonInfo::has_vit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AESummonInfo::set_has_vit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AESummonInfo::clear_has_vit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AESummonInfo::clear_vit() {
  vit_ = 0;
  clear_has_vit();
}
inline float AESummonInfo::vit() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.vit)
  return vit_;
}
inline void AESummonInfo::set_vit(float value) {
  set_has_vit();
  vit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.vit)
}

// optional float agi = 20 [default = 0];
inline bool AESummonInfo::has_agi() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void AESummonInfo::set_has_agi() {
  _has_bits_[0] |= 0x00080000u;
}
inline void AESummonInfo::clear_has_agi() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void AESummonInfo::clear_agi() {
  agi_ = 0;
  clear_has_agi();
}
inline float AESummonInfo::agi() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.agi)
  return agi_;
}
inline void AESummonInfo::set_agi(float value) {
  set_has_agi();
  agi_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.agi)
}

// optional float luk = 21 [default = 0];
inline bool AESummonInfo::has_luk() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void AESummonInfo::set_has_luk() {
  _has_bits_[0] |= 0x00100000u;
}
inline void AESummonInfo::clear_has_luk() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void AESummonInfo::clear_luk() {
  luk_ = 0;
  clear_has_luk();
}
inline float AESummonInfo::luk() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.luk)
  return luk_;
}
inline void AESummonInfo::set_luk(float value) {
  set_has_luk();
  luk_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.luk)
}

// optional float atk = 22 [default = 0];
inline bool AESummonInfo::has_atk() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void AESummonInfo::set_has_atk() {
  _has_bits_[0] |= 0x00200000u;
}
inline void AESummonInfo::clear_has_atk() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void AESummonInfo::clear_atk() {
  atk_ = 0;
  clear_has_atk();
}
inline float AESummonInfo::atk() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.atk)
  return atk_;
}
inline void AESummonInfo::set_atk(float value) {
  set_has_atk();
  atk_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.atk)
}

// optional float matk = 23 [default = 0];
inline bool AESummonInfo::has_matk() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void AESummonInfo::set_has_matk() {
  _has_bits_[0] |= 0x00400000u;
}
inline void AESummonInfo::clear_has_matk() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void AESummonInfo::clear_matk() {
  matk_ = 0;
  clear_has_matk();
}
inline float AESummonInfo::matk() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.matk)
  return matk_;
}
inline void AESummonInfo::set_matk(float value) {
  set_has_matk();
  matk_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.matk)
}

// optional float def = 24 [default = 0];
inline bool AESummonInfo::has_def() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void AESummonInfo::set_has_def() {
  _has_bits_[0] |= 0x00800000u;
}
inline void AESummonInfo::clear_has_def() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void AESummonInfo::clear_def() {
  def_ = 0;
  clear_has_def();
}
inline float AESummonInfo::def() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.def)
  return def_;
}
inline void AESummonInfo::set_def(float value) {
  set_has_def();
  def_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.def)
}

// optional float mdef = 25 [default = 0];
inline bool AESummonInfo::has_mdef() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void AESummonInfo::set_has_mdef() {
  _has_bits_[0] |= 0x01000000u;
}
inline void AESummonInfo::clear_has_mdef() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void AESummonInfo::clear_mdef() {
  mdef_ = 0;
  clear_has_mdef();
}
inline float AESummonInfo::mdef() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.mdef)
  return mdef_;
}
inline void AESummonInfo::set_mdef(float value) {
  set_has_mdef();
  mdef_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.mdef)
}

// optional float hp = 26 [default = 0];
inline bool AESummonInfo::has_hp() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void AESummonInfo::set_has_hp() {
  _has_bits_[0] |= 0x02000000u;
}
inline void AESummonInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void AESummonInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline float AESummonInfo::hp() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.hp)
  return hp_;
}
inline void AESummonInfo::set_hp(float value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.hp)
}

// optional float hit = 27 [default = 0];
inline bool AESummonInfo::has_hit() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void AESummonInfo::set_has_hit() {
  _has_bits_[0] |= 0x04000000u;
}
inline void AESummonInfo::clear_has_hit() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void AESummonInfo::clear_hit() {
  hit_ = 0;
  clear_has_hit();
}
inline float AESummonInfo::hit() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.hit)
  return hit_;
}
inline void AESummonInfo::set_hit(float value) {
  set_has_hit();
  hit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.hit)
}

// optional float flee = 28 [default = 0];
inline bool AESummonInfo::has_flee() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void AESummonInfo::set_has_flee() {
  _has_bits_[0] |= 0x08000000u;
}
inline void AESummonInfo::clear_has_flee() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void AESummonInfo::clear_flee() {
  flee_ = 0;
  clear_has_flee();
}
inline float AESummonInfo::flee() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.flee)
  return flee_;
}
inline void AESummonInfo::set_flee(float value) {
  set_has_flee();
  flee_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.flee)
}

// optional float movespd = 29 [default = 0];
inline bool AESummonInfo::has_movespd() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void AESummonInfo::set_has_movespd() {
  _has_bits_[0] |= 0x10000000u;
}
inline void AESummonInfo::clear_has_movespd() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void AESummonInfo::clear_movespd() {
  movespd_ = 0;
  clear_has_movespd();
}
inline float AESummonInfo::movespd() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.movespd)
  return movespd_;
}
inline void AESummonInfo::set_movespd(float value) {
  set_has_movespd();
  movespd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.movespd)
}

// optional float movespdrate = 30 [default = 0];
inline bool AESummonInfo::has_movespdrate() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void AESummonInfo::set_has_movespdrate() {
  _has_bits_[0] |= 0x20000000u;
}
inline void AESummonInfo::clear_has_movespdrate() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void AESummonInfo::clear_movespdrate() {
  movespdrate_ = 0;
  clear_has_movespdrate();
}
inline float AESummonInfo::movespdrate() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.movespdrate)
  return movespdrate_;
}
inline void AESummonInfo::set_movespdrate(float value) {
  set_has_movespdrate();
  movespdrate_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.movespdrate)
}

// optional float scale = 31 [default = 0];
inline bool AESummonInfo::has_scale() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void AESummonInfo::set_has_scale() {
  _has_bits_[0] |= 0x40000000u;
}
inline void AESummonInfo::clear_has_scale() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void AESummonInfo::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float AESummonInfo::scale() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.scale)
  return scale_;
}
inline void AESummonInfo::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.scale)
}

// optional uint32 normalskill = 32 [default = 0];
inline bool AESummonInfo::has_normalskill() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void AESummonInfo::set_has_normalskill() {
  _has_bits_[0] |= 0x80000000u;
}
inline void AESummonInfo::clear_has_normalskill() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void AESummonInfo::clear_normalskill() {
  normalskill_ = 0u;
  clear_has_normalskill();
}
inline ::google::protobuf::uint32 AESummonInfo::normalskill() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.normalskill)
  return normalskill_;
}
inline void AESummonInfo::set_normalskill(::google::protobuf::uint32 value) {
  set_has_normalskill();
  normalskill_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.normalskill)
}

// optional uint32 rewardid = 33 [default = 0];
inline bool AESummonInfo::has_rewardid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void AESummonInfo::set_has_rewardid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void AESummonInfo::clear_has_rewardid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void AESummonInfo::clear_rewardid() {
  rewardid_ = 0u;
  clear_has_rewardid();
}
inline ::google::protobuf::uint32 AESummonInfo::rewardid() const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.rewardid)
  return rewardid_;
}
inline void AESummonInfo::set_rewardid(::google::protobuf::uint32 value) {
  set_has_rewardid();
  rewardid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AESummonInfo.rewardid)
}

// repeated .Cmd.AEReward rewards = 34;
inline int AESummonInfo::rewards_size() const {
  return rewards_.size();
}
inline void AESummonInfo::clear_rewards() {
  rewards_.Clear();
}
inline const ::Cmd::AEReward& AESummonInfo::rewards(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.rewards)
  return rewards_.Get(index);
}
inline ::Cmd::AEReward* AESummonInfo::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.rewards)
  return rewards_.Mutable(index);
}
inline ::Cmd::AEReward* AESummonInfo::add_rewards() {
  // @@protoc_insertion_point(field_add:Cmd.AESummonInfo.rewards)
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >&
AESummonInfo::rewards() const {
  // @@protoc_insertion_point(field_list:Cmd.AESummonInfo.rewards)
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >*
AESummonInfo::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AESummonInfo.rewards)
  return &rewards_;
}

// repeated .Cmd.AEMap map = 35;
inline int AESummonInfo::map_size() const {
  return map_.size();
}
inline void AESummonInfo::clear_map() {
  map_.Clear();
}
inline const ::Cmd::AEMap& AESummonInfo::map(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AESummonInfo.map)
  return map_.Get(index);
}
inline ::Cmd::AEMap* AESummonInfo::mutable_map(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AESummonInfo.map)
  return map_.Mutable(index);
}
inline ::Cmd::AEMap* AESummonInfo::add_map() {
  // @@protoc_insertion_point(field_add:Cmd.AESummonInfo.map)
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >&
AESummonInfo::map() const {
  // @@protoc_insertion_point(field_list:Cmd.AESummonInfo.map)
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >*
AESummonInfo::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AESummonInfo.map)
  return &map_;
}

// -------------------------------------------------------------------

// AERewardExtraInfo

// repeated .Cmd.AEReward rewards = 1;
inline int AERewardExtraInfo::rewards_size() const {
  return rewards_.size();
}
inline void AERewardExtraInfo::clear_rewards() {
  rewards_.Clear();
}
inline const ::Cmd::AEReward& AERewardExtraInfo::rewards(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardExtraInfo.rewards)
  return rewards_.Get(index);
}
inline ::Cmd::AEReward* AERewardExtraInfo::mutable_rewards(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AERewardExtraInfo.rewards)
  return rewards_.Mutable(index);
}
inline ::Cmd::AEReward* AERewardExtraInfo::add_rewards() {
  // @@protoc_insertion_point(field_add:Cmd.AERewardExtraInfo.rewards)
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >&
AERewardExtraInfo::rewards() const {
  // @@protoc_insertion_point(field_list:Cmd.AERewardExtraInfo.rewards)
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEReward >*
AERewardExtraInfo::mutable_rewards() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AERewardExtraInfo.rewards)
  return &rewards_;
}

// optional uint32 finishcount = 2 [default = 0];
inline bool AERewardExtraInfo::has_finishcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AERewardExtraInfo::set_has_finishcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AERewardExtraInfo::clear_has_finishcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AERewardExtraInfo::clear_finishcount() {
  finishcount_ = 0u;
  clear_has_finishcount();
}
inline ::google::protobuf::uint32 AERewardExtraInfo::finishcount() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardExtraInfo.finishcount)
  return finishcount_;
}
inline void AERewardExtraInfo::set_finishcount(::google::protobuf::uint32 value) {
  set_has_finishcount();
  finishcount_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardExtraInfo.finishcount)
}

// optional uint32 daylimit = 3 [default = 0];
inline bool AERewardExtraInfo::has_daylimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AERewardExtraInfo::set_has_daylimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AERewardExtraInfo::clear_has_daylimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AERewardExtraInfo::clear_daylimit() {
  daylimit_ = 0u;
  clear_has_daylimit();
}
inline ::google::protobuf::uint32 AERewardExtraInfo::daylimit() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardExtraInfo.daylimit)
  return daylimit_;
}
inline void AERewardExtraInfo::set_daylimit(::google::protobuf::uint32 value) {
  set_has_daylimit();
  daylimit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardExtraInfo.daylimit)
}

// optional bool acclimit = 4 [default = false];
inline bool AERewardExtraInfo::has_acclimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AERewardExtraInfo::set_has_acclimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AERewardExtraInfo::clear_has_acclimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AERewardExtraInfo::clear_acclimit() {
  acclimit_ = false;
  clear_has_acclimit();
}
inline bool AERewardExtraInfo::acclimit() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardExtraInfo.acclimit)
  return acclimit_;
}
inline void AERewardExtraInfo::set_acclimit(bool value) {
  set_has_acclimit();
  acclimit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardExtraInfo.acclimit)
}

// -------------------------------------------------------------------

// AERewardMultipleInfo

// optional uint32 multiple = 1 [default = 1];
inline bool AERewardMultipleInfo::has_multiple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AERewardMultipleInfo::set_has_multiple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AERewardMultipleInfo::clear_has_multiple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AERewardMultipleInfo::clear_multiple() {
  multiple_ = 1u;
  clear_has_multiple();
}
inline ::google::protobuf::uint32 AERewardMultipleInfo::multiple() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardMultipleInfo.multiple)
  return multiple_;
}
inline void AERewardMultipleInfo::set_multiple(::google::protobuf::uint32 value) {
  set_has_multiple();
  multiple_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardMultipleInfo.multiple)
}

// optional uint32 finishcount = 2 [default = 0];
inline bool AERewardMultipleInfo::has_finishcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AERewardMultipleInfo::set_has_finishcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AERewardMultipleInfo::clear_has_finishcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AERewardMultipleInfo::clear_finishcount() {
  finishcount_ = 0u;
  clear_has_finishcount();
}
inline ::google::protobuf::uint32 AERewardMultipleInfo::finishcount() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardMultipleInfo.finishcount)
  return finishcount_;
}
inline void AERewardMultipleInfo::set_finishcount(::google::protobuf::uint32 value) {
  set_has_finishcount();
  finishcount_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardMultipleInfo.finishcount)
}

// optional uint32 daylimit = 3 [default = 0];
inline bool AERewardMultipleInfo::has_daylimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AERewardMultipleInfo::set_has_daylimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AERewardMultipleInfo::clear_has_daylimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AERewardMultipleInfo::clear_daylimit() {
  daylimit_ = 0u;
  clear_has_daylimit();
}
inline ::google::protobuf::uint32 AERewardMultipleInfo::daylimit() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardMultipleInfo.daylimit)
  return daylimit_;
}
inline void AERewardMultipleInfo::set_daylimit(::google::protobuf::uint32 value) {
  set_has_daylimit();
  daylimit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardMultipleInfo.daylimit)
}

// optional bool acclimit = 4 [default = false];
inline bool AERewardMultipleInfo::has_acclimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AERewardMultipleInfo::set_has_acclimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AERewardMultipleInfo::clear_has_acclimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AERewardMultipleInfo::clear_acclimit() {
  acclimit_ = false;
  clear_has_acclimit();
}
inline bool AERewardMultipleInfo::acclimit() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardMultipleInfo.acclimit)
  return acclimit_;
}
inline void AERewardMultipleInfo::set_acclimit(bool value) {
  set_has_acclimit();
  acclimit_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardMultipleInfo.acclimit)
}

// -------------------------------------------------------------------

// AERewardInfo

// optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
inline bool AERewardInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AERewardInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AERewardInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AERewardInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::Cmd::EAERewardMode AERewardInfo::mode() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardInfo.mode)
  return static_cast< ::Cmd::EAERewardMode >(mode_);
}
inline void AERewardInfo::set_mode(::Cmd::EAERewardMode value) {
  assert(::Cmd::EAERewardMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardInfo.mode)
}

// optional .Cmd.AERewardExtraInfo extrareward = 2;
inline bool AERewardInfo::has_extrareward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AERewardInfo::set_has_extrareward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AERewardInfo::clear_has_extrareward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AERewardInfo::clear_extrareward() {
  if (extrareward_ != NULL) extrareward_->::Cmd::AERewardExtraInfo::Clear();
  clear_has_extrareward();
}
inline const ::Cmd::AERewardExtraInfo& AERewardInfo::extrareward() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardInfo.extrareward)
  return extrareward_ != NULL ? *extrareward_ : *default_instance_->extrareward_;
}
inline ::Cmd::AERewardExtraInfo* AERewardInfo::mutable_extrareward() {
  set_has_extrareward();
  if (extrareward_ == NULL) extrareward_ = new ::Cmd::AERewardExtraInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.AERewardInfo.extrareward)
  return extrareward_;
}
inline ::Cmd::AERewardExtraInfo* AERewardInfo::release_extrareward() {
  clear_has_extrareward();
  ::Cmd::AERewardExtraInfo* temp = extrareward_;
  extrareward_ = NULL;
  return temp;
}
inline void AERewardInfo::set_allocated_extrareward(::Cmd::AERewardExtraInfo* extrareward) {
  delete extrareward_;
  extrareward_ = extrareward;
  if (extrareward) {
    set_has_extrareward();
  } else {
    clear_has_extrareward();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AERewardInfo.extrareward)
}

// optional .Cmd.AERewardMultipleInfo multiplereward = 3;
inline bool AERewardInfo::has_multiplereward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AERewardInfo::set_has_multiplereward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AERewardInfo::clear_has_multiplereward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AERewardInfo::clear_multiplereward() {
  if (multiplereward_ != NULL) multiplereward_->::Cmd::AERewardMultipleInfo::Clear();
  clear_has_multiplereward();
}
inline const ::Cmd::AERewardMultipleInfo& AERewardInfo::multiplereward() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardInfo.multiplereward)
  return multiplereward_ != NULL ? *multiplereward_ : *default_instance_->multiplereward_;
}
inline ::Cmd::AERewardMultipleInfo* AERewardInfo::mutable_multiplereward() {
  set_has_multiplereward();
  if (multiplereward_ == NULL) multiplereward_ = new ::Cmd::AERewardMultipleInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.AERewardInfo.multiplereward)
  return multiplereward_;
}
inline ::Cmd::AERewardMultipleInfo* AERewardInfo::release_multiplereward() {
  clear_has_multiplereward();
  ::Cmd::AERewardMultipleInfo* temp = multiplereward_;
  multiplereward_ = NULL;
  return temp;
}
inline void AERewardInfo::set_allocated_multiplereward(::Cmd::AERewardMultipleInfo* multiplereward) {
  delete multiplereward_;
  multiplereward_ = multiplereward;
  if (multiplereward) {
    set_has_multiplereward();
  } else {
    clear_has_multiplereward();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AERewardInfo.multiplereward)
}

// optional uint32 extratimes = 4 [default = 0];
inline bool AERewardInfo::has_extratimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AERewardInfo::set_has_extratimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AERewardInfo::clear_has_extratimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AERewardInfo::clear_extratimes() {
  extratimes_ = 0u;
  clear_has_extratimes();
}
inline ::google::protobuf::uint32 AERewardInfo::extratimes() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardInfo.extratimes)
  return extratimes_;
}
inline void AERewardInfo::set_extratimes(::google::protobuf::uint32 value) {
  set_has_extratimes();
  extratimes_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardInfo.extratimes)
}

// -------------------------------------------------------------------

// AELotteryDiscount

// optional .Cmd.ELotteryType lotterytype = 1;
inline bool AELotteryDiscount::has_lotterytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELotteryDiscount::set_has_lotterytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELotteryDiscount::clear_has_lotterytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELotteryDiscount::clear_lotterytype() {
  lotterytype_ = 0;
  clear_has_lotterytype();
}
inline ::Cmd::ELotteryType AELotteryDiscount::lotterytype() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.lotterytype)
  return static_cast< ::Cmd::ELotteryType >(lotterytype_);
}
inline void AELotteryDiscount::set_lotterytype(::Cmd::ELotteryType value) {
  assert(::Cmd::ELotteryType_IsValid(value));
  set_has_lotterytype();
  lotterytype_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.lotterytype)
}

// optional .Cmd.ECoinType cointype = 2;
inline bool AELotteryDiscount::has_cointype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AELotteryDiscount::set_has_cointype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AELotteryDiscount::clear_has_cointype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AELotteryDiscount::clear_cointype() {
  cointype_ = 0;
  clear_has_cointype();
}
inline ::Cmd::ECoinType AELotteryDiscount::cointype() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.cointype)
  return static_cast< ::Cmd::ECoinType >(cointype_);
}
inline void AELotteryDiscount::set_cointype(::Cmd::ECoinType value) {
  assert(::Cmd::ECoinType_IsValid(value));
  set_has_cointype();
  cointype_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.cointype)
}

// optional .Cmd.EUserType usertype = 3;
inline bool AELotteryDiscount::has_usertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AELotteryDiscount::set_has_usertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AELotteryDiscount::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AELotteryDiscount::clear_usertype() {
  usertype_ = 1;
  clear_has_usertype();
}
inline ::Cmd::EUserType AELotteryDiscount::usertype() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.usertype)
  return static_cast< ::Cmd::EUserType >(usertype_);
}
inline void AELotteryDiscount::set_usertype(::Cmd::EUserType value) {
  assert(::Cmd::EUserType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.usertype)
}

// optional uint32 discount = 4;
inline bool AELotteryDiscount::has_discount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AELotteryDiscount::set_has_discount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AELotteryDiscount::clear_has_discount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AELotteryDiscount::clear_discount() {
  discount_ = 0u;
  clear_has_discount();
}
inline ::google::protobuf::uint32 AELotteryDiscount::discount() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.discount)
  return discount_;
}
inline void AELotteryDiscount::set_discount(::google::protobuf::uint32 value) {
  set_has_discount();
  discount_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.discount)
}

// optional uint32 count = 5;
inline bool AELotteryDiscount::has_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AELotteryDiscount::set_has_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AELotteryDiscount::clear_has_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AELotteryDiscount::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 AELotteryDiscount::count() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.count)
  return count_;
}
inline void AELotteryDiscount::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.count)
}

// optional uint32 yearmonth = 7;
inline bool AELotteryDiscount::has_yearmonth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AELotteryDiscount::set_has_yearmonth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AELotteryDiscount::clear_has_yearmonth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AELotteryDiscount::clear_yearmonth() {
  yearmonth_ = 0u;
  clear_has_yearmonth();
}
inline ::google::protobuf::uint32 AELotteryDiscount::yearmonth() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryDiscount.yearmonth)
  return yearmonth_;
}
inline void AELotteryDiscount::set_yearmonth(::google::protobuf::uint32 value) {
  set_has_yearmonth();
  yearmonth_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryDiscount.yearmonth)
}

// -------------------------------------------------------------------

// AELotteryNpc

// optional .Cmd.ELotteryType lotterytype = 1;
inline bool AELotteryNpc::has_lotterytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELotteryNpc::set_has_lotterytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELotteryNpc::clear_has_lotterytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELotteryNpc::clear_lotterytype() {
  lotterytype_ = 0;
  clear_has_lotterytype();
}
inline ::Cmd::ELotteryType AELotteryNpc::lotterytype() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryNpc.lotterytype)
  return static_cast< ::Cmd::ELotteryType >(lotterytype_);
}
inline void AELotteryNpc::set_lotterytype(::Cmd::ELotteryType value) {
  assert(::Cmd::ELotteryType_IsValid(value));
  set_has_lotterytype();
  lotterytype_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryNpc.lotterytype)
}

// repeated .Cmd.AEMap map = 2;
inline int AELotteryNpc::map_size() const {
  return map_.size();
}
inline void AELotteryNpc::clear_map() {
  map_.Clear();
}
inline const ::Cmd::AEMap& AELotteryNpc::map(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryNpc.map)
  return map_.Get(index);
}
inline ::Cmd::AEMap* AELotteryNpc::mutable_map(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AELotteryNpc.map)
  return map_.Mutable(index);
}
inline ::Cmd::AEMap* AELotteryNpc::add_map() {
  // @@protoc_insertion_point(field_add:Cmd.AELotteryNpc.map)
  return map_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >&
AELotteryNpc::map() const {
  // @@protoc_insertion_point(field_list:Cmd.AELotteryNpc.map)
  return map_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEMap >*
AELotteryNpc::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AELotteryNpc.map)
  return &map_;
}

// -------------------------------------------------------------------

// AEUrl

// optional uint32 language = 1 [default = 0];
inline bool AEUrl::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEUrl::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEUrl::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEUrl::clear_language() {
  language_ = 0u;
  clear_has_language();
}
inline ::google::protobuf::uint32 AEUrl::language() const {
  // @@protoc_insertion_point(field_get:Cmd.AEUrl.language)
  return language_;
}
inline void AEUrl::set_language(::google::protobuf::uint32 value) {
  set_has_language();
  language_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEUrl.language)
}

// optional string url = 2;
inline bool AEUrl::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEUrl::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEUrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEUrl::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AEUrl::url() const {
  // @@protoc_insertion_point(field_get:Cmd.AEUrl.url)
  return *url_;
}
inline void AEUrl::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AEUrl.url)
}
inline void AEUrl::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AEUrl.url)
}
inline void AEUrl::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AEUrl.url)
}
inline ::std::string* AEUrl::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AEUrl.url)
  return url_;
}
inline ::std::string* AEUrl::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AEUrl::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AEUrl.url)
}

// -------------------------------------------------------------------

// AELotteryBanner

// optional .Cmd.ELotteryType lotterytype = 1;
inline bool AELotteryBanner::has_lotterytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AELotteryBanner::set_has_lotterytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AELotteryBanner::clear_has_lotterytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AELotteryBanner::clear_lotterytype() {
  lotterytype_ = 0;
  clear_has_lotterytype();
}
inline ::Cmd::ELotteryType AELotteryBanner::lotterytype() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryBanner.lotterytype)
  return static_cast< ::Cmd::ELotteryType >(lotterytype_);
}
inline void AELotteryBanner::set_lotterytype(::Cmd::ELotteryType value) {
  assert(::Cmd::ELotteryType_IsValid(value));
  set_has_lotterytype();
  lotterytype_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AELotteryBanner.lotterytype)
}

// optional string path = 2;
inline bool AELotteryBanner::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AELotteryBanner::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AELotteryBanner::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AELotteryBanner::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& AELotteryBanner::path() const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryBanner.path)
  return *path_;
}
inline void AELotteryBanner::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.AELotteryBanner.path)
}
inline void AELotteryBanner::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.AELotteryBanner.path)
}
inline void AELotteryBanner::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.AELotteryBanner.path)
}
inline ::std::string* AELotteryBanner::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.AELotteryBanner.path)
  return path_;
}
inline ::std::string* AELotteryBanner::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AELotteryBanner::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.AELotteryBanner.path)
}

// repeated .Cmd.AEUrl urls = 3;
inline int AELotteryBanner::urls_size() const {
  return urls_.size();
}
inline void AELotteryBanner::clear_urls() {
  urls_.Clear();
}
inline const ::Cmd::AEUrl& AELotteryBanner::urls(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AELotteryBanner.urls)
  return urls_.Get(index);
}
inline ::Cmd::AEUrl* AELotteryBanner::mutable_urls(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AELotteryBanner.urls)
  return urls_.Mutable(index);
}
inline ::Cmd::AEUrl* AELotteryBanner::add_urls() {
  // @@protoc_insertion_point(field_add:Cmd.AELotteryBanner.urls)
  return urls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEUrl >&
AELotteryBanner::urls() const {
  // @@protoc_insertion_point(field_list:Cmd.AELotteryBanner.urls)
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEUrl >*
AELotteryBanner::mutable_urls() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AELotteryBanner.urls)
  return &urls_;
}

// -------------------------------------------------------------------

// AEGuildBuildingSubmitInfo

// repeated .Cmd.EGuildBuilding types = 1;
inline int AEGuildBuildingSubmitInfo::types_size() const {
  return types_.size();
}
inline void AEGuildBuildingSubmitInfo::clear_types() {
  types_.Clear();
}
inline ::Cmd::EGuildBuilding AEGuildBuildingSubmitInfo::types(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEGuildBuildingSubmitInfo.types)
  return static_cast< ::Cmd::EGuildBuilding >(types_.Get(index));
}
inline void AEGuildBuildingSubmitInfo::set_types(int index, ::Cmd::EGuildBuilding value) {
  assert(::Cmd::EGuildBuilding_IsValid(value));
  types_.Set(index, value);
  // @@protoc_insertion_point(field_set:Cmd.AEGuildBuildingSubmitInfo.types)
}
inline void AEGuildBuildingSubmitInfo::add_types(::Cmd::EGuildBuilding value) {
  assert(::Cmd::EGuildBuilding_IsValid(value));
  types_.Add(value);
  // @@protoc_insertion_point(field_add:Cmd.AEGuildBuildingSubmitInfo.types)
}
inline const ::google::protobuf::RepeatedField<int>&
AEGuildBuildingSubmitInfo::types() const {
  // @@protoc_insertion_point(field_list:Cmd.AEGuildBuildingSubmitInfo.types)
  return types_;
}
inline ::google::protobuf::RepeatedField<int>*
AEGuildBuildingSubmitInfo::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEGuildBuildingSubmitInfo.types)
  return &types_;
}

// optional uint32 minlv = 2 [default = 0];
inline bool AEGuildBuildingSubmitInfo::has_minlv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEGuildBuildingSubmitInfo::set_has_minlv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEGuildBuildingSubmitInfo::clear_has_minlv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEGuildBuildingSubmitInfo::clear_minlv() {
  minlv_ = 0u;
  clear_has_minlv();
}
inline ::google::protobuf::uint32 AEGuildBuildingSubmitInfo::minlv() const {
  // @@protoc_insertion_point(field_get:Cmd.AEGuildBuildingSubmitInfo.minlv)
  return minlv_;
}
inline void AEGuildBuildingSubmitInfo::set_minlv(::google::protobuf::uint32 value) {
  set_has_minlv();
  minlv_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEGuildBuildingSubmitInfo.minlv)
}

// optional uint32 maxlv = 3 [default = 0];
inline bool AEGuildBuildingSubmitInfo::has_maxlv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AEGuildBuildingSubmitInfo::set_has_maxlv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AEGuildBuildingSubmitInfo::clear_has_maxlv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AEGuildBuildingSubmitInfo::clear_maxlv() {
  maxlv_ = 0u;
  clear_has_maxlv();
}
inline ::google::protobuf::uint32 AEGuildBuildingSubmitInfo::maxlv() const {
  // @@protoc_insertion_point(field_get:Cmd.AEGuildBuildingSubmitInfo.maxlv)
  return maxlv_;
}
inline void AEGuildBuildingSubmitInfo::set_maxlv(::google::protobuf::uint32 value) {
  set_has_maxlv();
  maxlv_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEGuildBuildingSubmitInfo.maxlv)
}

// optional uint32 submitinc = 4 [default = 0];
inline bool AEGuildBuildingSubmitInfo::has_submitinc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AEGuildBuildingSubmitInfo::set_has_submitinc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AEGuildBuildingSubmitInfo::clear_has_submitinc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AEGuildBuildingSubmitInfo::clear_submitinc() {
  submitinc_ = 0u;
  clear_has_submitinc();
}
inline ::google::protobuf::uint32 AEGuildBuildingSubmitInfo::submitinc() const {
  // @@protoc_insertion_point(field_get:Cmd.AEGuildBuildingSubmitInfo.submitinc)
  return submitinc_;
}
inline void AEGuildBuildingSubmitInfo::set_submitinc(::google::protobuf::uint32 value) {
  set_has_submitinc();
  submitinc_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEGuildBuildingSubmitInfo.submitinc)
}

// optional uint32 rewardinc = 5 [default = 0];
inline bool AEGuildBuildingSubmitInfo::has_rewardinc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AEGuildBuildingSubmitInfo::set_has_rewardinc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AEGuildBuildingSubmitInfo::clear_has_rewardinc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AEGuildBuildingSubmitInfo::clear_rewardinc() {
  rewardinc_ = 0u;
  clear_has_rewardinc();
}
inline ::google::protobuf::uint32 AEGuildBuildingSubmitInfo::rewardinc() const {
  // @@protoc_insertion_point(field_get:Cmd.AEGuildBuildingSubmitInfo.rewardinc)
  return rewardinc_;
}
inline void AEGuildBuildingSubmitInfo::set_rewardinc(::google::protobuf::uint32 value) {
  set_has_rewardinc();
  rewardinc_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEGuildBuildingSubmitInfo.rewardinc)
}

// -------------------------------------------------------------------

// AEShopInfo

// repeated .Cmd.ShopItem items = 1;
inline int AEShopInfo::items_size() const {
  return items_.size();
}
inline void AEShopInfo::clear_items() {
  items_.Clear();
}
inline const ::Cmd::ShopItem& AEShopInfo::items(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.AEShopInfo.items)
  return items_.Get(index);
}
inline ::Cmd::ShopItem* AEShopInfo::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.AEShopInfo.items)
  return items_.Mutable(index);
}
inline ::Cmd::ShopItem* AEShopInfo::add_items() {
  // @@protoc_insertion_point(field_add:Cmd.AEShopInfo.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ShopItem >&
AEShopInfo::items() const {
  // @@protoc_insertion_point(field_list:Cmd.AEShopInfo.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::ShopItem >*
AEShopInfo::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.AEShopInfo.items)
  return &items_;
}

// -------------------------------------------------------------------

// ActivityEventInfo

// optional uint64 id = 1 [default = 0];
inline bool ActivityEventInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEventInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEventInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEventInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ActivityEventInfo::id() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.id)
  return id_;
}
inline void ActivityEventInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventInfo.id)
}

// optional uint64 begintime = 2 [default = 0];
inline bool ActivityEventInfo::has_begintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEventInfo::set_has_begintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEventInfo::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEventInfo::clear_begintime() {
  begintime_ = GOOGLE_ULONGLONG(0);
  clear_has_begintime();
}
inline ::google::protobuf::uint64 ActivityEventInfo::begintime() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.begintime)
  return begintime_;
}
inline void ActivityEventInfo::set_begintime(::google::protobuf::uint64 value) {
  set_has_begintime();
  begintime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventInfo.begintime)
}

// optional uint64 endtime = 3 [default = 0];
inline bool ActivityEventInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityEventInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityEventInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityEventInfo::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 ActivityEventInfo::endtime() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.endtime)
  return endtime_;
}
inline void ActivityEventInfo::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventInfo.endtime)
}

// optional .Cmd.EActivityEventType type = 4;
inline bool ActivityEventInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActivityEventInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActivityEventInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActivityEventInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Cmd::EActivityEventType ActivityEventInfo::type() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.type)
  return static_cast< ::Cmd::EActivityEventType >(type_);
}
inline void ActivityEventInfo::set_type(::Cmd::EActivityEventType value) {
  assert(::Cmd::EActivityEventType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventInfo.type)
}

// optional .Cmd.AEFreeTransferInfo freetransferinfo = 5;
inline bool ActivityEventInfo::has_freetransferinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActivityEventInfo::set_has_freetransferinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActivityEventInfo::clear_has_freetransferinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActivityEventInfo::clear_freetransferinfo() {
  if (freetransferinfo_ != NULL) freetransferinfo_->::Cmd::AEFreeTransferInfo::Clear();
  clear_has_freetransferinfo();
}
inline const ::Cmd::AEFreeTransferInfo& ActivityEventInfo::freetransferinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.freetransferinfo)
  return freetransferinfo_ != NULL ? *freetransferinfo_ : *default_instance_->freetransferinfo_;
}
inline ::Cmd::AEFreeTransferInfo* ActivityEventInfo::mutable_freetransferinfo() {
  set_has_freetransferinfo();
  if (freetransferinfo_ == NULL) freetransferinfo_ = new ::Cmd::AEFreeTransferInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.freetransferinfo)
  return freetransferinfo_;
}
inline ::Cmd::AEFreeTransferInfo* ActivityEventInfo::release_freetransferinfo() {
  clear_has_freetransferinfo();
  ::Cmd::AEFreeTransferInfo* temp = freetransferinfo_;
  freetransferinfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_freetransferinfo(::Cmd::AEFreeTransferInfo* freetransferinfo) {
  delete freetransferinfo_;
  freetransferinfo_ = freetransferinfo;
  if (freetransferinfo) {
    set_has_freetransferinfo();
  } else {
    clear_has_freetransferinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.freetransferinfo)
}

// optional .Cmd.AESummonInfo summoninfo = 6;
inline bool ActivityEventInfo::has_summoninfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActivityEventInfo::set_has_summoninfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActivityEventInfo::clear_has_summoninfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActivityEventInfo::clear_summoninfo() {
  if (summoninfo_ != NULL) summoninfo_->::Cmd::AESummonInfo::Clear();
  clear_has_summoninfo();
}
inline const ::Cmd::AESummonInfo& ActivityEventInfo::summoninfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.summoninfo)
  return summoninfo_ != NULL ? *summoninfo_ : *default_instance_->summoninfo_;
}
inline ::Cmd::AESummonInfo* ActivityEventInfo::mutable_summoninfo() {
  set_has_summoninfo();
  if (summoninfo_ == NULL) summoninfo_ = new ::Cmd::AESummonInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.summoninfo)
  return summoninfo_;
}
inline ::Cmd::AESummonInfo* ActivityEventInfo::release_summoninfo() {
  clear_has_summoninfo();
  ::Cmd::AESummonInfo* temp = summoninfo_;
  summoninfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_summoninfo(::Cmd::AESummonInfo* summoninfo) {
  delete summoninfo_;
  summoninfo_ = summoninfo;
  if (summoninfo) {
    set_has_summoninfo();
  } else {
    clear_has_summoninfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.summoninfo)
}

// optional .Cmd.AERewardInfo rewardinfo = 7;
inline bool ActivityEventInfo::has_rewardinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActivityEventInfo::set_has_rewardinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActivityEventInfo::clear_has_rewardinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActivityEventInfo::clear_rewardinfo() {
  if (rewardinfo_ != NULL) rewardinfo_->::Cmd::AERewardInfo::Clear();
  clear_has_rewardinfo();
}
inline const ::Cmd::AERewardInfo& ActivityEventInfo::rewardinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.rewardinfo)
  return rewardinfo_ != NULL ? *rewardinfo_ : *default_instance_->rewardinfo_;
}
inline ::Cmd::AERewardInfo* ActivityEventInfo::mutable_rewardinfo() {
  set_has_rewardinfo();
  if (rewardinfo_ == NULL) rewardinfo_ = new ::Cmd::AERewardInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.rewardinfo)
  return rewardinfo_;
}
inline ::Cmd::AERewardInfo* ActivityEventInfo::release_rewardinfo() {
  clear_has_rewardinfo();
  ::Cmd::AERewardInfo* temp = rewardinfo_;
  rewardinfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_rewardinfo(::Cmd::AERewardInfo* rewardinfo) {
  delete rewardinfo_;
  rewardinfo_ = rewardinfo;
  if (rewardinfo) {
    set_has_rewardinfo();
  } else {
    clear_has_rewardinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.rewardinfo)
}

// optional .Cmd.AEResetInfo resetinfo = 8;
inline bool ActivityEventInfo::has_resetinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActivityEventInfo::set_has_resetinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActivityEventInfo::clear_has_resetinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActivityEventInfo::clear_resetinfo() {
  if (resetinfo_ != NULL) resetinfo_->::Cmd::AEResetInfo::Clear();
  clear_has_resetinfo();
}
inline const ::Cmd::AEResetInfo& ActivityEventInfo::resetinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.resetinfo)
  return resetinfo_ != NULL ? *resetinfo_ : *default_instance_->resetinfo_;
}
inline ::Cmd::AEResetInfo* ActivityEventInfo::mutable_resetinfo() {
  set_has_resetinfo();
  if (resetinfo_ == NULL) resetinfo_ = new ::Cmd::AEResetInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.resetinfo)
  return resetinfo_;
}
inline ::Cmd::AEResetInfo* ActivityEventInfo::release_resetinfo() {
  clear_has_resetinfo();
  ::Cmd::AEResetInfo* temp = resetinfo_;
  resetinfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_resetinfo(::Cmd::AEResetInfo* resetinfo) {
  delete resetinfo_;
  resetinfo_ = resetinfo;
  if (resetinfo) {
    set_has_resetinfo();
  } else {
    clear_has_resetinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.resetinfo)
}

// optional .Cmd.AELotteryDiscount lotterydiscount = 9;
inline bool ActivityEventInfo::has_lotterydiscount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActivityEventInfo::set_has_lotterydiscount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActivityEventInfo::clear_has_lotterydiscount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActivityEventInfo::clear_lotterydiscount() {
  if (lotterydiscount_ != NULL) lotterydiscount_->::Cmd::AELotteryDiscount::Clear();
  clear_has_lotterydiscount();
}
inline const ::Cmd::AELotteryDiscount& ActivityEventInfo::lotterydiscount() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.lotterydiscount)
  return lotterydiscount_ != NULL ? *lotterydiscount_ : *default_instance_->lotterydiscount_;
}
inline ::Cmd::AELotteryDiscount* ActivityEventInfo::mutable_lotterydiscount() {
  set_has_lotterydiscount();
  if (lotterydiscount_ == NULL) lotterydiscount_ = new ::Cmd::AELotteryDiscount;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.lotterydiscount)
  return lotterydiscount_;
}
inline ::Cmd::AELotteryDiscount* ActivityEventInfo::release_lotterydiscount() {
  clear_has_lotterydiscount();
  ::Cmd::AELotteryDiscount* temp = lotterydiscount_;
  lotterydiscount_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_lotterydiscount(::Cmd::AELotteryDiscount* lotterydiscount) {
  delete lotterydiscount_;
  lotterydiscount_ = lotterydiscount;
  if (lotterydiscount) {
    set_has_lotterydiscount();
  } else {
    clear_has_lotterydiscount();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.lotterydiscount)
}

// optional .Cmd.AELotteryNpc lotterynpc = 10;
inline bool ActivityEventInfo::has_lotterynpc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActivityEventInfo::set_has_lotterynpc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActivityEventInfo::clear_has_lotterynpc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActivityEventInfo::clear_lotterynpc() {
  if (lotterynpc_ != NULL) lotterynpc_->::Cmd::AELotteryNpc::Clear();
  clear_has_lotterynpc();
}
inline const ::Cmd::AELotteryNpc& ActivityEventInfo::lotterynpc() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.lotterynpc)
  return lotterynpc_ != NULL ? *lotterynpc_ : *default_instance_->lotterynpc_;
}
inline ::Cmd::AELotteryNpc* ActivityEventInfo::mutable_lotterynpc() {
  set_has_lotterynpc();
  if (lotterynpc_ == NULL) lotterynpc_ = new ::Cmd::AELotteryNpc;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.lotterynpc)
  return lotterynpc_;
}
inline ::Cmd::AELotteryNpc* ActivityEventInfo::release_lotterynpc() {
  clear_has_lotterynpc();
  ::Cmd::AELotteryNpc* temp = lotterynpc_;
  lotterynpc_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_lotterynpc(::Cmd::AELotteryNpc* lotterynpc) {
  delete lotterynpc_;
  lotterynpc_ = lotterynpc;
  if (lotterynpc) {
    set_has_lotterynpc();
  } else {
    clear_has_lotterynpc();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.lotterynpc)
}

// optional .Cmd.AELotteryBanner lotterybanner = 11;
inline bool ActivityEventInfo::has_lotterybanner() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActivityEventInfo::set_has_lotterybanner() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActivityEventInfo::clear_has_lotterybanner() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActivityEventInfo::clear_lotterybanner() {
  if (lotterybanner_ != NULL) lotterybanner_->::Cmd::AELotteryBanner::Clear();
  clear_has_lotterybanner();
}
inline const ::Cmd::AELotteryBanner& ActivityEventInfo::lotterybanner() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.lotterybanner)
  return lotterybanner_ != NULL ? *lotterybanner_ : *default_instance_->lotterybanner_;
}
inline ::Cmd::AELotteryBanner* ActivityEventInfo::mutable_lotterybanner() {
  set_has_lotterybanner();
  if (lotterybanner_ == NULL) lotterybanner_ = new ::Cmd::AELotteryBanner;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.lotterybanner)
  return lotterybanner_;
}
inline ::Cmd::AELotteryBanner* ActivityEventInfo::release_lotterybanner() {
  clear_has_lotterybanner();
  ::Cmd::AELotteryBanner* temp = lotterybanner_;
  lotterybanner_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_lotterybanner(::Cmd::AELotteryBanner* lotterybanner) {
  delete lotterybanner_;
  lotterybanner_ = lotterybanner;
  if (lotterybanner) {
    set_has_lotterybanner();
  } else {
    clear_has_lotterybanner();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.lotterybanner)
}

// optional .Cmd.AEGuildBuildingSubmitInfo gbuildingsubmitinfo = 12;
inline bool ActivityEventInfo::has_gbuildingsubmitinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ActivityEventInfo::set_has_gbuildingsubmitinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ActivityEventInfo::clear_has_gbuildingsubmitinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ActivityEventInfo::clear_gbuildingsubmitinfo() {
  if (gbuildingsubmitinfo_ != NULL) gbuildingsubmitinfo_->::Cmd::AEGuildBuildingSubmitInfo::Clear();
  clear_has_gbuildingsubmitinfo();
}
inline const ::Cmd::AEGuildBuildingSubmitInfo& ActivityEventInfo::gbuildingsubmitinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.gbuildingsubmitinfo)
  return gbuildingsubmitinfo_ != NULL ? *gbuildingsubmitinfo_ : *default_instance_->gbuildingsubmitinfo_;
}
inline ::Cmd::AEGuildBuildingSubmitInfo* ActivityEventInfo::mutable_gbuildingsubmitinfo() {
  set_has_gbuildingsubmitinfo();
  if (gbuildingsubmitinfo_ == NULL) gbuildingsubmitinfo_ = new ::Cmd::AEGuildBuildingSubmitInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.gbuildingsubmitinfo)
  return gbuildingsubmitinfo_;
}
inline ::Cmd::AEGuildBuildingSubmitInfo* ActivityEventInfo::release_gbuildingsubmitinfo() {
  clear_has_gbuildingsubmitinfo();
  ::Cmd::AEGuildBuildingSubmitInfo* temp = gbuildingsubmitinfo_;
  gbuildingsubmitinfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_gbuildingsubmitinfo(::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmitinfo) {
  delete gbuildingsubmitinfo_;
  gbuildingsubmitinfo_ = gbuildingsubmitinfo;
  if (gbuildingsubmitinfo) {
    set_has_gbuildingsubmitinfo();
  } else {
    clear_has_gbuildingsubmitinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.gbuildingsubmitinfo)
}

// optional .Cmd.AEShopInfo shopinfo = 13;
inline bool ActivityEventInfo::has_shopinfo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ActivityEventInfo::set_has_shopinfo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ActivityEventInfo::clear_has_shopinfo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ActivityEventInfo::clear_shopinfo() {
  if (shopinfo_ != NULL) shopinfo_->::Cmd::AEShopInfo::Clear();
  clear_has_shopinfo();
}
inline const ::Cmd::AEShopInfo& ActivityEventInfo::shopinfo() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventInfo.shopinfo)
  return shopinfo_ != NULL ? *shopinfo_ : *default_instance_->shopinfo_;
}
inline ::Cmd::AEShopInfo* ActivityEventInfo::mutable_shopinfo() {
  set_has_shopinfo();
  if (shopinfo_ == NULL) shopinfo_ = new ::Cmd::AEShopInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventInfo.shopinfo)
  return shopinfo_;
}
inline ::Cmd::AEShopInfo* ActivityEventInfo::release_shopinfo() {
  clear_has_shopinfo();
  ::Cmd::AEShopInfo* temp = shopinfo_;
  shopinfo_ = NULL;
  return temp;
}
inline void ActivityEventInfo::set_allocated_shopinfo(::Cmd::AEShopInfo* shopinfo) {
  delete shopinfo_;
  shopinfo_ = shopinfo;
  if (shopinfo) {
    set_has_shopinfo();
  } else {
    clear_has_shopinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEventInfo.shopinfo)
}

// -------------------------------------------------------------------

// AEResetInfo

// optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
inline bool AEResetInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AEResetInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AEResetInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AEResetInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::Cmd::EAERewardMode AEResetInfo::mode() const {
  // @@protoc_insertion_point(field_get:Cmd.AEResetInfo.mode)
  return static_cast< ::Cmd::EAERewardMode >(mode_);
}
inline void AEResetInfo::set_mode(::Cmd::EAERewardMode value) {
  assert(::Cmd::EAERewardMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEResetInfo.mode)
}

// optional uint32 times = 2 [default = 0];
inline bool AEResetInfo::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AEResetInfo::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AEResetInfo::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AEResetInfo::clear_times() {
  times_ = 0u;
  clear_has_times();
}
inline ::google::protobuf::uint32 AEResetInfo::times() const {
  // @@protoc_insertion_point(field_get:Cmd.AEResetInfo.times)
  return times_;
}
inline void AEResetInfo::set_times(::google::protobuf::uint32 value) {
  set_has_times();
  times_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AEResetInfo.times)
}

// -------------------------------------------------------------------

// AERewardItem

// optional .Cmd.EAERewardMode mode = 1 [default = EAEREWARDMODE_MIN];
inline bool AERewardItem::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AERewardItem::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AERewardItem::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AERewardItem::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::Cmd::EAERewardMode AERewardItem::mode() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardItem.mode)
  return static_cast< ::Cmd::EAERewardMode >(mode_);
}
inline void AERewardItem::set_mode(::Cmd::EAERewardMode value) {
  assert(::Cmd::EAERewardMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardItem.mode)
}

// optional uint32 daycount = 2 [default = 0];
inline bool AERewardItem::has_daycount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AERewardItem::set_has_daycount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AERewardItem::clear_has_daycount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AERewardItem::clear_daycount() {
  daycount_ = 0u;
  clear_has_daycount();
}
inline ::google::protobuf::uint32 AERewardItem::daycount() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardItem.daycount)
  return daycount_;
}
inline void AERewardItem::set_daycount(::google::protobuf::uint32 value) {
  set_has_daycount();
  daycount_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardItem.daycount)
}

// optional uint64 acclimitcharid = 3 [default = 0];
inline bool AERewardItem::has_acclimitcharid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AERewardItem::set_has_acclimitcharid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AERewardItem::clear_has_acclimitcharid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AERewardItem::clear_acclimitcharid() {
  acclimitcharid_ = GOOGLE_ULONGLONG(0);
  clear_has_acclimitcharid();
}
inline ::google::protobuf::uint64 AERewardItem::acclimitcharid() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardItem.acclimitcharid)
  return acclimitcharid_;
}
inline void AERewardItem::set_acclimitcharid(::google::protobuf::uint64 value) {
  set_has_acclimitcharid();
  acclimitcharid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardItem.acclimitcharid)
}

// optional uint32 multipledaycount = 4 [default = 0];
inline bool AERewardItem::has_multipledaycount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AERewardItem::set_has_multipledaycount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AERewardItem::clear_has_multipledaycount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AERewardItem::clear_multipledaycount() {
  multipledaycount_ = 0u;
  clear_has_multipledaycount();
}
inline ::google::protobuf::uint32 AERewardItem::multipledaycount() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardItem.multipledaycount)
  return multipledaycount_;
}
inline void AERewardItem::set_multipledaycount(::google::protobuf::uint32 value) {
  set_has_multipledaycount();
  multipledaycount_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardItem.multipledaycount)
}

// optional uint64 multipleacclimitcharid = 5 [default = 0];
inline bool AERewardItem::has_multipleacclimitcharid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AERewardItem::set_has_multipleacclimitcharid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AERewardItem::clear_has_multipleacclimitcharid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AERewardItem::clear_multipleacclimitcharid() {
  multipleacclimitcharid_ = GOOGLE_ULONGLONG(0);
  clear_has_multipleacclimitcharid();
}
inline ::google::protobuf::uint64 AERewardItem::multipleacclimitcharid() const {
  // @@protoc_insertion_point(field_get:Cmd.AERewardItem.multipleacclimitcharid)
  return multipleacclimitcharid_;
}
inline void AERewardItem::set_multipleacclimitcharid(::google::protobuf::uint64 value) {
  set_has_multipleacclimitcharid();
  multipleacclimitcharid_ = value;
  // @@protoc_insertion_point(field_set:Cmd.AERewardItem.multipleacclimitcharid)
}

// -------------------------------------------------------------------

// ActivityEvent

// optional .Cmd.EActivityEventType type = 1 [default = EACTIVITYEVENTTYPE_MIN];
inline bool ActivityEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEvent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Cmd::EActivityEventType ActivityEvent::type() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.type)
  return static_cast< ::Cmd::EActivityEventType >(type_);
}
inline void ActivityEvent::set_type(::Cmd::EActivityEventType value) {
  assert(::Cmd::EActivityEventType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEvent.type)
}

// optional uint64 begintime = 2 [default = 0];
inline bool ActivityEvent::has_begintime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEvent::set_has_begintime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEvent::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEvent::clear_begintime() {
  begintime_ = GOOGLE_ULONGLONG(0);
  clear_has_begintime();
}
inline ::google::protobuf::uint64 ActivityEvent::begintime() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.begintime)
  return begintime_;
}
inline void ActivityEvent::set_begintime(::google::protobuf::uint64 value) {
  set_has_begintime();
  begintime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEvent.begintime)
}

// optional uint64 endtime = 3 [default = 0];
inline bool ActivityEvent::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityEvent::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityEvent::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityEvent::clear_endtime() {
  endtime_ = GOOGLE_ULONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::uint64 ActivityEvent::endtime() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.endtime)
  return endtime_;
}
inline void ActivityEvent::set_endtime(::google::protobuf::uint64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEvent.endtime)
}

// optional .Cmd.AEFreeTransferInfo freetransfer = 4;
inline bool ActivityEvent::has_freetransfer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActivityEvent::set_has_freetransfer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActivityEvent::clear_has_freetransfer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActivityEvent::clear_freetransfer() {
  if (freetransfer_ != NULL) freetransfer_->::Cmd::AEFreeTransferInfo::Clear();
  clear_has_freetransfer();
}
inline const ::Cmd::AEFreeTransferInfo& ActivityEvent::freetransfer() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.freetransfer)
  return freetransfer_ != NULL ? *freetransfer_ : *default_instance_->freetransfer_;
}
inline ::Cmd::AEFreeTransferInfo* ActivityEvent::mutable_freetransfer() {
  set_has_freetransfer();
  if (freetransfer_ == NULL) freetransfer_ = new ::Cmd::AEFreeTransferInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.freetransfer)
  return freetransfer_;
}
inline ::Cmd::AEFreeTransferInfo* ActivityEvent::release_freetransfer() {
  clear_has_freetransfer();
  ::Cmd::AEFreeTransferInfo* temp = freetransfer_;
  freetransfer_ = NULL;
  return temp;
}
inline void ActivityEvent::set_allocated_freetransfer(::Cmd::AEFreeTransferInfo* freetransfer) {
  delete freetransfer_;
  freetransfer_ = freetransfer;
  if (freetransfer) {
    set_has_freetransfer();
  } else {
    clear_has_freetransfer();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEvent.freetransfer)
}

// repeated .Cmd.AERewardInfo reward = 5;
inline int ActivityEvent::reward_size() const {
  return reward_.size();
}
inline void ActivityEvent::clear_reward() {
  reward_.Clear();
}
inline const ::Cmd::AERewardInfo& ActivityEvent::reward(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.reward)
  return reward_.Get(index);
}
inline ::Cmd::AERewardInfo* ActivityEvent::mutable_reward(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.reward)
  return reward_.Mutable(index);
}
inline ::Cmd::AERewardInfo* ActivityEvent::add_reward() {
  // @@protoc_insertion_point(field_add:Cmd.ActivityEvent.reward)
  return reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardInfo >&
ActivityEvent::reward() const {
  // @@protoc_insertion_point(field_list:Cmd.ActivityEvent.reward)
  return reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardInfo >*
ActivityEvent::mutable_reward() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.ActivityEvent.reward)
  return &reward_;
}

// repeated .Cmd.AEResetInfo resetinfo = 6;
inline int ActivityEvent::resetinfo_size() const {
  return resetinfo_.size();
}
inline void ActivityEvent::clear_resetinfo() {
  resetinfo_.Clear();
}
inline const ::Cmd::AEResetInfo& ActivityEvent::resetinfo(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.resetinfo)
  return resetinfo_.Get(index);
}
inline ::Cmd::AEResetInfo* ActivityEvent::mutable_resetinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.resetinfo)
  return resetinfo_.Mutable(index);
}
inline ::Cmd::AEResetInfo* ActivityEvent::add_resetinfo() {
  // @@protoc_insertion_point(field_add:Cmd.ActivityEvent.resetinfo)
  return resetinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AEResetInfo >&
ActivityEvent::resetinfo() const {
  // @@protoc_insertion_point(field_list:Cmd.ActivityEvent.resetinfo)
  return resetinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AEResetInfo >*
ActivityEvent::mutable_resetinfo() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.ActivityEvent.resetinfo)
  return &resetinfo_;
}

// optional .Cmd.AELotteryDiscount lotterydiscount = 7;
inline bool ActivityEvent::has_lotterydiscount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActivityEvent::set_has_lotterydiscount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActivityEvent::clear_has_lotterydiscount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActivityEvent::clear_lotterydiscount() {
  if (lotterydiscount_ != NULL) lotterydiscount_->::Cmd::AELotteryDiscount::Clear();
  clear_has_lotterydiscount();
}
inline const ::Cmd::AELotteryDiscount& ActivityEvent::lotterydiscount() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.lotterydiscount)
  return lotterydiscount_ != NULL ? *lotterydiscount_ : *default_instance_->lotterydiscount_;
}
inline ::Cmd::AELotteryDiscount* ActivityEvent::mutable_lotterydiscount() {
  set_has_lotterydiscount();
  if (lotterydiscount_ == NULL) lotterydiscount_ = new ::Cmd::AELotteryDiscount;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.lotterydiscount)
  return lotterydiscount_;
}
inline ::Cmd::AELotteryDiscount* ActivityEvent::release_lotterydiscount() {
  clear_has_lotterydiscount();
  ::Cmd::AELotteryDiscount* temp = lotterydiscount_;
  lotterydiscount_ = NULL;
  return temp;
}
inline void ActivityEvent::set_allocated_lotterydiscount(::Cmd::AELotteryDiscount* lotterydiscount) {
  delete lotterydiscount_;
  lotterydiscount_ = lotterydiscount;
  if (lotterydiscount) {
    set_has_lotterydiscount();
  } else {
    clear_has_lotterydiscount();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEvent.lotterydiscount)
}

// optional .Cmd.AELotteryBanner lotterybanner = 8;
inline bool ActivityEvent::has_lotterybanner() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActivityEvent::set_has_lotterybanner() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActivityEvent::clear_has_lotterybanner() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActivityEvent::clear_lotterybanner() {
  if (lotterybanner_ != NULL) lotterybanner_->::Cmd::AELotteryBanner::Clear();
  clear_has_lotterybanner();
}
inline const ::Cmd::AELotteryBanner& ActivityEvent::lotterybanner() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.lotterybanner)
  return lotterybanner_ != NULL ? *lotterybanner_ : *default_instance_->lotterybanner_;
}
inline ::Cmd::AELotteryBanner* ActivityEvent::mutable_lotterybanner() {
  set_has_lotterybanner();
  if (lotterybanner_ == NULL) lotterybanner_ = new ::Cmd::AELotteryBanner;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.lotterybanner)
  return lotterybanner_;
}
inline ::Cmd::AELotteryBanner* ActivityEvent::release_lotterybanner() {
  clear_has_lotterybanner();
  ::Cmd::AELotteryBanner* temp = lotterybanner_;
  lotterybanner_ = NULL;
  return temp;
}
inline void ActivityEvent::set_allocated_lotterybanner(::Cmd::AELotteryBanner* lotterybanner) {
  delete lotterybanner_;
  lotterybanner_ = lotterybanner;
  if (lotterybanner) {
    set_has_lotterybanner();
  } else {
    clear_has_lotterybanner();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEvent.lotterybanner)
}

// optional uint64 id = 9;
inline bool ActivityEvent::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActivityEvent::set_has_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActivityEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActivityEvent::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ActivityEvent::id() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.id)
  return id_;
}
inline void ActivityEvent::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEvent.id)
}

// optional .Cmd.AEGuildBuildingSubmitInfo gbuildingsubmit = 10;
inline bool ActivityEvent::has_gbuildingsubmit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActivityEvent::set_has_gbuildingsubmit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActivityEvent::clear_has_gbuildingsubmit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActivityEvent::clear_gbuildingsubmit() {
  if (gbuildingsubmit_ != NULL) gbuildingsubmit_->::Cmd::AEGuildBuildingSubmitInfo::Clear();
  clear_has_gbuildingsubmit();
}
inline const ::Cmd::AEGuildBuildingSubmitInfo& ActivityEvent::gbuildingsubmit() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEvent.gbuildingsubmit)
  return gbuildingsubmit_ != NULL ? *gbuildingsubmit_ : *default_instance_->gbuildingsubmit_;
}
inline ::Cmd::AEGuildBuildingSubmitInfo* ActivityEvent::mutable_gbuildingsubmit() {
  set_has_gbuildingsubmit();
  if (gbuildingsubmit_ == NULL) gbuildingsubmit_ = new ::Cmd::AEGuildBuildingSubmitInfo;
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEvent.gbuildingsubmit)
  return gbuildingsubmit_;
}
inline ::Cmd::AEGuildBuildingSubmitInfo* ActivityEvent::release_gbuildingsubmit() {
  clear_has_gbuildingsubmit();
  ::Cmd::AEGuildBuildingSubmitInfo* temp = gbuildingsubmit_;
  gbuildingsubmit_ = NULL;
  return temp;
}
inline void ActivityEvent::set_allocated_gbuildingsubmit(::Cmd::AEGuildBuildingSubmitInfo* gbuildingsubmit) {
  delete gbuildingsubmit_;
  gbuildingsubmit_ = gbuildingsubmit;
  if (gbuildingsubmit) {
    set_has_gbuildingsubmit();
  } else {
    clear_has_gbuildingsubmit();
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.ActivityEvent.gbuildingsubmit)
}

// -------------------------------------------------------------------

// ActivityEventNtf

// optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
inline bool ActivityEventNtf::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEventNtf::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEventNtf::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEventNtf::clear_cmd() {
  cmd_ = 64;
  clear_has_cmd();
}
inline ::Cmd::Command ActivityEventNtf::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtf.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void ActivityEventNtf::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventNtf.cmd)
}

// optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_NTF];
inline bool ActivityEventNtf::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEventNtf::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEventNtf::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEventNtf::clear_param() {
  param_ = 1;
  clear_has_param();
}
inline ::Cmd::ActivityEventParam ActivityEventNtf::param() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtf.param)
  return static_cast< ::Cmd::ActivityEventParam >(param_);
}
inline void ActivityEventNtf::set_param(::Cmd::ActivityEventParam value) {
  assert(::Cmd::ActivityEventParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventNtf.param)
}

// repeated .Cmd.ActivityEvent events = 3;
inline int ActivityEventNtf::events_size() const {
  return events_.size();
}
inline void ActivityEventNtf::clear_events() {
  events_.Clear();
}
inline const ::Cmd::ActivityEvent& ActivityEventNtf::events(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtf.events)
  return events_.Get(index);
}
inline ::Cmd::ActivityEvent* ActivityEventNtf::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventNtf.events)
  return events_.Mutable(index);
}
inline ::Cmd::ActivityEvent* ActivityEventNtf::add_events() {
  // @@protoc_insertion_point(field_add:Cmd.ActivityEventNtf.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEvent >&
ActivityEventNtf::events() const {
  // @@protoc_insertion_point(field_list:Cmd.ActivityEventNtf.events)
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEvent >*
ActivityEventNtf::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.ActivityEventNtf.events)
  return &events_;
}

// -------------------------------------------------------------------

// ActivityEventUserDataNtf

// optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
inline bool ActivityEventUserDataNtf::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEventUserDataNtf::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEventUserDataNtf::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEventUserDataNtf::clear_cmd() {
  cmd_ = 64;
  clear_has_cmd();
}
inline ::Cmd::Command ActivityEventUserDataNtf::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventUserDataNtf.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void ActivityEventUserDataNtf::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventUserDataNtf.cmd)
}

// optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_USER_DATA_NTF];
inline bool ActivityEventUserDataNtf::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEventUserDataNtf::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEventUserDataNtf::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEventUserDataNtf::clear_param() {
  param_ = 2;
  clear_has_param();
}
inline ::Cmd::ActivityEventParam ActivityEventUserDataNtf::param() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventUserDataNtf.param)
  return static_cast< ::Cmd::ActivityEventParam >(param_);
}
inline void ActivityEventUserDataNtf::set_param(::Cmd::ActivityEventParam value) {
  assert(::Cmd::ActivityEventParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventUserDataNtf.param)
}

// repeated .Cmd.AERewardItem rewarditems = 3;
inline int ActivityEventUserDataNtf::rewarditems_size() const {
  return rewarditems_.size();
}
inline void ActivityEventUserDataNtf::clear_rewarditems() {
  rewarditems_.Clear();
}
inline const ::Cmd::AERewardItem& ActivityEventUserDataNtf::rewarditems(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventUserDataNtf.rewarditems)
  return rewarditems_.Get(index);
}
inline ::Cmd::AERewardItem* ActivityEventUserDataNtf::mutable_rewarditems(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventUserDataNtf.rewarditems)
  return rewarditems_.Mutable(index);
}
inline ::Cmd::AERewardItem* ActivityEventUserDataNtf::add_rewarditems() {
  // @@protoc_insertion_point(field_add:Cmd.ActivityEventUserDataNtf.rewarditems)
  return rewarditems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardItem >&
ActivityEventUserDataNtf::rewarditems() const {
  // @@protoc_insertion_point(field_list:Cmd.ActivityEventUserDataNtf.rewarditems)
  return rewarditems_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::AERewardItem >*
ActivityEventUserDataNtf::mutable_rewarditems() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.ActivityEventUserDataNtf.rewarditems)
  return &rewarditems_;
}

// -------------------------------------------------------------------

// ActivityEventCnt

// optional .Cmd.EActivityEventType type = 1 [default = EACTIVITYEVENTTYPE_MIN];
inline bool ActivityEventCnt::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEventCnt::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEventCnt::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEventCnt::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Cmd::EActivityEventType ActivityEventCnt::type() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventCnt.type)
  return static_cast< ::Cmd::EActivityEventType >(type_);
}
inline void ActivityEventCnt::set_type(::Cmd::EActivityEventType value) {
  assert(::Cmd::EActivityEventType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventCnt.type)
}

// optional uint64 id = 2;
inline bool ActivityEventCnt::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEventCnt::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEventCnt::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEventCnt::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ActivityEventCnt::id() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventCnt.id)
  return id_;
}
inline void ActivityEventCnt::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventCnt.id)
}

// optional uint32 count = 3;
inline bool ActivityEventCnt::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActivityEventCnt::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActivityEventCnt::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActivityEventCnt::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 ActivityEventCnt::count() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventCnt.count)
  return count_;
}
inline void ActivityEventCnt::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventCnt.count)
}

// -------------------------------------------------------------------

// ActivityEventNtfEventCntCmd

// optional .Cmd.Command cmd = 1 [default = ACTIVITY_EVENT_PROTOCMD];
inline bool ActivityEventNtfEventCntCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityEventNtfEventCntCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityEventNtfEventCntCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityEventNtfEventCntCmd::clear_cmd() {
  cmd_ = 64;
  clear_has_cmd();
}
inline ::Cmd::Command ActivityEventNtfEventCntCmd::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtfEventCntCmd.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void ActivityEventNtfEventCntCmd::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventNtfEventCntCmd.cmd)
}

// optional .Cmd.ActivityEventParam param = 2 [default = ACTIVITYEVENTPARAM_NTF_EVENT_CNT];
inline bool ActivityEventNtfEventCntCmd::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityEventNtfEventCntCmd::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityEventNtfEventCntCmd::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityEventNtfEventCntCmd::clear_param() {
  param_ = 3;
  clear_has_param();
}
inline ::Cmd::ActivityEventParam ActivityEventNtfEventCntCmd::param() const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtfEventCntCmd.param)
  return static_cast< ::Cmd::ActivityEventParam >(param_);
}
inline void ActivityEventNtfEventCntCmd::set_param(::Cmd::ActivityEventParam value) {
  assert(::Cmd::ActivityEventParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ActivityEventNtfEventCntCmd.param)
}

// repeated .Cmd.ActivityEventCnt cnt = 3;
inline int ActivityEventNtfEventCntCmd::cnt_size() const {
  return cnt_.size();
}
inline void ActivityEventNtfEventCntCmd::clear_cnt() {
  cnt_.Clear();
}
inline const ::Cmd::ActivityEventCnt& ActivityEventNtfEventCntCmd::cnt(int index) const {
  // @@protoc_insertion_point(field_get:Cmd.ActivityEventNtfEventCntCmd.cnt)
  return cnt_.Get(index);
}
inline ::Cmd::ActivityEventCnt* ActivityEventNtfEventCntCmd::mutable_cnt(int index) {
  // @@protoc_insertion_point(field_mutable:Cmd.ActivityEventNtfEventCntCmd.cnt)
  return cnt_.Mutable(index);
}
inline ::Cmd::ActivityEventCnt* ActivityEventNtfEventCntCmd::add_cnt() {
  // @@protoc_insertion_point(field_add:Cmd.ActivityEventNtfEventCntCmd.cnt)
  return cnt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEventCnt >&
ActivityEventNtfEventCntCmd::cnt() const {
  // @@protoc_insertion_point(field_list:Cmd.ActivityEventNtfEventCntCmd.cnt)
  return cnt_;
}
inline ::google::protobuf::RepeatedPtrField< ::Cmd::ActivityEventCnt >*
ActivityEventNtfEventCntCmd::mutable_cnt() {
  // @@protoc_insertion_point(field_mutable_list:Cmd.ActivityEventNtfEventCntCmd.cnt)
  return &cnt_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Cmd::ActivityEventParam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::ActivityEventParam>() {
  return ::Cmd::ActivityEventParam_descriptor();
}
template <> struct is_proto_enum< ::Cmd::EAERewardMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::EAERewardMode>() {
  return ::Cmd::EAERewardMode_descriptor();
}
template <> struct is_proto_enum< ::Cmd::ECoinType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::ECoinType>() {
  return ::Cmd::ECoinType_descriptor();
}
template <> struct is_proto_enum< ::Cmd::EUserType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::EUserType>() {
  return ::Cmd::EUserType_descriptor();
}
template <> struct is_proto_enum< ::Cmd::EActivityEventType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::EActivityEventType>() {
  return ::Cmd::EActivityEventType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ActivityEvent_2eproto__INCLUDED
