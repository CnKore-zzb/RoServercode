// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Authorize.proto

#ifndef PROTOBUF_Authorize_2eproto__INCLUDED
#define PROTOBUF_Authorize_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "xCmd.pb.h"
// @@protoc_insertion_point(includes)

namespace Cmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Authorize_2eproto();
void protobuf_AssignDesc_Authorize_2eproto();
void protobuf_ShutdownFile_Authorize_2eproto();

class SetAuthorizeUserCmd;
class ResetAuthorizeUserCmd;
class SyncAuthorizeToSession;
class NotifyAuthorizeUserCmd;
class SyncRealAuthorizeToSession;

enum AuthorizeParam {
  SET_AUTHORIZE_USER_CMD = 1,
  RESET_AUTHORIZE_USER_CMD = 2,
  SYNC_AUTHORIZE_TO_SESSION = 3,
  NOTIFY_AUTHORIZE_USER_CMD = 4,
  SYNC_REAL_AUTHORIZE_TO_SESSION = 5
};
bool AuthorizeParam_IsValid(int value);
const AuthorizeParam AuthorizeParam_MIN = SET_AUTHORIZE_USER_CMD;
const AuthorizeParam AuthorizeParam_MAX = SYNC_REAL_AUTHORIZE_TO_SESSION;
const int AuthorizeParam_ARRAYSIZE = AuthorizeParam_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthorizeParam_descriptor();
inline const ::std::string& AuthorizeParam_Name(AuthorizeParam value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthorizeParam_descriptor(), value);
}
inline bool AuthorizeParam_Parse(
    const ::std::string& name, AuthorizeParam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthorizeParam>(
    AuthorizeParam_descriptor(), name, value);
}
enum EUnlockType {
  EUNLOCKTYPE_MIN = 0,
  EUNLOCKTYPE_REFINE = 1,
  EUNLOCKTYPE_TRADE = 2,
  EUNLOCKTYPE_EQUIP_UPGRADE = 3,
  EUNLOCKTYPE_EQUIP_HOLE = 4,
  EUNLOCKTYPE_ENCHANT = 5,
  EUNLOCKTYPE_NPC_BUY = 6,
  EUNLOCKTYPE_GUILD = 7,
  EUNLOCKTYPE_FRIEND = 8,
  EUNLOCKTYPE_SELL = 9,
  EUNLOCKTYPE_USEITEM = 10,
  EUNLOCKTYPE_TRADE_GIFT = 11,
  EUNLOCKTYPE_DECOMPOSE = 12,
  EUNLOCKTYPE_AUCTION_SELL = 13,
  EUNLOCKTYPE_AUCTION_BUY = 14,
  EUNLOCKTYPE_ITEM_CODE = 15,
  EUNLOCKTYPE_MAX = 16
};
bool EUnlockType_IsValid(int value);
const EUnlockType EUnlockType_MIN = EUNLOCKTYPE_MIN;
const EUnlockType EUnlockType_MAX = EUNLOCKTYPE_MAX;
const int EUnlockType_ARRAYSIZE = EUnlockType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EUnlockType_descriptor();
inline const ::std::string& EUnlockType_Name(EUnlockType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EUnlockType_descriptor(), value);
}
inline bool EUnlockType_Parse(
    const ::std::string& name, EUnlockType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EUnlockType>(
    EUnlockType_descriptor(), name, value);
}
// ===================================================================

class SetAuthorizeUserCmd : public ::google::protobuf::Message {
 public:
  SetAuthorizeUserCmd();
  virtual ~SetAuthorizeUserCmd();

  SetAuthorizeUserCmd(const SetAuthorizeUserCmd& from);

  inline SetAuthorizeUserCmd& operator=(const SetAuthorizeUserCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAuthorizeUserCmd& default_instance();

  void Swap(SetAuthorizeUserCmd* other);

  // implements Message ----------------------------------------------

  SetAuthorizeUserCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAuthorizeUserCmd& from);
  void MergeFrom(const SetAuthorizeUserCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.AuthorizeParam param = 2 [default = SET_AUTHORIZE_USER_CMD];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::AuthorizeParam param() const;
  inline void set_param(::Cmd::AuthorizeParam value);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string oldpwd = 4;
  inline bool has_oldpwd() const;
  inline void clear_oldpwd();
  static const int kOldpwdFieldNumber = 4;
  inline const ::std::string& oldpwd() const;
  inline void set_oldpwd(const ::std::string& value);
  inline void set_oldpwd(const char* value);
  inline void set_oldpwd(const char* value, size_t size);
  inline ::std::string* mutable_oldpwd();
  inline ::std::string* release_oldpwd();
  inline void set_allocated_oldpwd(::std::string* oldpwd);

  // @@protoc_insertion_point(class_scope:Cmd.SetAuthorizeUserCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_oldpwd();
  inline void clear_has_oldpwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  ::std::string* password_;
  ::std::string* oldpwd_;
  friend void  protobuf_AddDesc_Authorize_2eproto();
  friend void protobuf_AssignDesc_Authorize_2eproto();
  friend void protobuf_ShutdownFile_Authorize_2eproto();

  void InitAsDefaultInstance();
  static SetAuthorizeUserCmd* default_instance_;
};
// -------------------------------------------------------------------

class ResetAuthorizeUserCmd : public ::google::protobuf::Message {
 public:
  ResetAuthorizeUserCmd();
  virtual ~ResetAuthorizeUserCmd();

  ResetAuthorizeUserCmd(const ResetAuthorizeUserCmd& from);

  inline ResetAuthorizeUserCmd& operator=(const ResetAuthorizeUserCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetAuthorizeUserCmd& default_instance();

  void Swap(ResetAuthorizeUserCmd* other);

  // implements Message ----------------------------------------------

  ResetAuthorizeUserCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetAuthorizeUserCmd& from);
  void MergeFrom(const ResetAuthorizeUserCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.AuthorizeParam param = 2 [default = RESET_AUTHORIZE_USER_CMD];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::AuthorizeParam param() const;
  inline void set_param(::Cmd::AuthorizeParam value);

  // required bool reset = 3;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 3;
  inline bool reset() const;
  inline void set_reset(bool value);

  // @@protoc_insertion_point(class_scope:Cmd.ResetAuthorizeUserCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  bool reset_;
  friend void  protobuf_AddDesc_Authorize_2eproto();
  friend void protobuf_AssignDesc_Authorize_2eproto();
  friend void protobuf_ShutdownFile_Authorize_2eproto();

  void InitAsDefaultInstance();
  static ResetAuthorizeUserCmd* default_instance_;
};
// -------------------------------------------------------------------

class SyncAuthorizeToSession : public ::google::protobuf::Message {
 public:
  SyncAuthorizeToSession();
  virtual ~SyncAuthorizeToSession();

  SyncAuthorizeToSession(const SyncAuthorizeToSession& from);

  inline SyncAuthorizeToSession& operator=(const SyncAuthorizeToSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncAuthorizeToSession& default_instance();

  void Swap(SyncAuthorizeToSession* other);

  // implements Message ----------------------------------------------

  SyncAuthorizeToSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncAuthorizeToSession& from);
  void MergeFrom(const SyncAuthorizeToSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.AuthorizeParam param = 2 [default = SYNC_AUTHORIZE_TO_SESSION];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::AuthorizeParam param() const;
  inline void set_param(::Cmd::AuthorizeParam value);

  // optional bool ignorepwd = 3 [default = false];
  inline bool has_ignorepwd() const;
  inline void clear_ignorepwd();
  static const int kIgnorepwdFieldNumber = 3;
  inline bool ignorepwd() const;
  inline void set_ignorepwd(bool value);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 resettime = 5 [default = 0];
  inline bool has_resettime() const;
  inline void clear_resettime();
  static const int kResettimeFieldNumber = 5;
  inline ::google::protobuf::uint32 resettime() const;
  inline void set_resettime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Cmd.SyncAuthorizeToSession)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_ignorepwd();
  inline void clear_has_ignorepwd();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_resettime();
  inline void clear_has_resettime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  ::std::string* password_;
  bool ignorepwd_;
  ::google::protobuf::uint32 resettime_;
  friend void  protobuf_AddDesc_Authorize_2eproto();
  friend void protobuf_AssignDesc_Authorize_2eproto();
  friend void protobuf_ShutdownFile_Authorize_2eproto();

  void InitAsDefaultInstance();
  static SyncAuthorizeToSession* default_instance_;
};
// -------------------------------------------------------------------

class NotifyAuthorizeUserCmd : public ::google::protobuf::Message {
 public:
  NotifyAuthorizeUserCmd();
  virtual ~NotifyAuthorizeUserCmd();

  NotifyAuthorizeUserCmd(const NotifyAuthorizeUserCmd& from);

  inline NotifyAuthorizeUserCmd& operator=(const NotifyAuthorizeUserCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyAuthorizeUserCmd& default_instance();

  void Swap(NotifyAuthorizeUserCmd* other);

  // implements Message ----------------------------------------------

  NotifyAuthorizeUserCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyAuthorizeUserCmd& from);
  void MergeFrom(const NotifyAuthorizeUserCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.AuthorizeParam param = 2 [default = NOTIFY_AUTHORIZE_USER_CMD];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::AuthorizeParam param() const;
  inline void set_param(::Cmd::AuthorizeParam value);

  // @@protoc_insertion_point(class_scope:Cmd.NotifyAuthorizeUserCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  friend void  protobuf_AddDesc_Authorize_2eproto();
  friend void protobuf_AssignDesc_Authorize_2eproto();
  friend void protobuf_ShutdownFile_Authorize_2eproto();

  void InitAsDefaultInstance();
  static NotifyAuthorizeUserCmd* default_instance_;
};
// -------------------------------------------------------------------

class SyncRealAuthorizeToSession : public ::google::protobuf::Message {
 public:
  SyncRealAuthorizeToSession();
  virtual ~SyncRealAuthorizeToSession();

  SyncRealAuthorizeToSession(const SyncRealAuthorizeToSession& from);

  inline SyncRealAuthorizeToSession& operator=(const SyncRealAuthorizeToSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncRealAuthorizeToSession& default_instance();

  void Swap(SyncRealAuthorizeToSession* other);

  // implements Message ----------------------------------------------

  SyncRealAuthorizeToSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncRealAuthorizeToSession& from);
  void MergeFrom(const SyncRealAuthorizeToSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::Cmd::Command cmd() const;
  inline void set_cmd(::Cmd::Command value);

  // optional .Cmd.AuthorizeParam param = 2 [default = SYNC_REAL_AUTHORIZE_TO_SESSION];
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline ::Cmd::AuthorizeParam param() const;
  inline void set_param(::Cmd::AuthorizeParam value);

  // optional bool authorized = 3 [default = false];
  inline bool has_authorized() const;
  inline void clear_authorized();
  static const int kAuthorizedFieldNumber = 3;
  inline bool authorized() const;
  inline void set_authorized(bool value);

  // @@protoc_insertion_point(class_scope:Cmd.SyncRealAuthorizeToSession)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_authorized();
  inline void clear_has_authorized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int cmd_;
  int param_;
  bool authorized_;
  friend void  protobuf_AddDesc_Authorize_2eproto();
  friend void protobuf_AssignDesc_Authorize_2eproto();
  friend void protobuf_ShutdownFile_Authorize_2eproto();

  void InitAsDefaultInstance();
  static SyncRealAuthorizeToSession* default_instance_;
};
// ===================================================================


// ===================================================================

// SetAuthorizeUserCmd

// optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
inline bool SetAuthorizeUserCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetAuthorizeUserCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetAuthorizeUserCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetAuthorizeUserCmd::clear_cmd() {
  cmd_ = 62;
  clear_has_cmd();
}
inline ::Cmd::Command SetAuthorizeUserCmd::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.SetAuthorizeUserCmd.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void SetAuthorizeUserCmd::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SetAuthorizeUserCmd.cmd)
}

// optional .Cmd.AuthorizeParam param = 2 [default = SET_AUTHORIZE_USER_CMD];
inline bool SetAuthorizeUserCmd::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetAuthorizeUserCmd::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetAuthorizeUserCmd::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetAuthorizeUserCmd::clear_param() {
  param_ = 1;
  clear_has_param();
}
inline ::Cmd::AuthorizeParam SetAuthorizeUserCmd::param() const {
  // @@protoc_insertion_point(field_get:Cmd.SetAuthorizeUserCmd.param)
  return static_cast< ::Cmd::AuthorizeParam >(param_);
}
inline void SetAuthorizeUserCmd::set_param(::Cmd::AuthorizeParam value) {
  assert(::Cmd::AuthorizeParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SetAuthorizeUserCmd.param)
}

// required string password = 3;
inline bool SetAuthorizeUserCmd::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetAuthorizeUserCmd::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetAuthorizeUserCmd::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetAuthorizeUserCmd::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SetAuthorizeUserCmd::password() const {
  // @@protoc_insertion_point(field_get:Cmd.SetAuthorizeUserCmd.password)
  return *password_;
}
inline void SetAuthorizeUserCmd::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.SetAuthorizeUserCmd.password)
}
inline void SetAuthorizeUserCmd::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.SetAuthorizeUserCmd.password)
}
inline void SetAuthorizeUserCmd::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.SetAuthorizeUserCmd.password)
}
inline ::std::string* SetAuthorizeUserCmd::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.SetAuthorizeUserCmd.password)
  return password_;
}
inline ::std::string* SetAuthorizeUserCmd::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetAuthorizeUserCmd::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.SetAuthorizeUserCmd.password)
}

// optional string oldpwd = 4;
inline bool SetAuthorizeUserCmd::has_oldpwd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetAuthorizeUserCmd::set_has_oldpwd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetAuthorizeUserCmd::clear_has_oldpwd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetAuthorizeUserCmd::clear_oldpwd() {
  if (oldpwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldpwd_->clear();
  }
  clear_has_oldpwd();
}
inline const ::std::string& SetAuthorizeUserCmd::oldpwd() const {
  // @@protoc_insertion_point(field_get:Cmd.SetAuthorizeUserCmd.oldpwd)
  return *oldpwd_;
}
inline void SetAuthorizeUserCmd::set_oldpwd(const ::std::string& value) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.SetAuthorizeUserCmd.oldpwd)
}
inline void SetAuthorizeUserCmd::set_oldpwd(const char* value) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.SetAuthorizeUserCmd.oldpwd)
}
inline void SetAuthorizeUserCmd::set_oldpwd(const char* value, size_t size) {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldpwd_ = new ::std::string;
  }
  oldpwd_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.SetAuthorizeUserCmd.oldpwd)
}
inline ::std::string* SetAuthorizeUserCmd::mutable_oldpwd() {
  set_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    oldpwd_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.SetAuthorizeUserCmd.oldpwd)
  return oldpwd_;
}
inline ::std::string* SetAuthorizeUserCmd::release_oldpwd() {
  clear_has_oldpwd();
  if (oldpwd_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = oldpwd_;
    oldpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SetAuthorizeUserCmd::set_allocated_oldpwd(::std::string* oldpwd) {
  if (oldpwd_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete oldpwd_;
  }
  if (oldpwd) {
    set_has_oldpwd();
    oldpwd_ = oldpwd;
  } else {
    clear_has_oldpwd();
    oldpwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.SetAuthorizeUserCmd.oldpwd)
}

// -------------------------------------------------------------------

// ResetAuthorizeUserCmd

// optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
inline bool ResetAuthorizeUserCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetAuthorizeUserCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetAuthorizeUserCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetAuthorizeUserCmd::clear_cmd() {
  cmd_ = 62;
  clear_has_cmd();
}
inline ::Cmd::Command ResetAuthorizeUserCmd::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.ResetAuthorizeUserCmd.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void ResetAuthorizeUserCmd::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ResetAuthorizeUserCmd.cmd)
}

// optional .Cmd.AuthorizeParam param = 2 [default = RESET_AUTHORIZE_USER_CMD];
inline bool ResetAuthorizeUserCmd::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetAuthorizeUserCmd::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetAuthorizeUserCmd::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetAuthorizeUserCmd::clear_param() {
  param_ = 2;
  clear_has_param();
}
inline ::Cmd::AuthorizeParam ResetAuthorizeUserCmd::param() const {
  // @@protoc_insertion_point(field_get:Cmd.ResetAuthorizeUserCmd.param)
  return static_cast< ::Cmd::AuthorizeParam >(param_);
}
inline void ResetAuthorizeUserCmd::set_param(::Cmd::AuthorizeParam value) {
  assert(::Cmd::AuthorizeParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ResetAuthorizeUserCmd.param)
}

// required bool reset = 3;
inline bool ResetAuthorizeUserCmd::has_reset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetAuthorizeUserCmd::set_has_reset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetAuthorizeUserCmd::clear_has_reset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetAuthorizeUserCmd::clear_reset() {
  reset_ = false;
  clear_has_reset();
}
inline bool ResetAuthorizeUserCmd::reset() const {
  // @@protoc_insertion_point(field_get:Cmd.ResetAuthorizeUserCmd.reset)
  return reset_;
}
inline void ResetAuthorizeUserCmd::set_reset(bool value) {
  set_has_reset();
  reset_ = value;
  // @@protoc_insertion_point(field_set:Cmd.ResetAuthorizeUserCmd.reset)
}

// -------------------------------------------------------------------

// SyncAuthorizeToSession

// optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
inline bool SyncAuthorizeToSession::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncAuthorizeToSession::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncAuthorizeToSession::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncAuthorizeToSession::clear_cmd() {
  cmd_ = 62;
  clear_has_cmd();
}
inline ::Cmd::Command SyncAuthorizeToSession::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncAuthorizeToSession.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void SyncAuthorizeToSession::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncAuthorizeToSession.cmd)
}

// optional .Cmd.AuthorizeParam param = 2 [default = SYNC_AUTHORIZE_TO_SESSION];
inline bool SyncAuthorizeToSession::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncAuthorizeToSession::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncAuthorizeToSession::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncAuthorizeToSession::clear_param() {
  param_ = 3;
  clear_has_param();
}
inline ::Cmd::AuthorizeParam SyncAuthorizeToSession::param() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncAuthorizeToSession.param)
  return static_cast< ::Cmd::AuthorizeParam >(param_);
}
inline void SyncAuthorizeToSession::set_param(::Cmd::AuthorizeParam value) {
  assert(::Cmd::AuthorizeParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncAuthorizeToSession.param)
}

// optional bool ignorepwd = 3 [default = false];
inline bool SyncAuthorizeToSession::has_ignorepwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncAuthorizeToSession::set_has_ignorepwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncAuthorizeToSession::clear_has_ignorepwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncAuthorizeToSession::clear_ignorepwd() {
  ignorepwd_ = false;
  clear_has_ignorepwd();
}
inline bool SyncAuthorizeToSession::ignorepwd() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncAuthorizeToSession.ignorepwd)
  return ignorepwd_;
}
inline void SyncAuthorizeToSession::set_ignorepwd(bool value) {
  set_has_ignorepwd();
  ignorepwd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncAuthorizeToSession.ignorepwd)
}

// optional string password = 4;
inline bool SyncAuthorizeToSession::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncAuthorizeToSession::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncAuthorizeToSession::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncAuthorizeToSession::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& SyncAuthorizeToSession::password() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncAuthorizeToSession.password)
  return *password_;
}
inline void SyncAuthorizeToSession::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Cmd.SyncAuthorizeToSession.password)
}
inline void SyncAuthorizeToSession::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Cmd.SyncAuthorizeToSession.password)
}
inline void SyncAuthorizeToSession::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Cmd.SyncAuthorizeToSession.password)
}
inline ::std::string* SyncAuthorizeToSession::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Cmd.SyncAuthorizeToSession.password)
  return password_;
}
inline ::std::string* SyncAuthorizeToSession::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SyncAuthorizeToSession::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Cmd.SyncAuthorizeToSession.password)
}

// optional uint32 resettime = 5 [default = 0];
inline bool SyncAuthorizeToSession::has_resettime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncAuthorizeToSession::set_has_resettime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncAuthorizeToSession::clear_has_resettime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncAuthorizeToSession::clear_resettime() {
  resettime_ = 0u;
  clear_has_resettime();
}
inline ::google::protobuf::uint32 SyncAuthorizeToSession::resettime() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncAuthorizeToSession.resettime)
  return resettime_;
}
inline void SyncAuthorizeToSession::set_resettime(::google::protobuf::uint32 value) {
  set_has_resettime();
  resettime_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncAuthorizeToSession.resettime)
}

// -------------------------------------------------------------------

// NotifyAuthorizeUserCmd

// optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
inline bool NotifyAuthorizeUserCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyAuthorizeUserCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyAuthorizeUserCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyAuthorizeUserCmd::clear_cmd() {
  cmd_ = 62;
  clear_has_cmd();
}
inline ::Cmd::Command NotifyAuthorizeUserCmd::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.NotifyAuthorizeUserCmd.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void NotifyAuthorizeUserCmd::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.NotifyAuthorizeUserCmd.cmd)
}

// optional .Cmd.AuthorizeParam param = 2 [default = NOTIFY_AUTHORIZE_USER_CMD];
inline bool NotifyAuthorizeUserCmd::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyAuthorizeUserCmd::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyAuthorizeUserCmd::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyAuthorizeUserCmd::clear_param() {
  param_ = 4;
  clear_has_param();
}
inline ::Cmd::AuthorizeParam NotifyAuthorizeUserCmd::param() const {
  // @@protoc_insertion_point(field_get:Cmd.NotifyAuthorizeUserCmd.param)
  return static_cast< ::Cmd::AuthorizeParam >(param_);
}
inline void NotifyAuthorizeUserCmd::set_param(::Cmd::AuthorizeParam value) {
  assert(::Cmd::AuthorizeParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.NotifyAuthorizeUserCmd.param)
}

// -------------------------------------------------------------------

// SyncRealAuthorizeToSession

// optional .Cmd.Command cmd = 1 [default = SESSION_USER_AUTHORIZE_PROTOCMD];
inline bool SyncRealAuthorizeToSession::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncRealAuthorizeToSession::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncRealAuthorizeToSession::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncRealAuthorizeToSession::clear_cmd() {
  cmd_ = 62;
  clear_has_cmd();
}
inline ::Cmd::Command SyncRealAuthorizeToSession::cmd() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncRealAuthorizeToSession.cmd)
  return static_cast< ::Cmd::Command >(cmd_);
}
inline void SyncRealAuthorizeToSession::set_cmd(::Cmd::Command value) {
  assert(::Cmd::Command_IsValid(value));
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncRealAuthorizeToSession.cmd)
}

// optional .Cmd.AuthorizeParam param = 2 [default = SYNC_REAL_AUTHORIZE_TO_SESSION];
inline bool SyncRealAuthorizeToSession::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncRealAuthorizeToSession::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncRealAuthorizeToSession::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncRealAuthorizeToSession::clear_param() {
  param_ = 5;
  clear_has_param();
}
inline ::Cmd::AuthorizeParam SyncRealAuthorizeToSession::param() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncRealAuthorizeToSession.param)
  return static_cast< ::Cmd::AuthorizeParam >(param_);
}
inline void SyncRealAuthorizeToSession::set_param(::Cmd::AuthorizeParam value) {
  assert(::Cmd::AuthorizeParam_IsValid(value));
  set_has_param();
  param_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncRealAuthorizeToSession.param)
}

// optional bool authorized = 3 [default = false];
inline bool SyncRealAuthorizeToSession::has_authorized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncRealAuthorizeToSession::set_has_authorized() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncRealAuthorizeToSession::clear_has_authorized() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncRealAuthorizeToSession::clear_authorized() {
  authorized_ = false;
  clear_has_authorized();
}
inline bool SyncRealAuthorizeToSession::authorized() const {
  // @@protoc_insertion_point(field_get:Cmd.SyncRealAuthorizeToSession.authorized)
  return authorized_;
}
inline void SyncRealAuthorizeToSession::set_authorized(bool value) {
  set_has_authorized();
  authorized_ = value;
  // @@protoc_insertion_point(field_set:Cmd.SyncRealAuthorizeToSession.authorized)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Cmd::AuthorizeParam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::AuthorizeParam>() {
  return ::Cmd::AuthorizeParam_descriptor();
}
template <> struct is_proto_enum< ::Cmd::EUnlockType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Cmd::EUnlockType>() {
  return ::Cmd::EUnlockType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Authorize_2eproto__INCLUDED
