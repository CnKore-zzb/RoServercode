// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RecordTrade.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "RecordTrade.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace Cmd {

namespace {

const ::google::protobuf::Descriptor* SearchCond_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SearchCond_reflection_ = NULL;
const ::google::protobuf::Descriptor* BriefPendingListRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BriefPendingListRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* DetailPendingListRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DetailPendingListRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* BriefBuyInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BriefBuyInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemSellInfoRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemSellInfoRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* MyPendingListRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MyPendingListRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* NameInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NameInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NameInfoList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NameInfoList_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogItemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogItemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MyTradeLogRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MyTradeLogRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* TakeLogCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TakeLogCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* AddNewLog_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AddNewLog_reflection_ = NULL;
const ::google::protobuf::Descriptor* FetchNameInfoCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FetchNameInfoCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqServerPriceRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqServerPriceRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* BuyItemRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BuyItemRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* SellItemRecordTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SellItemRecordTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* CancelItemRecordTrade_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CancelItemRecordTrade_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResellPendingRecordTrade_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResellPendingRecordTrade_reflection_ = NULL;
const ::google::protobuf::Descriptor* PanelRecordTrade_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PanelRecordTrade_reflection_ = NULL;
const ::google::protobuf::Descriptor* ListNtfRecordTrade_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ListNtfRecordTrade_reflection_ = NULL;
const ::google::protobuf::Descriptor* HotItemidRecordTrade_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HotItemidRecordTrade_reflection_ = NULL;
const ::google::protobuf::Descriptor* NtfCanTakeCountTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NtfCanTakeCountTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* GiveTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GiveTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* AcceptTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AcceptTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* RefuseTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RefuseTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* GiveItemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GiveItemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqGiveItemInfoCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqGiveItemInfoCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckPackageSizeTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckPackageSizeTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* QucikTakeLogTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QucikTakeLogTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* ItemCount_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ItemCount_reflection_ = NULL;
const ::google::protobuf::Descriptor* QueryItemCountTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  QueryItemCountTradeCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* LotteryGiveInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LotteryGiveInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* LotteryGiveCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LotteryGiveCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* TodayFinanceItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TodayFinanceItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* TodayFinanceRank_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TodayFinanceRank_reflection_ = NULL;
const ::google::protobuf::Descriptor* TodayFinanceDetail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TodayFinanceDetail_reflection_ = NULL;
const ::google::protobuf::Descriptor* BoothPlayerPendingListCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BoothPlayerPendingListCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpdateOrderTradeCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpdateOrderTradeCmd_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RecordUserTradeParam_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RankType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EOperType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ETakeStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StateType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EPanelOperType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EListNtfType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EFinanceDateType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EFinanceRankType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_RecordTrade_2eproto() {
  protobuf_AddDesc_RecordTrade_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "RecordTrade.proto");
  GOOGLE_CHECK(file != NULL);
  SearchCond_descriptor_ = file->message_type(0);
  static const int SearchCond_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, item_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, page_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, page_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, rank_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, trade_type_),
  };
  SearchCond_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SearchCond_descriptor_,
      SearchCond::default_instance_,
      SearchCond_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SearchCond, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SearchCond));
  BriefPendingListRecordTradeCmd_descriptor_ = file->message_type(1);
  static const int BriefPendingListRecordTradeCmd_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, category_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, job_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, fashion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, pub_lists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, lists_),
  };
  BriefPendingListRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BriefPendingListRecordTradeCmd_descriptor_,
      BriefPendingListRecordTradeCmd::default_instance_,
      BriefPendingListRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefPendingListRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BriefPendingListRecordTradeCmd));
  DetailPendingListRecordTradeCmd_descriptor_ = file->message_type(2);
  static const int DetailPendingListRecordTradeCmd_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, search_cond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, lists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, total_page_count_),
  };
  DetailPendingListRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DetailPendingListRecordTradeCmd_descriptor_,
      DetailPendingListRecordTradeCmd::default_instance_,
      DetailPendingListRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetailPendingListRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DetailPendingListRecordTradeCmd));
  BriefBuyInfo_descriptor_ = file->message_type(3);
  static const int BriefBuyInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefBuyInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefBuyInfo, time_),
  };
  BriefBuyInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BriefBuyInfo_descriptor_,
      BriefBuyInfo::default_instance_,
      BriefBuyInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefBuyInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BriefBuyInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BriefBuyInfo));
  ItemSellInfoRecordTradeCmd_descriptor_ = file->message_type(4);
  static const int ItemSellInfoRecordTradeCmd_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, refine_lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, publicity_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, statetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, buyer_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, buy_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, quota_),
  };
  ItemSellInfoRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemSellInfoRecordTradeCmd_descriptor_,
      ItemSellInfoRecordTradeCmd::default_instance_,
      ItemSellInfoRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemSellInfoRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemSellInfoRecordTradeCmd));
  MyPendingListRecordTradeCmd_descriptor_ = file->message_type(5);
  static const int MyPendingListRecordTradeCmd_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, search_cond_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, lists_),
  };
  MyPendingListRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MyPendingListRecordTradeCmd_descriptor_,
      MyPendingListRecordTradeCmd::default_instance_,
      MyPendingListRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyPendingListRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MyPendingListRecordTradeCmd));
  NameInfo_descriptor_ = file->message_type(6);
  static const int NameInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfo, zoneid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfo, count_),
  };
  NameInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NameInfo_descriptor_,
      NameInfo::default_instance_,
      NameInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NameInfo));
  NameInfoList_descriptor_ = file->message_type(7);
  static const int NameInfoList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfoList, name_infos_),
  };
  NameInfoList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NameInfoList_descriptor_,
      NameInfoList::default_instance_,
      NameInfoList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfoList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NameInfoList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NameInfoList));
  LogItemInfo_descriptor_ = file->message_type(8);
  static const int LogItemInfo_offsets_[31] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, logtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, refine_lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, damage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, tradetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, tax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, getmoney_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, costmoney_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, failcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, retmoney_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, totalcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, endtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, name_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, is_many_people_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, name_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, itemdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, receiverid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, receivername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, receiverzoneid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, quota_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, background_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, expiretime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, ret_cost_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, cangive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, trade_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, is_public_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, quota_cost_),
  };
  LogItemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogItemInfo_descriptor_,
      LogItemInfo::default_instance_,
      LogItemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogItemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogItemInfo));
  MyTradeLogRecordTradeCmd_descriptor_ = file->message_type(9);
  static const int MyTradeLogRecordTradeCmd_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, total_page_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, log_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, trade_type_),
  };
  MyTradeLogRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MyTradeLogRecordTradeCmd_descriptor_,
      MyTradeLogRecordTradeCmd::default_instance_,
      MyTradeLogRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MyTradeLogRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MyTradeLogRecordTradeCmd));
  TakeLogCmd_descriptor_ = file->message_type(10);
  static const int TakeLogCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, success_),
  };
  TakeLogCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TakeLogCmd_descriptor_,
      TakeLogCmd::default_instance_,
      TakeLogCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeLogCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TakeLogCmd));
  AddNewLog_descriptor_ = file->message_type(11);
  static const int AddNewLog_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, log_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, total_page_count_),
  };
  AddNewLog_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AddNewLog_descriptor_,
      AddNewLog::default_instance_,
      AddNewLog_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AddNewLog, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AddNewLog));
  FetchNameInfoCmd_descriptor_ = file->message_type(12);
  static const int FetchNameInfoCmd_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, total_page_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, name_list_),
  };
  FetchNameInfoCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FetchNameInfoCmd_descriptor_,
      FetchNameInfoCmd::default_instance_,
      FetchNameInfoCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FetchNameInfoCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FetchNameInfoCmd));
  ReqServerPriceRecordTradeCmd_descriptor_ = file->message_type(13);
  static const int ReqServerPriceRecordTradeCmd_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, itemdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, issell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, statetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, buyer_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, end_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, trade_type_),
  };
  ReqServerPriceRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqServerPriceRecordTradeCmd_descriptor_,
      ReqServerPriceRecordTradeCmd::default_instance_,
      ReqServerPriceRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqServerPriceRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqServerPriceRecordTradeCmd));
  BuyItemRecordTradeCmd_descriptor_ = file->message_type(14);
  static const int BuyItemRecordTradeCmd_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, item_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, type_),
  };
  BuyItemRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BuyItemRecordTradeCmd_descriptor_,
      BuyItemRecordTradeCmd::default_instance_,
      BuyItemRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BuyItemRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BuyItemRecordTradeCmd));
  SellItemRecordTradeCmd_descriptor_ = file->message_type(15);
  static const int SellItemRecordTradeCmd_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, item_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, type_),
  };
  SellItemRecordTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SellItemRecordTradeCmd_descriptor_,
      SellItemRecordTradeCmd::default_instance_,
      SellItemRecordTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SellItemRecordTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SellItemRecordTradeCmd));
  CancelItemRecordTrade_descriptor_ = file->message_type(16);
  static const int CancelItemRecordTrade_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, item_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, quota_),
  };
  CancelItemRecordTrade_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CancelItemRecordTrade_descriptor_,
      CancelItemRecordTrade::default_instance_,
      CancelItemRecordTrade_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelItemRecordTrade, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CancelItemRecordTrade));
  ResellPendingRecordTrade_descriptor_ = file->message_type(17);
  static const int ResellPendingRecordTrade_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, item_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, order_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, quota_),
  };
  ResellPendingRecordTrade_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResellPendingRecordTrade_descriptor_,
      ResellPendingRecordTrade::default_instance_,
      ResellPendingRecordTrade_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResellPendingRecordTrade, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResellPendingRecordTrade));
  PanelRecordTrade_descriptor_ = file->message_type(18);
  static const int PanelRecordTrade_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, oper_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, trade_type_),
  };
  PanelRecordTrade_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PanelRecordTrade_descriptor_,
      PanelRecordTrade::default_instance_,
      PanelRecordTrade_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PanelRecordTrade, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PanelRecordTrade));
  ListNtfRecordTrade_descriptor_ = file->message_type(19);
  static const int ListNtfRecordTrade_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, trade_type_),
  };
  ListNtfRecordTrade_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ListNtfRecordTrade_descriptor_,
      ListNtfRecordTrade::default_instance_,
      ListNtfRecordTrade_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ListNtfRecordTrade, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ListNtfRecordTrade));
  HotItemidRecordTrade_descriptor_ = file->message_type(20);
  static const int HotItemidRecordTrade_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, job_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, pub_lists_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, lists_),
  };
  HotItemidRecordTrade_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HotItemidRecordTrade_descriptor_,
      HotItemidRecordTrade::default_instance_,
      HotItemidRecordTrade_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HotItemidRecordTrade, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HotItemidRecordTrade));
  NtfCanTakeCountTradeCmd_descriptor_ = file->message_type(21);
  static const int NtfCanTakeCountTradeCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, trade_type_),
  };
  NtfCanTakeCountTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NtfCanTakeCountTradeCmd_descriptor_,
      NtfCanTakeCountTradeCmd::default_instance_,
      NtfCanTakeCountTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NtfCanTakeCountTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NtfCanTakeCountTradeCmd));
  GiveTradeCmd_descriptor_ = file->message_type(22);
  static const int GiveTradeCmd_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, logtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, friendid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, anonymous_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, background_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, success_),
  };
  GiveTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GiveTradeCmd_descriptor_,
      GiveTradeCmd::default_instance_,
      GiveTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GiveTradeCmd));
  AcceptTradeCmd_descriptor_ = file->message_type(23);
  static const int AcceptTradeCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, success_),
  };
  AcceptTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AcceptTradeCmd_descriptor_,
      AcceptTradeCmd::default_instance_,
      AcceptTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AcceptTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AcceptTradeCmd));
  RefuseTradeCmd_descriptor_ = file->message_type(24);
  static const int RefuseTradeCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, success_),
  };
  RefuseTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RefuseTradeCmd_descriptor_,
      RefuseTradeCmd::default_instance_,
      RefuseTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RefuseTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RefuseTradeCmd));
  GiveItemInfo_descriptor_ = file->message_type(25);
  static const int GiveItemInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, itemdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, senderid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, sendername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, anonymous_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, expiretime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, quota_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, receivername_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, background_),
  };
  GiveItemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GiveItemInfo_descriptor_,
      GiveItemInfo::default_instance_,
      GiveItemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GiveItemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GiveItemInfo));
  ReqGiveItemInfoCmd_descriptor_ = file->message_type(26);
  static const int ReqGiveItemInfoCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, iteminfo_),
  };
  ReqGiveItemInfoCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqGiveItemInfoCmd_descriptor_,
      ReqGiveItemInfoCmd::default_instance_,
      ReqGiveItemInfoCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqGiveItemInfoCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqGiveItemInfoCmd));
  CheckPackageSizeTradeCmd_descriptor_ = file->message_type(27);
  static const int CheckPackageSizeTradeCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, items_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, ret_),
  };
  CheckPackageSizeTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckPackageSizeTradeCmd_descriptor_,
      CheckPackageSizeTradeCmd::default_instance_,
      CheckPackageSizeTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckPackageSizeTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckPackageSizeTradeCmd));
  QucikTakeLogTradeCmd_descriptor_ = file->message_type(28);
  static const int QucikTakeLogTradeCmd_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QucikTakeLogTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QucikTakeLogTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QucikTakeLogTradeCmd, trade_type_),
  };
  QucikTakeLogTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QucikTakeLogTradeCmd_descriptor_,
      QucikTakeLogTradeCmd::default_instance_,
      QucikTakeLogTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QucikTakeLogTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QucikTakeLogTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QucikTakeLogTradeCmd));
  ItemCount_descriptor_ = file->message_type(29);
  static const int ItemCount_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemCount, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemCount, count_),
  };
  ItemCount_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ItemCount_descriptor_,
      ItemCount::default_instance_,
      ItemCount_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemCount, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ItemCount, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ItemCount));
  QueryItemCountTradeCmd_descriptor_ = file->message_type(30);
  static const int QueryItemCountTradeCmd_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, items_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, res_items_),
  };
  QueryItemCountTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      QueryItemCountTradeCmd_descriptor_,
      QueryItemCountTradeCmd::default_instance_,
      QueryItemCountTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(QueryItemCountTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(QueryItemCountTradeCmd));
  LotteryGiveInfo_descriptor_ = file->message_type(31);
  static const int LotteryGiveInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, year_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, month_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, content_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, configid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, receiverid_),
  };
  LotteryGiveInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LotteryGiveInfo_descriptor_,
      LotteryGiveInfo::default_instance_,
      LotteryGiveInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LotteryGiveInfo));
  LotteryGiveCmd_descriptor_ = file->message_type(32);
  static const int LotteryGiveCmd_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveCmd, iteminfo_),
  };
  LotteryGiveCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LotteryGiveCmd_descriptor_,
      LotteryGiveCmd::default_instance_,
      LotteryGiveCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LotteryGiveCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LotteryGiveCmd));
  TodayFinanceItem_descriptor_ = file->message_type(33);
  static const int TodayFinanceItem_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceItem, item_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceItem, ratio_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceItem, time_),
  };
  TodayFinanceItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TodayFinanceItem_descriptor_,
      TodayFinanceItem::default_instance_,
      TodayFinanceItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TodayFinanceItem));
  TodayFinanceRank_descriptor_ = file->message_type(34);
  static const int TodayFinanceRank_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, rank_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, date_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, lists_),
  };
  TodayFinanceRank_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TodayFinanceRank_descriptor_,
      TodayFinanceRank::default_instance_,
      TodayFinanceRank_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceRank, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TodayFinanceRank));
  TodayFinanceDetail_descriptor_ = file->message_type(35);
  static const int TodayFinanceDetail_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, item_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, rank_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, date_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, lists_),
  };
  TodayFinanceDetail_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TodayFinanceDetail_descriptor_,
      TodayFinanceDetail::default_instance_,
      TodayFinanceDetail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TodayFinanceDetail, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TodayFinanceDetail));
  BoothPlayerPendingListCmd_descriptor_ = file->message_type(36);
  static const int BoothPlayerPendingListCmd_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, lists_),
  };
  BoothPlayerPendingListCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BoothPlayerPendingListCmd_descriptor_,
      BoothPlayerPendingListCmd::default_instance_,
      BoothPlayerPendingListCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BoothPlayerPendingListCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BoothPlayerPendingListCmd));
  UpdateOrderTradeCmd_descriptor_ = file->message_type(37);
  static const int UpdateOrderTradeCmd_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, cmd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, type_),
  };
  UpdateOrderTradeCmd_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpdateOrderTradeCmd_descriptor_,
      UpdateOrderTradeCmd::default_instance_,
      UpdateOrderTradeCmd_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpdateOrderTradeCmd, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpdateOrderTradeCmd));
  RecordUserTradeParam_descriptor_ = file->enum_type(0);
  RankType_descriptor_ = file->enum_type(1);
  EOperType_descriptor_ = file->enum_type(2);
  ETakeStatus_descriptor_ = file->enum_type(3);
  StateType_descriptor_ = file->enum_type(4);
  EPanelOperType_descriptor_ = file->enum_type(5);
  EListNtfType_descriptor_ = file->enum_type(6);
  EFinanceDateType_descriptor_ = file->enum_type(7);
  EFinanceRankType_descriptor_ = file->enum_type(8);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_RecordTrade_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SearchCond_descriptor_, &SearchCond::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BriefPendingListRecordTradeCmd_descriptor_, &BriefPendingListRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DetailPendingListRecordTradeCmd_descriptor_, &DetailPendingListRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BriefBuyInfo_descriptor_, &BriefBuyInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemSellInfoRecordTradeCmd_descriptor_, &ItemSellInfoRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MyPendingListRecordTradeCmd_descriptor_, &MyPendingListRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NameInfo_descriptor_, &NameInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NameInfoList_descriptor_, &NameInfoList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogItemInfo_descriptor_, &LogItemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MyTradeLogRecordTradeCmd_descriptor_, &MyTradeLogRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TakeLogCmd_descriptor_, &TakeLogCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AddNewLog_descriptor_, &AddNewLog::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FetchNameInfoCmd_descriptor_, &FetchNameInfoCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqServerPriceRecordTradeCmd_descriptor_, &ReqServerPriceRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BuyItemRecordTradeCmd_descriptor_, &BuyItemRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SellItemRecordTradeCmd_descriptor_, &SellItemRecordTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CancelItemRecordTrade_descriptor_, &CancelItemRecordTrade::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResellPendingRecordTrade_descriptor_, &ResellPendingRecordTrade::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PanelRecordTrade_descriptor_, &PanelRecordTrade::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ListNtfRecordTrade_descriptor_, &ListNtfRecordTrade::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HotItemidRecordTrade_descriptor_, &HotItemidRecordTrade::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NtfCanTakeCountTradeCmd_descriptor_, &NtfCanTakeCountTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GiveTradeCmd_descriptor_, &GiveTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AcceptTradeCmd_descriptor_, &AcceptTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RefuseTradeCmd_descriptor_, &RefuseTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GiveItemInfo_descriptor_, &GiveItemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqGiveItemInfoCmd_descriptor_, &ReqGiveItemInfoCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckPackageSizeTradeCmd_descriptor_, &CheckPackageSizeTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QucikTakeLogTradeCmd_descriptor_, &QucikTakeLogTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ItemCount_descriptor_, &ItemCount::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    QueryItemCountTradeCmd_descriptor_, &QueryItemCountTradeCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LotteryGiveInfo_descriptor_, &LotteryGiveInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LotteryGiveCmd_descriptor_, &LotteryGiveCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TodayFinanceItem_descriptor_, &TodayFinanceItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TodayFinanceRank_descriptor_, &TodayFinanceRank::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TodayFinanceDetail_descriptor_, &TodayFinanceDetail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BoothPlayerPendingListCmd_descriptor_, &BoothPlayerPendingListCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpdateOrderTradeCmd_descriptor_, &UpdateOrderTradeCmd::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_RecordTrade_2eproto() {
  delete SearchCond::default_instance_;
  delete SearchCond_reflection_;
  delete BriefPendingListRecordTradeCmd::default_instance_;
  delete BriefPendingListRecordTradeCmd_reflection_;
  delete DetailPendingListRecordTradeCmd::default_instance_;
  delete DetailPendingListRecordTradeCmd_reflection_;
  delete BriefBuyInfo::default_instance_;
  delete BriefBuyInfo_reflection_;
  delete ItemSellInfoRecordTradeCmd::default_instance_;
  delete ItemSellInfoRecordTradeCmd_reflection_;
  delete MyPendingListRecordTradeCmd::default_instance_;
  delete MyPendingListRecordTradeCmd_reflection_;
  delete NameInfo::default_instance_;
  delete NameInfo_reflection_;
  delete NameInfoList::default_instance_;
  delete NameInfoList_reflection_;
  delete LogItemInfo::default_instance_;
  delete LogItemInfo_reflection_;
  delete MyTradeLogRecordTradeCmd::default_instance_;
  delete MyTradeLogRecordTradeCmd_reflection_;
  delete TakeLogCmd::default_instance_;
  delete TakeLogCmd_reflection_;
  delete AddNewLog::default_instance_;
  delete AddNewLog_reflection_;
  delete FetchNameInfoCmd::default_instance_;
  delete FetchNameInfoCmd_reflection_;
  delete ReqServerPriceRecordTradeCmd::default_instance_;
  delete ReqServerPriceRecordTradeCmd_reflection_;
  delete BuyItemRecordTradeCmd::default_instance_;
  delete BuyItemRecordTradeCmd_reflection_;
  delete SellItemRecordTradeCmd::default_instance_;
  delete SellItemRecordTradeCmd_reflection_;
  delete CancelItemRecordTrade::default_instance_;
  delete CancelItemRecordTrade_reflection_;
  delete ResellPendingRecordTrade::default_instance_;
  delete ResellPendingRecordTrade_reflection_;
  delete PanelRecordTrade::default_instance_;
  delete PanelRecordTrade_reflection_;
  delete ListNtfRecordTrade::default_instance_;
  delete ListNtfRecordTrade_reflection_;
  delete HotItemidRecordTrade::default_instance_;
  delete HotItemidRecordTrade_reflection_;
  delete NtfCanTakeCountTradeCmd::default_instance_;
  delete NtfCanTakeCountTradeCmd_reflection_;
  delete GiveTradeCmd::default_instance_;
  delete GiveTradeCmd_reflection_;
  delete AcceptTradeCmd::default_instance_;
  delete AcceptTradeCmd_reflection_;
  delete RefuseTradeCmd::default_instance_;
  delete RefuseTradeCmd_reflection_;
  delete GiveItemInfo::default_instance_;
  delete GiveItemInfo_reflection_;
  delete ReqGiveItemInfoCmd::default_instance_;
  delete ReqGiveItemInfoCmd_reflection_;
  delete CheckPackageSizeTradeCmd::default_instance_;
  delete CheckPackageSizeTradeCmd_reflection_;
  delete QucikTakeLogTradeCmd::default_instance_;
  delete QucikTakeLogTradeCmd_reflection_;
  delete ItemCount::default_instance_;
  delete ItemCount_reflection_;
  delete QueryItemCountTradeCmd::default_instance_;
  delete QueryItemCountTradeCmd_reflection_;
  delete LotteryGiveInfo::default_instance_;
  delete LotteryGiveInfo_reflection_;
  delete LotteryGiveCmd::default_instance_;
  delete LotteryGiveCmd_reflection_;
  delete TodayFinanceItem::default_instance_;
  delete TodayFinanceItem_reflection_;
  delete TodayFinanceRank::default_instance_;
  delete TodayFinanceRank_reflection_;
  delete TodayFinanceDetail::default_instance_;
  delete TodayFinanceDetail_reflection_;
  delete BoothPlayerPendingListCmd::default_instance_;
  delete BoothPlayerPendingListCmd_reflection_;
  delete UpdateOrderTradeCmd::default_instance_;
  delete UpdateOrderTradeCmd_reflection_;
}

void protobuf_AddDesc_RecordTrade_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::Cmd::protobuf_AddDesc_xCmd_2eproto();
  ::Cmd::protobuf_AddDesc_ProtoCommon_2eproto();
  ::Cmd::protobuf_AddDesc_SceneItem_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021RecordTrade.proto\022\003Cmd\032\nxCmd.proto\032\021Pr"
    "otoCommon.proto\032\017SceneItem.proto\"\264\001\n\nSea"
    "rchCond\022\017\n\007item_id\030\001 \001(\r\022\022\n\npage_index\030\007"
    " \001(\r\022\022\n\npage_count\030\010 \001(\r\0226\n\trank_type\030\t "
    "\001(\0162\r.Cmd.RankType:\024RANKTYPE_ITEM_ID_INC"
    "\0225\n\ntrade_type\030\n \001(\0162\017.Cmd.ETradeType:\020E"
    "TRADETYPE_TRADE\"\203\002\n\036BriefPendingListReco"
    "rdTradeCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032R"
    "ECORD_USER_TRADE_PROTOCMD\022H\n\005param\030\002 \001(\016"
    "2\031.Cmd.RecordUserTradeParam:\036BRIEF_PENDI"
    "NG_LIST_RECORDTRADE\022\016\n\006charid\030\003 \001(\004\022\020\n\010c"
    "ategory\030\004 \001(\r\022\013\n\003job\030\005 \001(\r\022\017\n\007fashion\030\006 "
    "\001(\r\022\021\n\tpub_lists\030\007 \003(\r\022\r\n\005lists\030\010 \003(\r\"\232\002"
    "\n\037DetailPendingListRecordTradeCmd\0225\n\003cmd"
    "\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_"
    "PROTOCMD\022I\n\005param\030\002 \001(\0162\031.Cmd.RecordUser"
    "TradeParam:\037DETAIL_PENDING_LIST_RECORDTR"
    "ADE\022$\n\013search_cond\030\003 \001(\0132\017.Cmd.SearchCon"
    "d\022\016\n\006charid\030\004 \001(\004\022%\n\005lists\030\005 \003(\0132\026.Cmd.T"
    "radeItemBaseInfo\022\030\n\020total_page_count\030\006 \001"
    "(\r\"*\n\014BriefBuyInfo\022\014\n\004name\030\001 \001(\t\022\014\n\004time"
    "\030\002 \001(\r\"\246\003\n\032ItemSellInfoRecordTradeCmd\0225\n"
    "\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TR"
    "ADE_PROTOCMD\022D\n\005param\030\002 \001(\0162\031.Cmd.Record"
    "UserTradeParam:\032ITEM_SELL_INFO_RECORDTRA"
    "DE\022\016\n\006charid\030\003 \001(\004\022\016\n\006itemid\030\004 \001(\r\022\021\n\tre"
    "fine_lv\030\005 \001(\r\022\024\n\014publicity_id\030\006 \001(\r\022!\n\ts"
    "tatetype\030\007 \001(\0162\016.Cmd.StateType\022\020\n\005count\030"
    "\010 \001(\r:\0010\022\026\n\013buyer_count\030\t \001(\r:\0010\022#\n\010buy_"
    "info\030\n \003(\0132\021.Cmd.BriefBuyInfo\022\020\n\010order_i"
    "d\030\013 \001(\004\022/\n\004type\030\014 \001(\0162\017.Cmd.ETradeType:\020"
    "ETRADETYPE_TRADE\022\r\n\005quota\030\r \001(\004\"\370\001\n\033MyPe"
    "ndingListRecordTradeCmd\0225\n\003cmd\030\001 \001(\0162\014.C"
    "md.Command:\032RECORD_USER_TRADE_PROTOCMD\022E"
    "\n\005param\030\002 \001(\0162\031.Cmd.RecordUserTradeParam"
    ":\033MY_PENDING_LIST_RECORDTRADE\022$\n\013search_"
    "cond\030\003 \001(\0132\017.Cmd.SearchCond\022\016\n\006charid\030\004 "
    "\001(\004\022%\n\005lists\030\006 \003(\0132\026.Cmd.TradeItemBaseIn"
    "fo\"7\n\010NameInfo\022\014\n\004name\030\001 \001(\t\022\016\n\006zoneid\030\002"
    " \001(\r\022\r\n\005count\030\003 \001(\r\"1\n\014NameInfoList\022!\n\nn"
    "ame_infos\030\001 \003(\0132\r.Cmd.NameInfo\"\272\005\n\013LogIt"
    "emInfo\022\n\n\002id\030\001 \001(\004\022 \n\006status\030\002 \001(\0162\020.Cmd"
    ".ETakeStatus\022\037\n\007logtype\030\003 \001(\0162\016.Cmd.EOpe"
    "rType\022\016\n\006itemid\030\004 \001(\r\022\021\n\trefine_lv\030\005 \001(\r"
    "\022\016\n\006damage\030\006 \001(\010\022\021\n\ttradetime\030\007 \001(\r\022\r\n\005c"
    "ount\030\010 \001(\r\022\r\n\005price\030\024 \001(\r\022\013\n\003tax\030\t \001(\r\022\020"
    "\n\010getmoney\030\n \001(\r\022\021\n\tcostmoney\030\013 \001(\r\022\021\n\tf"
    "ailcount\030\014 \001(\r\022\020\n\010retmoney\030\r \001(\r\022\022\n\ntota"
    "lcount\030\016 \001(\r\022\017\n\007endtime\030\017 \001(\r\022 \n\tname_in"
    "fo\030\020 \001(\0132\r.Cmd.NameInfo\022\026\n\016is_many_peopl"
    "e\030\021 \001(\010\022$\n\tname_list\030\022 \001(\0132\021.Cmd.NameInf"
    "oList\022\037\n\010itemdata\030\023 \001(\0132\r.Cmd.ItemData\022\022"
    "\n\nreceiverid\030\025 \001(\004\022\024\n\014receivername\030\026 \001(\t"
    "\022\026\n\016receiverzoneid\030\027 \001(\r\022\r\n\005quota\030\030 \001(\004\022"
    "\022\n\nbackground\030\031 \001(\r\022\022\n\nexpiretime\030\032 \001(\r\022"
    "\020\n\010ret_cost\030\033 \001(\r\022\017\n\007cangive\030\034 \001(\010\0225\n\ntr"
    "ade_type\030\035 \001(\0162\017.Cmd.ETradeType:\020ETRADET"
    "YPE_TRADE\022\021\n\tis_public\030\036 \001(\010\022\025\n\nquota_co"
    "st\030\037 \001(\004:\0010\"\256\002\n\030MyTradeLogRecordTradeCmd"
    "\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER"
    "_TRADE_PROTOCMD\022G\n\005param\030\002 \001(\0162\031.Cmd.Rec"
    "ordUserTradeParam:\035MY_TRADE_LOG_LIST_REC"
    "ORDTRADE\022\016\n\006charid\030\003 \001(\004\022\r\n\005index\030\004 \001(\r\022"
    "\030\n\020total_page_count\030\005 \001(\r\022\"\n\010log_list\030\006 "
    "\003(\0132\020.Cmd.LogItemInfo\0225\n\ntrade_type\030\007 \001("
    "\0162\017.Cmd.ETradeType:\020ETRADETYPE_TRADE\"\263\001\n"
    "\nTakeLogCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032"
    "RECORD_USER_TRADE_PROTOCMD\022>\n\005param\030\002 \001("
    "\0162\031.Cmd.RecordUserTradeParam:\024TAKE_LOG_T"
    "RADE_PARAM\022\035\n\003log\030\003 \001(\0132\020.Cmd.LogItemInf"
    "o\022\017\n\007success\030\004 \001(\010\"\315\001\n\tAddNewLog\0225\n\003cmd\030"
    "\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_P"
    "ROTOCMD\022@\n\005param\030\002 \001(\0162\031.Cmd.RecordUserT"
    "radeParam:\026ADD_NEWLOG_TRADE_PARAM\022\016\n\006cha"
    "rid\030\003 \001(\004\022\035\n\003log\030\004 \001(\0132\020.Cmd.LogItemInfo"
    "\022\030\n\020total_page_count\030\005 \001(\r\"\210\002\n\020FetchName"
    "InfoCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECO"
    "RD_USER_TRADE_PROTOCMD\022D\n\005param\030\002 \001(\0162\031."
    "Cmd.RecordUserTradeParam:\032FETCH_NAMEINFO"
    "_TRADE_PARAM\022\n\n\002id\030\003 \001(\004\022\034\n\004type\030\004 \001(\0162\016"
    ".Cmd.EOperType\022\r\n\005index\030\005 \001(\r\022\030\n\020total_p"
    "age_count\030\006 \001(\r\022$\n\tname_list\030\007 \001(\0132\021.Cmd"
    ".NameInfoList\"\215\003\n\034ReqServerPriceRecordTr"
    "adeCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECOR"
    "D_USER_TRADE_PROTOCMD\022F\n\005param\030\002 \001(\0162\031.C"
    "md.RecordUserTradeParam:\034REQ_SERVER_PRIC"
    "E_RECORDTRADE\022\016\n\006charid\030\003 \001(\004\022\037\n\010itemDat"
    "a\030\004 \001(\0132\r.Cmd.ItemData\022\r\n\005price\030\005 \001(\r\022\025\n"
    "\006issell\030\006 \001(\010:\005false\022!\n\tstatetype\030\007 \001(\0162"
    "\016.Cmd.StateType\022\020\n\005count\030\010 \001(\r:\0010\022\026\n\013buy"
    "er_count\030\t \001(\r:\0010\022\023\n\010end_time\030\n \001(\r:\0010\0225"
    "\n\ntrade_type\030\013 \001(\0162\017.Cmd.ETradeType:\020ETR"
    "ADETYPE_TRADE\"\235\002\n\025BuyItemRecordTradeCmd\022"
    "5\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_"
    "TRADE_PROTOCMD\022>\n\005param\030\002 \001(\0162\031.Cmd.Reco"
    "rdUserTradeParam:\024BUY_ITEM_RECORDTRADE\022)"
    "\n\titem_info\030\003 \001(\0132\026.Cmd.TradeItemBaseInf"
    "o\022\016\n\006charid\030\004 \001(\004\022!\n\003ret\030\005 \001(\0162\024.Cmd.ETR"
    "ADE_RET_CODE\022/\n\004type\030\006 \001(\0162\017.Cmd.ETradeT"
    "ype:\020ETRADETYPE_TRADE\"\237\002\n\026SellItemRecord"
    "TradeCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032REC"
    "ORD_USER_TRADE_PROTOCMD\022\?\n\005param\030\002 \001(\0162\031"
    ".Cmd.RecordUserTradeParam:\025SELL_ITEM_REC"
    "ORDTRADE\022)\n\titem_info\030\003 \001(\0132\026.Cmd.TradeI"
    "temBaseInfo\022\016\n\006charid\030\004 \001(\004\022!\n\003ret\030\005 \001(\016"
    "2\024.Cmd.ETRADE_RET_CODE\022/\n\004type\030\006 \001(\0162\017.C"
    "md.ETradeType:\020ETRADETYPE_TRADE\"\304\002\n\025Canc"
    "elItemRecordTrade\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Com"
    "mand:\032RECORD_USER_TRADE_PROTOCMD\022D\n\005para"
    "m\030\002 \001(\0162\031.Cmd.RecordUserTradeParam:\032CANC"
    "EL_PENDING_RECORDTRADE\022)\n\titem_info\030\003 \001("
    "\0132\026.Cmd.TradeItemBaseInfo\022\016\n\006charid\030\004 \001("
    "\004\022!\n\003ret\030\005 \001(\0162\024.Cmd.ETRADE_RET_CODE\022\020\n\010"
    "order_id\030\006 \001(\004\022/\n\004type\030\007 \001(\0162\017.Cmd.ETrad"
    "eType:\020ETRADETYPE_TRADE\022\r\n\005quota\030\010 \001(\004\"\307"
    "\002\n\030ResellPendingRecordTrade\0225\n\003cmd\030\001 \001(\016"
    "2\014.Cmd.Command:\032RECORD_USER_TRADE_PROTOC"
    "MD\022D\n\005param\030\002 \001(\0162\031.Cmd.RecordUserTradeP"
    "aram:\032RESELL_PENDING_RECORDTRADE\022)\n\titem"
    "_info\030\003 \001(\0132\026.Cmd.TradeItemBaseInfo\022\016\n\006c"
    "harid\030\004 \001(\004\022!\n\003ret\030\005 \001(\0162\024.Cmd.ETRADE_RE"
    "T_CODE\022\020\n\010order_id\030\006 \001(\004\022/\n\004type\030\007 \001(\0162\017"
    ".Cmd.ETradeType:\020ETRADETYPE_TRADE\022\r\n\005quo"
    "ta\030\010 \001(\004\"\360\001\n\020PanelRecordTrade\0225\n\003cmd\030\001 \001"
    "(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_PROT"
    "OCMD\022;\n\005param\030\002 \001(\0162\031.Cmd.RecordUserTrad"
    "eParam:\021PANEL_RECORDTRADE\022\016\n\006charid\030\003 \001("
    "\004\022!\n\004oper\030\004 \001(\0162\023.Cmd.EPanelOperType\0225\n\n"
    "trade_type\030\005 \001(\0162\017.Cmd.ETradeType:\020ETRAD"
    "ETYPE_TRADE\"\363\001\n\022ListNtfRecordTrade\0225\n\003cm"
    "d\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE"
    "_PROTOCMD\022>\n\005param\030\002 \001(\0162\031.Cmd.RecordUse"
    "rTradeParam:\024LIST_NTF_RECORDTRADE\022\016\n\006cha"
    "rid\030\003 \001(\004\022\037\n\004type\030\004 \001(\0162\021.Cmd.EListNtfTy"
    "pe\0225\n\ntrade_type\030\005 \001(\0162\017.Cmd.ETradeType:"
    "\020ETRADETYPE_TRADE\"\316\001\n\024HotItemidRecordTra"
    "de\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_US"
    "ER_TRADE_PROTOCMD\022@\n\005param\030\002 \001(\0162\031.Cmd.R"
    "ecordUserTradeParam:\026HOT_ITEMID_RECORDTR"
    "ADE\022\016\n\006charid\030\003 \001(\004\022\013\n\003job\030\004 \001(\r\022\021\n\tpub_"
    "lists\030\005 \003(\r\022\r\n\005lists\030\006 \003(\r\"\340\001\n\027NtfCanTak"
    "eCountTradeCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Comman"
    "d:\032RECORD_USER_TRADE_PROTOCMD\022H\n\005param\030\002"
    " \001(\0162\031.Cmd.RecordUserTradeParam:\036NTF_CAN"
    "_TAKE_COUNT_TRADE_PARAM\022\r\n\005count\030\003 \001(\r\0225"
    "\n\ntrade_type\030\004 \001(\0162\017.Cmd.ETradeType:\020ETR"
    "ADETYPE_TRADE\"\211\002\n\014GiveTradeCmd\0225\n\003cmd\030\001 "
    "\001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_PRO"
    "TOCMD\022:\n\005param\030\002 \001(\0162\031.Cmd.RecordUserTra"
    "deParam:\020GIVE_TRADE_PARAM\022\n\n\002id\030\003 \001(\004\022\037\n"
    "\007logtype\030\004 \001(\0162\016.Cmd.EOperType\022\020\n\010friend"
    "id\030\005 \001(\004\022\017\n\007content\030\006 \001(\t\022\021\n\tanonymous\030\007"
    " \001(\010\022\022\n\nbackground\030\010 \001(\r\022\017\n\007success\030\t \001("
    "\010\"\242\001\n\016AcceptTradeCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd."
    "Command:\032RECORD_USER_TRADE_PROTOCMD\022<\n\005p"
    "aram\030\002 \001(\0162\031.Cmd.RecordUserTradeParam:\022A"
    "CCEPT_TRADE_PARAM\022\n\n\002id\030\003 \001(\004\022\017\n\007success"
    "\030\004 \001(\010\"\242\001\n\016RefuseTradeCmd\0225\n\003cmd\030\001 \001(\0162\014"
    ".Cmd.Command:\032RECORD_USER_TRADE_PROTOCMD"
    "\022<\n\005param\030\002 \001(\0162\031.Cmd.RecordUserTradePar"
    "am:\022REFUSE_TRADE_PARAM\022\n\n\002id\030\003 \001(\004\022\017\n\007su"
    "ccess\030\004 \001(\010\"\223\002\n\014GiveItemInfo\022\n\n\002id\030\001 \001(\004"
    "\022 \n\006status\030\002 \001(\0162\020.Cmd.ETakeStatus\022\016\n\006it"
    "emid\030\003 \001(\r\022\r\n\005count\030\004 \001(\r\022\037\n\010itemdata\030\005 "
    "\001(\0132\r.Cmd.ItemData\022\020\n\010senderid\030\006 \001(\004\022\022\n\n"
    "sendername\030\007 \001(\t\022\021\n\tanonymous\030\010 \001(\010\022\022\n\ne"
    "xpiretime\030\t \001(\r\022\017\n\007content\030\n \001(\t\022\r\n\005quot"
    "a\030\013 \001(\004\022\024\n\014receivername\030\014 \001(\t\022\022\n\nbackgro"
    "und\030\r \001(\r\"\306\001\n\022ReqGiveItemInfoCmd\0225\n\003cmd\030"
    "\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_P"
    "ROTOCMD\022H\n\005param\030\002 \001(\0162\031.Cmd.RecordUserT"
    "radeParam:\036REQ_GIVE_ITEM_INFO_TRADE_PARA"
    "M\022\n\n\002id\030\003 \001(\004\022#\n\010iteminfo\030\004 \001(\0132\021.Cmd.Gi"
    "veItemInfo\"\304\001\n\030CheckPackageSizeTradeCmd\022"
    "5\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_"
    "TRADE_PROTOCMD\022F\n\005param\030\002 \001(\0162\031.Cmd.Reco"
    "rdUserTradeParam:\034CHECK_PACKAGE_SIZE_TRA"
    "DE_CMD\022\034\n\005items\030\003 \003(\0132\r.Cmd.ItemInfo\022\013\n\003"
    "ret\030\004 \001(\010\"\312\001\n\024QucikTakeLogTradeCmd\0225\n\003cm"
    "d\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE"
    "_PROTOCMD\022D\n\005param\030\002 \001(\0162\031.Cmd.RecordUse"
    "rTradeParam:\032QUICK_TAKE_LOG_TRADE_PARAM\022"
    "5\n\ntrade_type\030\003 \001(\0162\017.Cmd.ETradeType:\020ET"
    "RADETYPE_TRADE\"*\n\tItemCount\022\016\n\006itemid\030\001 "
    "\001(\r\022\r\n\005count\030\002 \001(\r\"\361\001\n\026QueryItemCountTra"
    "deCmd\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD"
    "_USER_TRADE_PROTOCMD\022F\n\005param\030\002 \001(\0162\031.Cm"
    "d.RecordUserTradeParam:\034QUERY_ITEM_COUNT"
    "_TRADE_PARAM\022\016\n\006charid\030\003 \001(\004\022\035\n\005items\030\004 "
    "\003(\0132\016.Cmd.ItemCount\022)\n\tres_items\030\005 \003(\0132\026"
    ".Cmd.TradeItemBaseInfo\"t\n\017LotteryGiveInf"
    "o\022\014\n\004year\030\001 \001(\r\022\r\n\005month\030\002 \001(\r\022\r\n\005count\030"
    "\003 \001(\r\022\017\n\007content\030\004 \001(\t\022\020\n\010configid\030\005 \001(\r"
    "\022\022\n\nreceiverid\030\006 \001(\004\"\271\001\n\016LotteryGiveCmd\022"
    "5\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_"
    "TRADE_PROTOCMD\022H\n\005param\030\002 \001(\0162\031.Cmd.Reco"
    "rdUserTradeParam:\036QUERY_LOTTERY_GIVE_TRA"
    "DE_PARAM\022&\n\010iteminfo\030\003 \001(\0132\024.Cmd.Lottery"
    "GiveInfo\"@\n\020TodayFinanceItem\022\017\n\007item_id\030"
    "\001 \001(\r\022\r\n\005ratio\030\002 \001(\r\022\014\n\004time\030\003 \001(\r\"\267\002\n\020T"
    "odayFinanceRank\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Comma"
    "nd:\032RECORD_USER_TRADE_PROTOCMD\022D\n\005param\030"
    "\002 \001(\0162\031.Cmd.RecordUserTradeParam:\032QUERY_"
    "SERVANT_FINANCE_RANK\022A\n\trank_type\030\003 \001(\0162"
    "\025.Cmd.EFinanceRankType:\027EFINANCE_RANK_DE"
    "ALCOUNT\022=\n\tdate_type\030\004 \001(\0162\025.Cmd.EFinanc"
    "eDateType:\023EFINANCE_DATE_THREE\022$\n\005lists\030"
    "\005 \003(\0132\025.Cmd.TodayFinanceItem\"\314\002\n\022TodayFi"
    "nanceDetail\0225\n\003cmd\030\001 \001(\0162\014.Cmd.Command:\032"
    "RECORD_USER_TRADE_PROTOCMD\022F\n\005param\030\002 \001("
    "\0162\031.Cmd.RecordUserTradeParam:\034QUERY_SERV"
    "ANT_FINANCE_DETAIL\022\017\n\007item_id\030\003 \001(\r\022A\n\tr"
    "ank_type\030\004 \001(\0162\025.Cmd.EFinanceRankType:\027E"
    "FINANCE_RANK_DEALCOUNT\022=\n\tdate_type\030\005 \001("
    "\0162\025.Cmd.EFinanceDateType:\023EFINANCE_DATE_"
    "THREE\022$\n\005lists\030\006 \003(\0132\025.Cmd.TodayFinanceI"
    "tem\"\316\001\n\031BoothPlayerPendingListCmd\0225\n\003cmd"
    "\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRADE_"
    "PROTOCMD\022C\n\005param\030\002 \001(\0162\031.Cmd.RecordUser"
    "TradeParam:\031BOOTH_PLAYER_PENDING_LIST\022\016\n"
    "\006charid\030\003 \001(\004\022%\n\005lists\030\004 \003(\0132\026.Cmd.Trade"
    "ItemBaseInfo\"\367\001\n\023UpdateOrderTradeCmd\0225\n\003"
    "cmd\030\001 \001(\0162\014.Cmd.Command:\032RECORD_USER_TRA"
    "DE_PROTOCMD\022B\n\005param\030\002 \001(\0162\031.Cmd.RecordU"
    "serTradeParam:\030UPDATE_ORDER_TRADE_PARAM\022"
    "\016\n\006charid\030\003 \001(\004\022$\n\004info\030\004 \001(\0132\026.Cmd.Trad"
    "eItemBaseInfo\022/\n\004type\030\005 \001(\0162\017.Cmd.ETrade"
    "Type:\020ETRADETYPE_TRADE*\222\007\n\024RecordUserTra"
    "deParam\022\"\n\036BRIEF_PENDING_LIST_RECORDTRAD"
    "E\020\001\022#\n\037DETAIL_PENDING_LIST_RECORDTRADE\020\003"
    "\022\036\n\032ITEM_SELL_INFO_RECORDTRADE\020\004\022\037\n\033MY_P"
    "ENDING_LIST_RECORDTRADE\020\007\022!\n\035MY_TRADE_LO"
    "G_LIST_RECORDTRADE\020\t\022 \n\034REQ_SERVER_PRICE"
    "_RECORDTRADE\020\016\022\030\n\024BUY_ITEM_RECORDTRADE\020\017"
    "\022\031\n\025SELL_ITEM_RECORDTRADE\020\024\022\036\n\032CANCEL_PE"
    "NDING_RECORDTRADE\020\026\022\036\n\032RESELL_PENDING_RE"
    "CORDTRADE\020\027\022\025\n\021PANEL_RECORDTRADE\020\030\022\030\n\024LI"
    "ST_NTF_RECORDTRADE\020\031\022\032\n\026HOT_ITEMID_RECOR"
    "DTRADE\020\032\022\030\n\024TAKE_LOG_TRADE_PARAM\020\033\022\032\n\026AD"
    "D_NEWLOG_TRADE_PARAM\020\034\022\036\n\032FETCH_NAMEINFO"
    "_TRADE_PARAM\020\035\022\"\n\036NTF_CAN_TAKE_COUNT_TRA"
    "DE_PARAM\020\036\022\024\n\020GIVE_TRADE_PARAM\020\037\022\"\n\036REQ_"
    "GIVE_ITEM_INFO_TRADE_PARAM\020 \022\026\n\022ACCEPT_T"
    "RADE_PARAM\020!\022\026\n\022REFUSE_TRADE_PARAM\020\"\022 \n\034"
    "CHECK_PACKAGE_SIZE_TRADE_CMD\020#\022\036\n\032QUICK_"
    "TAKE_LOG_TRADE_PARAM\020$\022 \n\034QUERY_ITEM_COU"
    "NT_TRADE_PARAM\020%\022\"\n\036QUERY_LOTTERY_GIVE_T"
    "RADE_PARAM\020&\022\036\n\032QUERY_SERVANT_FINANCE_RA"
    "NK\020\'\022 \n\034QUERY_SERVANT_FINANCE_DETAIL\020(\022\035"
    "\n\031BOOTH_PLAYER_PENDING_LIST\020)\022\034\n\030UPDATE_"
    "ORDER_TRADE_PARAM\020**\356\001\n\010RankType\022\030\n\024RANK"
    "TYPE_ITEM_ID_INC\020\001\022\030\n\024RANKTYPE_ITEM_ID_D"
    "ES\020\002\022\032\n\026RANKTYPE_REFINE_LV_INC\020\003\022\032\n\026RANK"
    "TYPE_REFINE_LV_DES\020\004\022\033\n\027RANKTYPE_ITEM_PR"
    "ICE_INC\020\005\022\033\n\027RANKTYPE_ITEM_PRICE_DES\020\006\022\035"
    "\n\031RANKTYPE_PENDING_TIME_INC\020\007\022\035\n\031RANKTYP"
    "E_PENDING_TIME_DES\020\010*\350\002\n\tEOperType\022\030\n\024EO"
    "perType_PayPending\020\000\022\030\n\024EOperType_Normal"
    "Sell\020\001\022\027\n\023EOperType_NoramlBuy\020\002\022\027\n\023EOper"
    "Type_Publicity\020\003\022\"\n\036EOperType_PublicityS"
    "ellSuccess\020\004\022\037\n\033EOperType_PublicitySellF"
    "ail\020\005\022!\n\035EOperType_PublicityBuySuccess\020\006"
    "\022\036\n\032EOperType_PublicityBuyFail\020\007\022\035\n\031EOpe"
    "rType_PublicityBuying\020\010\022\035\n\031EOperType_Aut"
    "oOffTheShelf\020\t\022\025\n\021EOperType_PayFail\020\n\022\030\n"
    "\024EOperType_PayTimeout\020\013*\322\001\n\013ETakeStatus\022"
    "\033\n\027ETakeStatus_CanTakeGive\020\000\022\024\n\020ETakeSta"
    "tus_Took\020\001\022\026\n\022ETakeStatus_Taking\020\002\022\026\n\022ET"
    "akeStatus_Giving\020\003\022\036\n\032ETakeStatus_Give_A"
    "ccepting\020\004\022\037\n\033ETakeStatus_Give_Accepted_"
    "1\020\005\022\037\n\033ETakeStatus_Give_Accepted_2\020\006*d\n\t"
    "StateType\022\024\n\020St_OverlapNormal\020\001\022\027\n\023St_No"
    "noverlapNormal\020\002\022\024\n\020St_WillPublicity\020\003\022\022"
    "\n\016St_InPublicity\020\004*3\n\016EPanelOperType\022\017\n\013"
    "EPANEL_OPEN\020\001\022\020\n\014EPANEL_CLOSE\020\002*>\n\014EList"
    "NtfType\022\030\n\024ELIST_NTF_MY_PENDING\020\001\022\024\n\020ELI"
    "ST_NTF_MY_LOG\020\002*D\n\020EFinanceDateType\022\027\n\023E"
    "FINANCE_DATE_THREE\020\001\022\027\n\023EFINANCE_DATE_SE"
    "VEN\020\002*g\n\020EFinanceRankType\022\033\n\027EFINANCE_RA"
    "NK_DEALCOUNT\020\001\022\031\n\025EFINANCE_RANK_UPRATIO\020"
    "\002\022\033\n\027EFINANCE_RANK_DOWNRATIO\020\003", 11230);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "RecordTrade.proto", &protobuf_RegisterTypes);
  SearchCond::default_instance_ = new SearchCond();
  BriefPendingListRecordTradeCmd::default_instance_ = new BriefPendingListRecordTradeCmd();
  DetailPendingListRecordTradeCmd::default_instance_ = new DetailPendingListRecordTradeCmd();
  BriefBuyInfo::default_instance_ = new BriefBuyInfo();
  ItemSellInfoRecordTradeCmd::default_instance_ = new ItemSellInfoRecordTradeCmd();
  MyPendingListRecordTradeCmd::default_instance_ = new MyPendingListRecordTradeCmd();
  NameInfo::default_instance_ = new NameInfo();
  NameInfoList::default_instance_ = new NameInfoList();
  LogItemInfo::default_instance_ = new LogItemInfo();
  MyTradeLogRecordTradeCmd::default_instance_ = new MyTradeLogRecordTradeCmd();
  TakeLogCmd::default_instance_ = new TakeLogCmd();
  AddNewLog::default_instance_ = new AddNewLog();
  FetchNameInfoCmd::default_instance_ = new FetchNameInfoCmd();
  ReqServerPriceRecordTradeCmd::default_instance_ = new ReqServerPriceRecordTradeCmd();
  BuyItemRecordTradeCmd::default_instance_ = new BuyItemRecordTradeCmd();
  SellItemRecordTradeCmd::default_instance_ = new SellItemRecordTradeCmd();
  CancelItemRecordTrade::default_instance_ = new CancelItemRecordTrade();
  ResellPendingRecordTrade::default_instance_ = new ResellPendingRecordTrade();
  PanelRecordTrade::default_instance_ = new PanelRecordTrade();
  ListNtfRecordTrade::default_instance_ = new ListNtfRecordTrade();
  HotItemidRecordTrade::default_instance_ = new HotItemidRecordTrade();
  NtfCanTakeCountTradeCmd::default_instance_ = new NtfCanTakeCountTradeCmd();
  GiveTradeCmd::default_instance_ = new GiveTradeCmd();
  AcceptTradeCmd::default_instance_ = new AcceptTradeCmd();
  RefuseTradeCmd::default_instance_ = new RefuseTradeCmd();
  GiveItemInfo::default_instance_ = new GiveItemInfo();
  ReqGiveItemInfoCmd::default_instance_ = new ReqGiveItemInfoCmd();
  CheckPackageSizeTradeCmd::default_instance_ = new CheckPackageSizeTradeCmd();
  QucikTakeLogTradeCmd::default_instance_ = new QucikTakeLogTradeCmd();
  ItemCount::default_instance_ = new ItemCount();
  QueryItemCountTradeCmd::default_instance_ = new QueryItemCountTradeCmd();
  LotteryGiveInfo::default_instance_ = new LotteryGiveInfo();
  LotteryGiveCmd::default_instance_ = new LotteryGiveCmd();
  TodayFinanceItem::default_instance_ = new TodayFinanceItem();
  TodayFinanceRank::default_instance_ = new TodayFinanceRank();
  TodayFinanceDetail::default_instance_ = new TodayFinanceDetail();
  BoothPlayerPendingListCmd::default_instance_ = new BoothPlayerPendingListCmd();
  UpdateOrderTradeCmd::default_instance_ = new UpdateOrderTradeCmd();
  SearchCond::default_instance_->InitAsDefaultInstance();
  BriefPendingListRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  DetailPendingListRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  BriefBuyInfo::default_instance_->InitAsDefaultInstance();
  ItemSellInfoRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  MyPendingListRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  NameInfo::default_instance_->InitAsDefaultInstance();
  NameInfoList::default_instance_->InitAsDefaultInstance();
  LogItemInfo::default_instance_->InitAsDefaultInstance();
  MyTradeLogRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  TakeLogCmd::default_instance_->InitAsDefaultInstance();
  AddNewLog::default_instance_->InitAsDefaultInstance();
  FetchNameInfoCmd::default_instance_->InitAsDefaultInstance();
  ReqServerPriceRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  BuyItemRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  SellItemRecordTradeCmd::default_instance_->InitAsDefaultInstance();
  CancelItemRecordTrade::default_instance_->InitAsDefaultInstance();
  ResellPendingRecordTrade::default_instance_->InitAsDefaultInstance();
  PanelRecordTrade::default_instance_->InitAsDefaultInstance();
  ListNtfRecordTrade::default_instance_->InitAsDefaultInstance();
  HotItemidRecordTrade::default_instance_->InitAsDefaultInstance();
  NtfCanTakeCountTradeCmd::default_instance_->InitAsDefaultInstance();
  GiveTradeCmd::default_instance_->InitAsDefaultInstance();
  AcceptTradeCmd::default_instance_->InitAsDefaultInstance();
  RefuseTradeCmd::default_instance_->InitAsDefaultInstance();
  GiveItemInfo::default_instance_->InitAsDefaultInstance();
  ReqGiveItemInfoCmd::default_instance_->InitAsDefaultInstance();
  CheckPackageSizeTradeCmd::default_instance_->InitAsDefaultInstance();
  QucikTakeLogTradeCmd::default_instance_->InitAsDefaultInstance();
  ItemCount::default_instance_->InitAsDefaultInstance();
  QueryItemCountTradeCmd::default_instance_->InitAsDefaultInstance();
  LotteryGiveInfo::default_instance_->InitAsDefaultInstance();
  LotteryGiveCmd::default_instance_->InitAsDefaultInstance();
  TodayFinanceItem::default_instance_->InitAsDefaultInstance();
  TodayFinanceRank::default_instance_->InitAsDefaultInstance();
  TodayFinanceDetail::default_instance_->InitAsDefaultInstance();
  BoothPlayerPendingListCmd::default_instance_->InitAsDefaultInstance();
  UpdateOrderTradeCmd::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_RecordTrade_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_RecordTrade_2eproto {
  StaticDescriptorInitializer_RecordTrade_2eproto() {
    protobuf_AddDesc_RecordTrade_2eproto();
  }
} static_descriptor_initializer_RecordTrade_2eproto_;
const ::google::protobuf::EnumDescriptor* RecordUserTradeParam_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecordUserTradeParam_descriptor_;
}
bool RecordUserTradeParam_IsValid(int value) {
  switch(value) {
    case 1:
    case 3:
    case 4:
    case 7:
    case 9:
    case 14:
    case 15:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RankType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RankType_descriptor_;
}
bool RankType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EOperType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EOperType_descriptor_;
}
bool EOperType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ETakeStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ETakeStatus_descriptor_;
}
bool ETakeStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StateType_descriptor_;
}
bool StateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EPanelOperType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EPanelOperType_descriptor_;
}
bool EPanelOperType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EListNtfType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EListNtfType_descriptor_;
}
bool EListNtfType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EFinanceDateType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EFinanceDateType_descriptor_;
}
bool EFinanceDateType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EFinanceRankType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EFinanceRankType_descriptor_;
}
bool EFinanceRankType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int SearchCond::kItemIdFieldNumber;
const int SearchCond::kPageIndexFieldNumber;
const int SearchCond::kPageCountFieldNumber;
const int SearchCond::kRankTypeFieldNumber;
const int SearchCond::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

SearchCond::SearchCond()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.SearchCond)
}

void SearchCond::InitAsDefaultInstance() {
}

SearchCond::SearchCond(const SearchCond& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.SearchCond)
}

void SearchCond::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  page_index_ = 0u;
  page_count_ = 0u;
  rank_type_ = 1;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SearchCond::~SearchCond() {
  // @@protoc_insertion_point(destructor:Cmd.SearchCond)
  SharedDtor();
}

void SearchCond::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SearchCond::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SearchCond::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SearchCond_descriptor_;
}

const SearchCond& SearchCond::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

SearchCond* SearchCond::default_instance_ = NULL;

SearchCond* SearchCond::New() const {
  return new SearchCond;
}

void SearchCond::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SearchCond*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(item_id_, page_count_);
    rank_type_ = 1;
    trade_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SearchCond::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.SearchCond)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 item_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_page_index;
        break;
      }

      // optional uint32 page_index = 7;
      case 7: {
        if (tag == 56) {
         parse_page_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_index_)));
          set_has_page_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_page_count;
        break;
      }

      // optional uint32 page_count = 8;
      case 8: {
        if (tag == 64) {
         parse_page_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_count_)));
          set_has_page_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_rank_type;
        break;
      }

      // optional .Cmd.RankType rank_type = 9 [default = RANKTYPE_ITEM_ID_INC];
      case 9: {
        if (tag == 72) {
         parse_rank_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RankType_IsValid(value)) {
            set_rank_type(static_cast< ::Cmd::RankType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 10 [default = ETRADETYPE_TRADE];
      case 10: {
        if (tag == 80) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.SearchCond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.SearchCond)
  return false;
#undef DO_
}

void SearchCond::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.SearchCond)
  // optional uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

  // optional uint32 page_index = 7;
  if (has_page_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->page_index(), output);
  }

  // optional uint32 page_count = 8;
  if (has_page_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->page_count(), output);
  }

  // optional .Cmd.RankType rank_type = 9 [default = RANKTYPE_ITEM_ID_INC];
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->rank_type(), output);
  }

  // optional .Cmd.ETradeType trade_type = 10 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.SearchCond)
}

::google::protobuf::uint8* SearchCond::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.SearchCond)
  // optional uint32 item_id = 1;
  if (has_item_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->item_id(), target);
  }

  // optional uint32 page_index = 7;
  if (has_page_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->page_index(), target);
  }

  // optional uint32 page_count = 8;
  if (has_page_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->page_count(), target);
  }

  // optional .Cmd.RankType rank_type = 9 [default = RANKTYPE_ITEM_ID_INC];
  if (has_rank_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->rank_type(), target);
  }

  // optional .Cmd.ETradeType trade_type = 10 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.SearchCond)
  return target;
}

int SearchCond::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // optional uint32 page_index = 7;
    if (has_page_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page_index());
    }

    // optional uint32 page_count = 8;
    if (has_page_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page_count());
    }

    // optional .Cmd.RankType rank_type = 9 [default = RANKTYPE_ITEM_ID_INC];
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rank_type());
    }

    // optional .Cmd.ETradeType trade_type = 10 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SearchCond::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SearchCond* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SearchCond*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SearchCond::MergeFrom(const SearchCond& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_page_index()) {
      set_page_index(from.page_index());
    }
    if (from.has_page_count()) {
      set_page_count(from.page_count());
    }
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SearchCond::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SearchCond::CopyFrom(const SearchCond& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SearchCond::IsInitialized() const {

  return true;
}

void SearchCond::Swap(SearchCond* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(page_index_, other->page_index_);
    std::swap(page_count_, other->page_count_);
    std::swap(rank_type_, other->rank_type_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SearchCond::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SearchCond_descriptor_;
  metadata.reflection = SearchCond_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BriefPendingListRecordTradeCmd::kCmdFieldNumber;
const int BriefPendingListRecordTradeCmd::kParamFieldNumber;
const int BriefPendingListRecordTradeCmd::kCharidFieldNumber;
const int BriefPendingListRecordTradeCmd::kCategoryFieldNumber;
const int BriefPendingListRecordTradeCmd::kJobFieldNumber;
const int BriefPendingListRecordTradeCmd::kFashionFieldNumber;
const int BriefPendingListRecordTradeCmd::kPubListsFieldNumber;
const int BriefPendingListRecordTradeCmd::kListsFieldNumber;
#endif  // !_MSC_VER

BriefPendingListRecordTradeCmd::BriefPendingListRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.BriefPendingListRecordTradeCmd)
}

void BriefPendingListRecordTradeCmd::InitAsDefaultInstance() {
}

BriefPendingListRecordTradeCmd::BriefPendingListRecordTradeCmd(const BriefPendingListRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.BriefPendingListRecordTradeCmd)
}

void BriefPendingListRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 1;
  charid_ = GOOGLE_ULONGLONG(0);
  category_ = 0u;
  job_ = 0u;
  fashion_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BriefPendingListRecordTradeCmd::~BriefPendingListRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.BriefPendingListRecordTradeCmd)
  SharedDtor();
}

void BriefPendingListRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BriefPendingListRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BriefPendingListRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BriefPendingListRecordTradeCmd_descriptor_;
}

const BriefPendingListRecordTradeCmd& BriefPendingListRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

BriefPendingListRecordTradeCmd* BriefPendingListRecordTradeCmd::default_instance_ = NULL;

BriefPendingListRecordTradeCmd* BriefPendingListRecordTradeCmd::New() const {
  return new BriefPendingListRecordTradeCmd;
}

void BriefPendingListRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BriefPendingListRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(charid_, job_);
    cmd_ = 57;
    param_ = 1;
    fashion_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  pub_lists_.Clear();
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BriefPendingListRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.BriefPendingListRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = BRIEF_PENDING_LIST_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_category;
        break;
      }

      // optional uint32 category = 4;
      case 4: {
        if (tag == 32) {
         parse_category:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &category_)));
          set_has_category();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_job;
        break;
      }

      // optional uint32 job = 5;
      case 5: {
        if (tag == 40) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_fashion;
        break;
      }

      // optional uint32 fashion = 6;
      case 6: {
        if (tag == 48) {
         parse_fashion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fashion_)));
          set_has_fashion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_pub_lists;
        break;
      }

      // repeated uint32 pub_lists = 7;
      case 7: {
        if (tag == 56) {
         parse_pub_lists:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 56, input, this->mutable_pub_lists())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_pub_lists())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_pub_lists;
        if (input->ExpectTag(64)) goto parse_lists;
        break;
      }

      // repeated uint32 lists = 8;
      case 8: {
        if (tag == 64) {
         parse_lists:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_lists())));
        } else if (tag == 66) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_lists())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.BriefPendingListRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.BriefPendingListRecordTradeCmd)
  return false;
#undef DO_
}

void BriefPendingListRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.BriefPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BRIEF_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional uint32 category = 4;
  if (has_category()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->category(), output);
  }

  // optional uint32 job = 5;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->job(), output);
  }

  // optional uint32 fashion = 6;
  if (has_fashion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->fashion(), output);
  }

  // repeated uint32 pub_lists = 7;
  for (int i = 0; i < this->pub_lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      7, this->pub_lists(i), output);
  }

  // repeated uint32 lists = 8;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.BriefPendingListRecordTradeCmd)
}

::google::protobuf::uint8* BriefPendingListRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.BriefPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BRIEF_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional uint32 category = 4;
  if (has_category()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->category(), target);
  }

  // optional uint32 job = 5;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->job(), target);
  }

  // optional uint32 fashion = 6;
  if (has_fashion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->fashion(), target);
  }

  // repeated uint32 pub_lists = 7;
  for (int i = 0; i < this->pub_lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(7, this->pub_lists(i), target);
  }

  // repeated uint32 lists = 8;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(8, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.BriefPendingListRecordTradeCmd)
  return target;
}

int BriefPendingListRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = BRIEF_PENDING_LIST_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional uint32 category = 4;
    if (has_category()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->category());
    }

    // optional uint32 job = 5;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->job());
    }

    // optional uint32 fashion = 6;
    if (has_fashion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fashion());
    }

  }
  // repeated uint32 pub_lists = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->pub_lists_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->pub_lists(i));
    }
    total_size += 1 * this->pub_lists_size() + data_size;
  }

  // repeated uint32 lists = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->lists_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->lists(i));
    }
    total_size += 1 * this->lists_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BriefPendingListRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BriefPendingListRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BriefPendingListRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BriefPendingListRecordTradeCmd::MergeFrom(const BriefPendingListRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  pub_lists_.MergeFrom(from.pub_lists_);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_category()) {
      set_category(from.category());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_fashion()) {
      set_fashion(from.fashion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BriefPendingListRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BriefPendingListRecordTradeCmd::CopyFrom(const BriefPendingListRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BriefPendingListRecordTradeCmd::IsInitialized() const {

  return true;
}

void BriefPendingListRecordTradeCmd::Swap(BriefPendingListRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(category_, other->category_);
    std::swap(job_, other->job_);
    std::swap(fashion_, other->fashion_);
    pub_lists_.Swap(&other->pub_lists_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BriefPendingListRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BriefPendingListRecordTradeCmd_descriptor_;
  metadata.reflection = BriefPendingListRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DetailPendingListRecordTradeCmd::kCmdFieldNumber;
const int DetailPendingListRecordTradeCmd::kParamFieldNumber;
const int DetailPendingListRecordTradeCmd::kSearchCondFieldNumber;
const int DetailPendingListRecordTradeCmd::kCharidFieldNumber;
const int DetailPendingListRecordTradeCmd::kListsFieldNumber;
const int DetailPendingListRecordTradeCmd::kTotalPageCountFieldNumber;
#endif  // !_MSC_VER

DetailPendingListRecordTradeCmd::DetailPendingListRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.DetailPendingListRecordTradeCmd)
}

void DetailPendingListRecordTradeCmd::InitAsDefaultInstance() {
  search_cond_ = const_cast< ::Cmd::SearchCond*>(&::Cmd::SearchCond::default_instance());
}

DetailPendingListRecordTradeCmd::DetailPendingListRecordTradeCmd(const DetailPendingListRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.DetailPendingListRecordTradeCmd)
}

void DetailPendingListRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 3;
  search_cond_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  total_page_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetailPendingListRecordTradeCmd::~DetailPendingListRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.DetailPendingListRecordTradeCmd)
  SharedDtor();
}

void DetailPendingListRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete search_cond_;
  }
}

void DetailPendingListRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DetailPendingListRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetailPendingListRecordTradeCmd_descriptor_;
}

const DetailPendingListRecordTradeCmd& DetailPendingListRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

DetailPendingListRecordTradeCmd* DetailPendingListRecordTradeCmd::default_instance_ = NULL;

DetailPendingListRecordTradeCmd* DetailPendingListRecordTradeCmd::New() const {
  return new DetailPendingListRecordTradeCmd;
}

void DetailPendingListRecordTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 47) {
    cmd_ = 57;
    param_ = 3;
    if (has_search_cond()) {
      if (search_cond_ != NULL) search_cond_->::Cmd::SearchCond::Clear();
    }
    charid_ = GOOGLE_ULONGLONG(0);
    total_page_count_ = 0u;
  }
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DetailPendingListRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.DetailPendingListRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = DETAIL_PENDING_LIST_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_search_cond;
        break;
      }

      // optional .Cmd.SearchCond search_cond = 3;
      case 3: {
        if (tag == 26) {
         parse_search_cond:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_search_cond()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_lists;
        break;
      }

      // repeated .Cmd.TradeItemBaseInfo lists = 5;
      case 5: {
        if (tag == 42) {
         parse_lists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lists()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_lists;
        if (input->ExpectTag(48)) goto parse_total_page_count;
        break;
      }

      // optional uint32 total_page_count = 6;
      case 6: {
        if (tag == 48) {
         parse_total_page_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_page_count_)));
          set_has_total_page_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.DetailPendingListRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.DetailPendingListRecordTradeCmd)
  return false;
#undef DO_
}

void DetailPendingListRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.DetailPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = DETAIL_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.SearchCond search_cond = 3;
  if (has_search_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->search_cond(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 5;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->lists(i), output);
  }

  // optional uint32 total_page_count = 6;
  if (has_total_page_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->total_page_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.DetailPendingListRecordTradeCmd)
}

::google::protobuf::uint8* DetailPendingListRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.DetailPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = DETAIL_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.SearchCond search_cond = 3;
  if (has_search_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->search_cond(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 5;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->lists(i), target);
  }

  // optional uint32 total_page_count = 6;
  if (has_total_page_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->total_page_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.DetailPendingListRecordTradeCmd)
  return target;
}

int DetailPendingListRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = DETAIL_PENDING_LIST_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.SearchCond search_cond = 3;
    if (has_search_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->search_cond());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional uint32 total_page_count = 6;
    if (has_total_page_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_page_count());
    }

  }
  // repeated .Cmd.TradeItemBaseInfo lists = 5;
  total_size += 1 * this->lists_size();
  for (int i = 0; i < this->lists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetailPendingListRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DetailPendingListRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DetailPendingListRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DetailPendingListRecordTradeCmd::MergeFrom(const DetailPendingListRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_search_cond()) {
      mutable_search_cond()->::Cmd::SearchCond::MergeFrom(from.search_cond());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_total_page_count()) {
      set_total_page_count(from.total_page_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DetailPendingListRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DetailPendingListRecordTradeCmd::CopyFrom(const DetailPendingListRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetailPendingListRecordTradeCmd::IsInitialized() const {

  return true;
}

void DetailPendingListRecordTradeCmd::Swap(DetailPendingListRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(search_cond_, other->search_cond_);
    std::swap(charid_, other->charid_);
    lists_.Swap(&other->lists_);
    std::swap(total_page_count_, other->total_page_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DetailPendingListRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DetailPendingListRecordTradeCmd_descriptor_;
  metadata.reflection = DetailPendingListRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BriefBuyInfo::kNameFieldNumber;
const int BriefBuyInfo::kTimeFieldNumber;
#endif  // !_MSC_VER

BriefBuyInfo::BriefBuyInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.BriefBuyInfo)
}

void BriefBuyInfo::InitAsDefaultInstance() {
}

BriefBuyInfo::BriefBuyInfo(const BriefBuyInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.BriefBuyInfo)
}

void BriefBuyInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BriefBuyInfo::~BriefBuyInfo() {
  // @@protoc_insertion_point(destructor:Cmd.BriefBuyInfo)
  SharedDtor();
}

void BriefBuyInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void BriefBuyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BriefBuyInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BriefBuyInfo_descriptor_;
}

const BriefBuyInfo& BriefBuyInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

BriefBuyInfo* BriefBuyInfo::default_instance_ = NULL;

BriefBuyInfo* BriefBuyInfo::New() const {
  return new BriefBuyInfo;
}

void BriefBuyInfo::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    time_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BriefBuyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.BriefBuyInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // optional uint32 time = 2;
      case 2: {
        if (tag == 16) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.BriefBuyInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.BriefBuyInfo)
  return false;
#undef DO_
}

void BriefBuyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.BriefBuyInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint32 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.BriefBuyInfo)
}

::google::protobuf::uint8* BriefBuyInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.BriefBuyInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional uint32 time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.BriefBuyInfo)
  return target;
}

int BriefBuyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BriefBuyInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BriefBuyInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BriefBuyInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BriefBuyInfo::MergeFrom(const BriefBuyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BriefBuyInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BriefBuyInfo::CopyFrom(const BriefBuyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BriefBuyInfo::IsInitialized() const {

  return true;
}

void BriefBuyInfo::Swap(BriefBuyInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BriefBuyInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BriefBuyInfo_descriptor_;
  metadata.reflection = BriefBuyInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemSellInfoRecordTradeCmd::kCmdFieldNumber;
const int ItemSellInfoRecordTradeCmd::kParamFieldNumber;
const int ItemSellInfoRecordTradeCmd::kCharidFieldNumber;
const int ItemSellInfoRecordTradeCmd::kItemidFieldNumber;
const int ItemSellInfoRecordTradeCmd::kRefineLvFieldNumber;
const int ItemSellInfoRecordTradeCmd::kPublicityIdFieldNumber;
const int ItemSellInfoRecordTradeCmd::kStatetypeFieldNumber;
const int ItemSellInfoRecordTradeCmd::kCountFieldNumber;
const int ItemSellInfoRecordTradeCmd::kBuyerCountFieldNumber;
const int ItemSellInfoRecordTradeCmd::kBuyInfoFieldNumber;
const int ItemSellInfoRecordTradeCmd::kOrderIdFieldNumber;
const int ItemSellInfoRecordTradeCmd::kTypeFieldNumber;
const int ItemSellInfoRecordTradeCmd::kQuotaFieldNumber;
#endif  // !_MSC_VER

ItemSellInfoRecordTradeCmd::ItemSellInfoRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ItemSellInfoRecordTradeCmd)
}

void ItemSellInfoRecordTradeCmd::InitAsDefaultInstance() {
}

ItemSellInfoRecordTradeCmd::ItemSellInfoRecordTradeCmd(const ItemSellInfoRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ItemSellInfoRecordTradeCmd)
}

void ItemSellInfoRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 4;
  charid_ = GOOGLE_ULONGLONG(0);
  itemid_ = 0u;
  refine_lv_ = 0u;
  publicity_id_ = 0u;
  statetype_ = 1;
  count_ = 0u;
  buyer_count_ = 0u;
  order_id_ = GOOGLE_ULONGLONG(0);
  type_ = 1;
  quota_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemSellInfoRecordTradeCmd::~ItemSellInfoRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.ItemSellInfoRecordTradeCmd)
  SharedDtor();
}

void ItemSellInfoRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemSellInfoRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemSellInfoRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemSellInfoRecordTradeCmd_descriptor_;
}

const ItemSellInfoRecordTradeCmd& ItemSellInfoRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ItemSellInfoRecordTradeCmd* ItemSellInfoRecordTradeCmd::default_instance_ = NULL;

ItemSellInfoRecordTradeCmd* ItemSellInfoRecordTradeCmd::New() const {
  return new ItemSellInfoRecordTradeCmd;
}

void ItemSellInfoRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ItemSellInfoRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(charid_, publicity_id_);
    cmd_ = 57;
    param_ = 4;
    statetype_ = 1;
    count_ = 0u;
  }
  if (_has_bits_[8 / 32] & 7424) {
    ZR_(order_id_, quota_);
    buyer_count_ = 0u;
    type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  buy_info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemSellInfoRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ItemSellInfoRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = ITEM_SELL_INFO_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_itemid;
        break;
      }

      // optional uint32 itemid = 4;
      case 4: {
        if (tag == 32) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_refine_lv;
        break;
      }

      // optional uint32 refine_lv = 5;
      case 5: {
        if (tag == 40) {
         parse_refine_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refine_lv_)));
          set_has_refine_lv();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_publicity_id;
        break;
      }

      // optional uint32 publicity_id = 6;
      case 6: {
        if (tag == 48) {
         parse_publicity_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &publicity_id_)));
          set_has_publicity_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_statetype;
        break;
      }

      // optional .Cmd.StateType statetype = 7;
      case 7: {
        if (tag == 56) {
         parse_statetype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::StateType_IsValid(value)) {
            set_statetype(static_cast< ::Cmd::StateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_count;
        break;
      }

      // optional uint32 count = 8 [default = 0];
      case 8: {
        if (tag == 64) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_buyer_count;
        break;
      }

      // optional uint32 buyer_count = 9 [default = 0];
      case 9: {
        if (tag == 72) {
         parse_buyer_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buyer_count_)));
          set_has_buyer_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_buy_info;
        break;
      }

      // repeated .Cmd.BriefBuyInfo buy_info = 10;
      case 10: {
        if (tag == 82) {
         parse_buy_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buy_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_buy_info;
        if (input->ExpectTag(88)) goto parse_order_id;
        break;
      }

      // optional uint64 order_id = 11;
      case 11: {
        if (tag == 88) {
         parse_order_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 12 [default = ETRADETYPE_TRADE];
      case 12: {
        if (tag == 96) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(12, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_quota;
        break;
      }

      // optional uint64 quota = 13;
      case 13: {
        if (tag == 104) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ItemSellInfoRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ItemSellInfoRecordTradeCmd)
  return false;
#undef DO_
}

void ItemSellInfoRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ItemSellInfoRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ITEM_SELL_INFO_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional uint32 itemid = 4;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->itemid(), output);
  }

  // optional uint32 refine_lv = 5;
  if (has_refine_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->refine_lv(), output);
  }

  // optional uint32 publicity_id = 6;
  if (has_publicity_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->publicity_id(), output);
  }

  // optional .Cmd.StateType statetype = 7;
  if (has_statetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->statetype(), output);
  }

  // optional uint32 count = 8 [default = 0];
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->count(), output);
  }

  // optional uint32 buyer_count = 9 [default = 0];
  if (has_buyer_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->buyer_count(), output);
  }

  // repeated .Cmd.BriefBuyInfo buy_info = 10;
  for (int i = 0; i < this->buy_info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->buy_info(i), output);
  }

  // optional uint64 order_id = 11;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->order_id(), output);
  }

  // optional .Cmd.ETradeType type = 12 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      12, this->type(), output);
  }

  // optional uint64 quota = 13;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->quota(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ItemSellInfoRecordTradeCmd)
}

::google::protobuf::uint8* ItemSellInfoRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ItemSellInfoRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ITEM_SELL_INFO_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional uint32 itemid = 4;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->itemid(), target);
  }

  // optional uint32 refine_lv = 5;
  if (has_refine_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->refine_lv(), target);
  }

  // optional uint32 publicity_id = 6;
  if (has_publicity_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->publicity_id(), target);
  }

  // optional .Cmd.StateType statetype = 7;
  if (has_statetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->statetype(), target);
  }

  // optional uint32 count = 8 [default = 0];
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->count(), target);
  }

  // optional uint32 buyer_count = 9 [default = 0];
  if (has_buyer_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->buyer_count(), target);
  }

  // repeated .Cmd.BriefBuyInfo buy_info = 10;
  for (int i = 0; i < this->buy_info_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->buy_info(i), target);
  }

  // optional uint64 order_id = 11;
  if (has_order_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->order_id(), target);
  }

  // optional .Cmd.ETradeType type = 12 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      12, this->type(), target);
  }

  // optional uint64 quota = 13;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(13, this->quota(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ItemSellInfoRecordTradeCmd)
  return target;
}

int ItemSellInfoRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = ITEM_SELL_INFO_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional uint32 itemid = 4;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // optional uint32 refine_lv = 5;
    if (has_refine_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refine_lv());
    }

    // optional uint32 publicity_id = 6;
    if (has_publicity_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->publicity_id());
    }

    // optional .Cmd.StateType statetype = 7;
    if (has_statetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->statetype());
    }

    // optional uint32 count = 8 [default = 0];
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 buyer_count = 9 [default = 0];
    if (has_buyer_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buyer_count());
    }

    // optional uint64 order_id = 11;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->order_id());
    }

    // optional .Cmd.ETradeType type = 12 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 quota = 13;
    if (has_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

  }
  // repeated .Cmd.BriefBuyInfo buy_info = 10;
  total_size += 1 * this->buy_info_size();
  for (int i = 0; i < this->buy_info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buy_info(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemSellInfoRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemSellInfoRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemSellInfoRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemSellInfoRecordTradeCmd::MergeFrom(const ItemSellInfoRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  buy_info_.MergeFrom(from.buy_info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_refine_lv()) {
      set_refine_lv(from.refine_lv());
    }
    if (from.has_publicity_id()) {
      set_publicity_id(from.publicity_id());
    }
    if (from.has_statetype()) {
      set_statetype(from.statetype());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buyer_count()) {
      set_buyer_count(from.buyer_count());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemSellInfoRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemSellInfoRecordTradeCmd::CopyFrom(const ItemSellInfoRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemSellInfoRecordTradeCmd::IsInitialized() const {

  return true;
}

void ItemSellInfoRecordTradeCmd::Swap(ItemSellInfoRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(itemid_, other->itemid_);
    std::swap(refine_lv_, other->refine_lv_);
    std::swap(publicity_id_, other->publicity_id_);
    std::swap(statetype_, other->statetype_);
    std::swap(count_, other->count_);
    std::swap(buyer_count_, other->buyer_count_);
    buy_info_.Swap(&other->buy_info_);
    std::swap(order_id_, other->order_id_);
    std::swap(type_, other->type_);
    std::swap(quota_, other->quota_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemSellInfoRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemSellInfoRecordTradeCmd_descriptor_;
  metadata.reflection = ItemSellInfoRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MyPendingListRecordTradeCmd::kCmdFieldNumber;
const int MyPendingListRecordTradeCmd::kParamFieldNumber;
const int MyPendingListRecordTradeCmd::kSearchCondFieldNumber;
const int MyPendingListRecordTradeCmd::kCharidFieldNumber;
const int MyPendingListRecordTradeCmd::kListsFieldNumber;
#endif  // !_MSC_VER

MyPendingListRecordTradeCmd::MyPendingListRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.MyPendingListRecordTradeCmd)
}

void MyPendingListRecordTradeCmd::InitAsDefaultInstance() {
  search_cond_ = const_cast< ::Cmd::SearchCond*>(&::Cmd::SearchCond::default_instance());
}

MyPendingListRecordTradeCmd::MyPendingListRecordTradeCmd(const MyPendingListRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.MyPendingListRecordTradeCmd)
}

void MyPendingListRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 7;
  search_cond_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MyPendingListRecordTradeCmd::~MyPendingListRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.MyPendingListRecordTradeCmd)
  SharedDtor();
}

void MyPendingListRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete search_cond_;
  }
}

void MyPendingListRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MyPendingListRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MyPendingListRecordTradeCmd_descriptor_;
}

const MyPendingListRecordTradeCmd& MyPendingListRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

MyPendingListRecordTradeCmd* MyPendingListRecordTradeCmd::default_instance_ = NULL;

MyPendingListRecordTradeCmd* MyPendingListRecordTradeCmd::New() const {
  return new MyPendingListRecordTradeCmd;
}

void MyPendingListRecordTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 7;
    if (has_search_cond()) {
      if (search_cond_ != NULL) search_cond_->::Cmd::SearchCond::Clear();
    }
    charid_ = GOOGLE_ULONGLONG(0);
  }
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MyPendingListRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.MyPendingListRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_PENDING_LIST_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_search_cond;
        break;
      }

      // optional .Cmd.SearchCond search_cond = 3;
      case 3: {
        if (tag == 26) {
         parse_search_cond:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_search_cond()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_lists;
        break;
      }

      // repeated .Cmd.TradeItemBaseInfo lists = 6;
      case 6: {
        if (tag == 50) {
         parse_lists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lists()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.MyPendingListRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.MyPendingListRecordTradeCmd)
  return false;
#undef DO_
}

void MyPendingListRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.MyPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.SearchCond search_cond = 3;
  if (has_search_cond()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->search_cond(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.MyPendingListRecordTradeCmd)
}

::google::protobuf::uint8* MyPendingListRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.MyPendingListRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_PENDING_LIST_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.SearchCond search_cond = 3;
  if (has_search_cond()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->search_cond(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.MyPendingListRecordTradeCmd)
  return target;
}

int MyPendingListRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_PENDING_LIST_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.SearchCond search_cond = 3;
    if (has_search_cond()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->search_cond());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

  }
  // repeated .Cmd.TradeItemBaseInfo lists = 6;
  total_size += 1 * this->lists_size();
  for (int i = 0; i < this->lists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MyPendingListRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MyPendingListRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MyPendingListRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MyPendingListRecordTradeCmd::MergeFrom(const MyPendingListRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_search_cond()) {
      mutable_search_cond()->::Cmd::SearchCond::MergeFrom(from.search_cond());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MyPendingListRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MyPendingListRecordTradeCmd::CopyFrom(const MyPendingListRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MyPendingListRecordTradeCmd::IsInitialized() const {

  return true;
}

void MyPendingListRecordTradeCmd::Swap(MyPendingListRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(search_cond_, other->search_cond_);
    std::swap(charid_, other->charid_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MyPendingListRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MyPendingListRecordTradeCmd_descriptor_;
  metadata.reflection = MyPendingListRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NameInfo::kNameFieldNumber;
const int NameInfo::kZoneidFieldNumber;
const int NameInfo::kCountFieldNumber;
#endif  // !_MSC_VER

NameInfo::NameInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.NameInfo)
}

void NameInfo::InitAsDefaultInstance() {
}

NameInfo::NameInfo(const NameInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.NameInfo)
}

void NameInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  zoneid_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NameInfo::~NameInfo() {
  // @@protoc_insertion_point(destructor:Cmd.NameInfo)
  SharedDtor();
}

void NameInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void NameInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NameInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NameInfo_descriptor_;
}

const NameInfo& NameInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

NameInfo* NameInfo::default_instance_ = NULL;

NameInfo* NameInfo::New() const {
  return new NameInfo;
}

void NameInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<NameInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(zoneid_, count_);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NameInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.NameInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_zoneid;
        break;
      }

      // optional uint32 zoneid = 2;
      case 2: {
        if (tag == 16) {
         parse_zoneid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.NameInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.NameInfo)
  return false;
#undef DO_
}

void NameInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.NameInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint32 zoneid = 2;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->zoneid(), output);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.NameInfo)
}

::google::protobuf::uint8* NameInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.NameInfo)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional uint32 zoneid = 2;
  if (has_zoneid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->zoneid(), target);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.NameInfo)
  return target;
}

int NameInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 zoneid = 2;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->zoneid());
    }

    // optional uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NameInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NameInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NameInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NameInfo::MergeFrom(const NameInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NameInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NameInfo::CopyFrom(const NameInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NameInfo::IsInitialized() const {

  return true;
}

void NameInfo::Swap(NameInfo* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(zoneid_, other->zoneid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NameInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NameInfo_descriptor_;
  metadata.reflection = NameInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NameInfoList::kNameInfosFieldNumber;
#endif  // !_MSC_VER

NameInfoList::NameInfoList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.NameInfoList)
}

void NameInfoList::InitAsDefaultInstance() {
}

NameInfoList::NameInfoList(const NameInfoList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.NameInfoList)
}

void NameInfoList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NameInfoList::~NameInfoList() {
  // @@protoc_insertion_point(destructor:Cmd.NameInfoList)
  SharedDtor();
}

void NameInfoList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NameInfoList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NameInfoList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NameInfoList_descriptor_;
}

const NameInfoList& NameInfoList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

NameInfoList* NameInfoList::default_instance_ = NULL;

NameInfoList* NameInfoList::New() const {
  return new NameInfoList;
}

void NameInfoList::Clear() {
  name_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NameInfoList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.NameInfoList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Cmd.NameInfo name_infos = 1;
      case 1: {
        if (tag == 10) {
         parse_name_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_name_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_name_infos;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.NameInfoList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.NameInfoList)
  return false;
#undef DO_
}

void NameInfoList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.NameInfoList)
  // repeated .Cmd.NameInfo name_infos = 1;
  for (int i = 0; i < this->name_infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->name_infos(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.NameInfoList)
}

::google::protobuf::uint8* NameInfoList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.NameInfoList)
  // repeated .Cmd.NameInfo name_infos = 1;
  for (int i = 0; i < this->name_infos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->name_infos(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.NameInfoList)
  return target;
}

int NameInfoList::ByteSize() const {
  int total_size = 0;

  // repeated .Cmd.NameInfo name_infos = 1;
  total_size += 1 * this->name_infos_size();
  for (int i = 0; i < this->name_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->name_infos(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NameInfoList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NameInfoList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NameInfoList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NameInfoList::MergeFrom(const NameInfoList& from) {
  GOOGLE_CHECK_NE(&from, this);
  name_infos_.MergeFrom(from.name_infos_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NameInfoList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NameInfoList::CopyFrom(const NameInfoList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NameInfoList::IsInitialized() const {

  return true;
}

void NameInfoList::Swap(NameInfoList* other) {
  if (other != this) {
    name_infos_.Swap(&other->name_infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NameInfoList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NameInfoList_descriptor_;
  metadata.reflection = NameInfoList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogItemInfo::kIdFieldNumber;
const int LogItemInfo::kStatusFieldNumber;
const int LogItemInfo::kLogtypeFieldNumber;
const int LogItemInfo::kItemidFieldNumber;
const int LogItemInfo::kRefineLvFieldNumber;
const int LogItemInfo::kDamageFieldNumber;
const int LogItemInfo::kTradetimeFieldNumber;
const int LogItemInfo::kCountFieldNumber;
const int LogItemInfo::kPriceFieldNumber;
const int LogItemInfo::kTaxFieldNumber;
const int LogItemInfo::kGetmoneyFieldNumber;
const int LogItemInfo::kCostmoneyFieldNumber;
const int LogItemInfo::kFailcountFieldNumber;
const int LogItemInfo::kRetmoneyFieldNumber;
const int LogItemInfo::kTotalcountFieldNumber;
const int LogItemInfo::kEndtimeFieldNumber;
const int LogItemInfo::kNameInfoFieldNumber;
const int LogItemInfo::kIsManyPeopleFieldNumber;
const int LogItemInfo::kNameListFieldNumber;
const int LogItemInfo::kItemdataFieldNumber;
const int LogItemInfo::kReceiveridFieldNumber;
const int LogItemInfo::kReceivernameFieldNumber;
const int LogItemInfo::kReceiverzoneidFieldNumber;
const int LogItemInfo::kQuotaFieldNumber;
const int LogItemInfo::kBackgroundFieldNumber;
const int LogItemInfo::kExpiretimeFieldNumber;
const int LogItemInfo::kRetCostFieldNumber;
const int LogItemInfo::kCangiveFieldNumber;
const int LogItemInfo::kTradeTypeFieldNumber;
const int LogItemInfo::kIsPublicFieldNumber;
const int LogItemInfo::kQuotaCostFieldNumber;
#endif  // !_MSC_VER

LogItemInfo::LogItemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.LogItemInfo)
}

void LogItemInfo::InitAsDefaultInstance() {
  name_info_ = const_cast< ::Cmd::NameInfo*>(&::Cmd::NameInfo::default_instance());
  name_list_ = const_cast< ::Cmd::NameInfoList*>(&::Cmd::NameInfoList::default_instance());
  itemdata_ = const_cast< ::Cmd::ItemData*>(&::Cmd::ItemData::default_instance());
}

LogItemInfo::LogItemInfo(const LogItemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.LogItemInfo)
}

void LogItemInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  logtype_ = 0;
  itemid_ = 0u;
  refine_lv_ = 0u;
  damage_ = false;
  tradetime_ = 0u;
  count_ = 0u;
  price_ = 0u;
  tax_ = 0u;
  getmoney_ = 0u;
  costmoney_ = 0u;
  failcount_ = 0u;
  retmoney_ = 0u;
  totalcount_ = 0u;
  endtime_ = 0u;
  name_info_ = NULL;
  is_many_people_ = false;
  name_list_ = NULL;
  itemdata_ = NULL;
  receiverid_ = GOOGLE_ULONGLONG(0);
  receivername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  receiverzoneid_ = 0u;
  quota_ = GOOGLE_ULONGLONG(0);
  background_ = 0u;
  expiretime_ = 0u;
  ret_cost_ = 0u;
  cangive_ = false;
  trade_type_ = 1;
  is_public_ = false;
  quota_cost_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogItemInfo::~LogItemInfo() {
  // @@protoc_insertion_point(destructor:Cmd.LogItemInfo)
  SharedDtor();
}

void LogItemInfo::SharedDtor() {
  if (receivername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete receivername_;
  }
  if (this != default_instance_) {
    delete name_info_;
    delete name_list_;
    delete itemdata_;
  }
}

void LogItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogItemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogItemInfo_descriptor_;
}

const LogItemInfo& LogItemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

LogItemInfo* LogItemInfo::default_instance_ = NULL;

LogItemInfo* LogItemInfo::New() const {
  return new LogItemInfo;
}

void LogItemInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LogItemInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, count_);
    damage_ = false;
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(price_, endtime_);
  }
  if (_has_bits_[16 / 32] & 16711680) {
    if (has_name_info()) {
      if (name_info_ != NULL) name_info_->::Cmd::NameInfo::Clear();
    }
    is_many_people_ = false;
    if (has_name_list()) {
      if (name_list_ != NULL) name_list_->::Cmd::NameInfoList::Clear();
    }
    if (has_itemdata()) {
      if (itemdata_ != NULL) itemdata_->::Cmd::ItemData::Clear();
    }
    receiverid_ = GOOGLE_ULONGLONG(0);
    if (has_receivername()) {
      if (receivername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        receivername_->clear();
      }
    }
    receiverzoneid_ = 0u;
    quota_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[24 / 32] & 2130706432) {
    ZR_(cangive_, is_public_);
    ZR_(background_, ret_cost_);
    trade_type_ = 1;
    quota_cost_ = GOOGLE_ULONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.LogItemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .Cmd.ETakeStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETakeStatus_IsValid(value)) {
            set_status(static_cast< ::Cmd::ETakeStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_logtype;
        break;
      }

      // optional .Cmd.EOperType logtype = 3;
      case 3: {
        if (tag == 24) {
         parse_logtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EOperType_IsValid(value)) {
            set_logtype(static_cast< ::Cmd::EOperType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_itemid;
        break;
      }

      // optional uint32 itemid = 4;
      case 4: {
        if (tag == 32) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_refine_lv;
        break;
      }

      // optional uint32 refine_lv = 5;
      case 5: {
        if (tag == 40) {
         parse_refine_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &refine_lv_)));
          set_has_refine_lv();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_damage;
        break;
      }

      // optional bool damage = 6;
      case 6: {
        if (tag == 48) {
         parse_damage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &damage_)));
          set_has_damage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tradetime;
        break;
      }

      // optional uint32 tradetime = 7;
      case 7: {
        if (tag == 56) {
         parse_tradetime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tradetime_)));
          set_has_tradetime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_count;
        break;
      }

      // optional uint32 count = 8;
      case 8: {
        if (tag == 64) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_tax;
        break;
      }

      // optional uint32 tax = 9;
      case 9: {
        if (tag == 72) {
         parse_tax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tax_)));
          set_has_tax();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_getmoney;
        break;
      }

      // optional uint32 getmoney = 10;
      case 10: {
        if (tag == 80) {
         parse_getmoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &getmoney_)));
          set_has_getmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_costmoney;
        break;
      }

      // optional uint32 costmoney = 11;
      case 11: {
        if (tag == 88) {
         parse_costmoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &costmoney_)));
          set_has_costmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_failcount;
        break;
      }

      // optional uint32 failcount = 12;
      case 12: {
        if (tag == 96) {
         parse_failcount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &failcount_)));
          set_has_failcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_retmoney;
        break;
      }

      // optional uint32 retmoney = 13;
      case 13: {
        if (tag == 104) {
         parse_retmoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &retmoney_)));
          set_has_retmoney();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_totalcount;
        break;
      }

      // optional uint32 totalcount = 14;
      case 14: {
        if (tag == 112) {
         parse_totalcount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &totalcount_)));
          set_has_totalcount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_endtime;
        break;
      }

      // optional uint32 endtime = 15;
      case 15: {
        if (tag == 120) {
         parse_endtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_name_info;
        break;
      }

      // optional .Cmd.NameInfo name_info = 16;
      case 16: {
        if (tag == 130) {
         parse_name_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_is_many_people;
        break;
      }

      // optional bool is_many_people = 17;
      case 17: {
        if (tag == 136) {
         parse_is_many_people:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_many_people_)));
          set_has_is_many_people();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_name_list;
        break;
      }

      // optional .Cmd.NameInfoList name_list = 18;
      case 18: {
        if (tag == 146) {
         parse_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_itemdata;
        break;
      }

      // optional .Cmd.ItemData itemdata = 19;
      case 19: {
        if (tag == 154) {
         parse_itemdata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_price;
        break;
      }

      // optional uint32 price = 20;
      case 20: {
        if (tag == 160) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_receiverid;
        break;
      }

      // optional uint64 receiverid = 21;
      case 21: {
        if (tag == 168) {
         parse_receiverid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &receiverid_)));
          set_has_receiverid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_receivername;
        break;
      }

      // optional string receivername = 22;
      case 22: {
        if (tag == 178) {
         parse_receivername:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_receivername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->receivername().data(), this->receivername().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "receivername");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_receiverzoneid;
        break;
      }

      // optional uint32 receiverzoneid = 23;
      case 23: {
        if (tag == 184) {
         parse_receiverzoneid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &receiverzoneid_)));
          set_has_receiverzoneid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_quota;
        break;
      }

      // optional uint64 quota = 24;
      case 24: {
        if (tag == 192) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_background;
        break;
      }

      // optional uint32 background = 25;
      case 25: {
        if (tag == 200) {
         parse_background:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &background_)));
          set_has_background();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_expiretime;
        break;
      }

      // optional uint32 expiretime = 26;
      case 26: {
        if (tag == 208) {
         parse_expiretime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiretime_)));
          set_has_expiretime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_ret_cost;
        break;
      }

      // optional uint32 ret_cost = 27;
      case 27: {
        if (tag == 216) {
         parse_ret_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ret_cost_)));
          set_has_ret_cost();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_cangive;
        break;
      }

      // optional bool cangive = 28;
      case 28: {
        if (tag == 224) {
         parse_cangive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cangive_)));
          set_has_cangive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 29 [default = ETRADETYPE_TRADE];
      case 29: {
        if (tag == 232) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(29, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_is_public;
        break;
      }

      // optional bool is_public = 30;
      case 30: {
        if (tag == 240) {
         parse_is_public:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_public_)));
          set_has_is_public();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_quota_cost;
        break;
      }

      // optional uint64 quota_cost = 31 [default = 0];
      case 31: {
        if (tag == 248) {
         parse_quota_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_cost_)));
          set_has_quota_cost();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.LogItemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.LogItemInfo)
  return false;
#undef DO_
}

void LogItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.LogItemInfo)
  // optional uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // optional .Cmd.ETakeStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .Cmd.EOperType logtype = 3;
  if (has_logtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->logtype(), output);
  }

  // optional uint32 itemid = 4;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->itemid(), output);
  }

  // optional uint32 refine_lv = 5;
  if (has_refine_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->refine_lv(), output);
  }

  // optional bool damage = 6;
  if (has_damage()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->damage(), output);
  }

  // optional uint32 tradetime = 7;
  if (has_tradetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->tradetime(), output);
  }

  // optional uint32 count = 8;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->count(), output);
  }

  // optional uint32 tax = 9;
  if (has_tax()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->tax(), output);
  }

  // optional uint32 getmoney = 10;
  if (has_getmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->getmoney(), output);
  }

  // optional uint32 costmoney = 11;
  if (has_costmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->costmoney(), output);
  }

  // optional uint32 failcount = 12;
  if (has_failcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->failcount(), output);
  }

  // optional uint32 retmoney = 13;
  if (has_retmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->retmoney(), output);
  }

  // optional uint32 totalcount = 14;
  if (has_totalcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->totalcount(), output);
  }

  // optional uint32 endtime = 15;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->endtime(), output);
  }

  // optional .Cmd.NameInfo name_info = 16;
  if (has_name_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->name_info(), output);
  }

  // optional bool is_many_people = 17;
  if (has_is_many_people()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(17, this->is_many_people(), output);
  }

  // optional .Cmd.NameInfoList name_list = 18;
  if (has_name_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, this->name_list(), output);
  }

  // optional .Cmd.ItemData itemdata = 19;
  if (has_itemdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19, this->itemdata(), output);
  }

  // optional uint32 price = 20;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(20, this->price(), output);
  }

  // optional uint64 receiverid = 21;
  if (has_receiverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->receiverid(), output);
  }

  // optional string receivername = 22;
  if (has_receivername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->receivername().data(), this->receivername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "receivername");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      22, this->receivername(), output);
  }

  // optional uint32 receiverzoneid = 23;
  if (has_receiverzoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->receiverzoneid(), output);
  }

  // optional uint64 quota = 24;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(24, this->quota(), output);
  }

  // optional uint32 background = 25;
  if (has_background()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(25, this->background(), output);
  }

  // optional uint32 expiretime = 26;
  if (has_expiretime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(26, this->expiretime(), output);
  }

  // optional uint32 ret_cost = 27;
  if (has_ret_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(27, this->ret_cost(), output);
  }

  // optional bool cangive = 28;
  if (has_cangive()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(28, this->cangive(), output);
  }

  // optional .Cmd.ETradeType trade_type = 29 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      29, this->trade_type(), output);
  }

  // optional bool is_public = 30;
  if (has_is_public()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(30, this->is_public(), output);
  }

  // optional uint64 quota_cost = 31 [default = 0];
  if (has_quota_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(31, this->quota_cost(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.LogItemInfo)
}

::google::protobuf::uint8* LogItemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.LogItemInfo)
  // optional uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // optional .Cmd.ETakeStatus status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional .Cmd.EOperType logtype = 3;
  if (has_logtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->logtype(), target);
  }

  // optional uint32 itemid = 4;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->itemid(), target);
  }

  // optional uint32 refine_lv = 5;
  if (has_refine_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->refine_lv(), target);
  }

  // optional bool damage = 6;
  if (has_damage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->damage(), target);
  }

  // optional uint32 tradetime = 7;
  if (has_tradetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->tradetime(), target);
  }

  // optional uint32 count = 8;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->count(), target);
  }

  // optional uint32 tax = 9;
  if (has_tax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->tax(), target);
  }

  // optional uint32 getmoney = 10;
  if (has_getmoney()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->getmoney(), target);
  }

  // optional uint32 costmoney = 11;
  if (has_costmoney()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->costmoney(), target);
  }

  // optional uint32 failcount = 12;
  if (has_failcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->failcount(), target);
  }

  // optional uint32 retmoney = 13;
  if (has_retmoney()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->retmoney(), target);
  }

  // optional uint32 totalcount = 14;
  if (has_totalcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->totalcount(), target);
  }

  // optional uint32 endtime = 15;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->endtime(), target);
  }

  // optional .Cmd.NameInfo name_info = 16;
  if (has_name_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->name_info(), target);
  }

  // optional bool is_many_people = 17;
  if (has_is_many_people()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(17, this->is_many_people(), target);
  }

  // optional .Cmd.NameInfoList name_list = 18;
  if (has_name_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        18, this->name_list(), target);
  }

  // optional .Cmd.ItemData itemdata = 19;
  if (has_itemdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        19, this->itemdata(), target);
  }

  // optional uint32 price = 20;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(20, this->price(), target);
  }

  // optional uint64 receiverid = 21;
  if (has_receiverid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->receiverid(), target);
  }

  // optional string receivername = 22;
  if (has_receivername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->receivername().data(), this->receivername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "receivername");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        22, this->receivername(), target);
  }

  // optional uint32 receiverzoneid = 23;
  if (has_receiverzoneid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->receiverzoneid(), target);
  }

  // optional uint64 quota = 24;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(24, this->quota(), target);
  }

  // optional uint32 background = 25;
  if (has_background()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(25, this->background(), target);
  }

  // optional uint32 expiretime = 26;
  if (has_expiretime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(26, this->expiretime(), target);
  }

  // optional uint32 ret_cost = 27;
  if (has_ret_cost()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(27, this->ret_cost(), target);
  }

  // optional bool cangive = 28;
  if (has_cangive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(28, this->cangive(), target);
  }

  // optional .Cmd.ETradeType trade_type = 29 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      29, this->trade_type(), target);
  }

  // optional bool is_public = 30;
  if (has_is_public()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(30, this->is_public(), target);
  }

  // optional uint64 quota_cost = 31 [default = 0];
  if (has_quota_cost()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(31, this->quota_cost(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.LogItemInfo)
  return target;
}

int LogItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional .Cmd.ETakeStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional .Cmd.EOperType logtype = 3;
    if (has_logtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->logtype());
    }

    // optional uint32 itemid = 4;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // optional uint32 refine_lv = 5;
    if (has_refine_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->refine_lv());
    }

    // optional bool damage = 6;
    if (has_damage()) {
      total_size += 1 + 1;
    }

    // optional uint32 tradetime = 7;
    if (has_tradetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tradetime());
    }

    // optional uint32 count = 8;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 price = 20;
    if (has_price()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

    // optional uint32 tax = 9;
    if (has_tax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tax());
    }

    // optional uint32 getmoney = 10;
    if (has_getmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->getmoney());
    }

    // optional uint32 costmoney = 11;
    if (has_costmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->costmoney());
    }

    // optional uint32 failcount = 12;
    if (has_failcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->failcount());
    }

    // optional uint32 retmoney = 13;
    if (has_retmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->retmoney());
    }

    // optional uint32 totalcount = 14;
    if (has_totalcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->totalcount());
    }

    // optional uint32 endtime = 15;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->endtime());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .Cmd.NameInfo name_info = 16;
    if (has_name_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name_info());
    }

    // optional bool is_many_people = 17;
    if (has_is_many_people()) {
      total_size += 2 + 1;
    }

    // optional .Cmd.NameInfoList name_list = 18;
    if (has_name_list()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name_list());
    }

    // optional .Cmd.ItemData itemdata = 19;
    if (has_itemdata()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemdata());
    }

    // optional uint64 receiverid = 21;
    if (has_receiverid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->receiverid());
    }

    // optional string receivername = 22;
    if (has_receivername()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->receivername());
    }

    // optional uint32 receiverzoneid = 23;
    if (has_receiverzoneid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->receiverzoneid());
    }

    // optional uint64 quota = 24;
    if (has_quota()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

  }
  if (_has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    // optional uint32 background = 25;
    if (has_background()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->background());
    }

    // optional uint32 expiretime = 26;
    if (has_expiretime()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiretime());
    }

    // optional uint32 ret_cost = 27;
    if (has_ret_cost()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ret_cost());
    }

    // optional bool cangive = 28;
    if (has_cangive()) {
      total_size += 2 + 1;
    }

    // optional .Cmd.ETradeType trade_type = 29 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

    // optional bool is_public = 30;
    if (has_is_public()) {
      total_size += 2 + 1;
    }

    // optional uint64 quota_cost = 31 [default = 0];
    if (has_quota_cost()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota_cost());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogItemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogItemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogItemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogItemInfo::MergeFrom(const LogItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_logtype()) {
      set_logtype(from.logtype());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_refine_lv()) {
      set_refine_lv(from.refine_lv());
    }
    if (from.has_damage()) {
      set_damage(from.damage());
    }
    if (from.has_tradetime()) {
      set_tradetime(from.tradetime());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_tax()) {
      set_tax(from.tax());
    }
    if (from.has_getmoney()) {
      set_getmoney(from.getmoney());
    }
    if (from.has_costmoney()) {
      set_costmoney(from.costmoney());
    }
    if (from.has_failcount()) {
      set_failcount(from.failcount());
    }
    if (from.has_retmoney()) {
      set_retmoney(from.retmoney());
    }
    if (from.has_totalcount()) {
      set_totalcount(from.totalcount());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_name_info()) {
      mutable_name_info()->::Cmd::NameInfo::MergeFrom(from.name_info());
    }
    if (from.has_is_many_people()) {
      set_is_many_people(from.is_many_people());
    }
    if (from.has_name_list()) {
      mutable_name_list()->::Cmd::NameInfoList::MergeFrom(from.name_list());
    }
    if (from.has_itemdata()) {
      mutable_itemdata()->::Cmd::ItemData::MergeFrom(from.itemdata());
    }
    if (from.has_receiverid()) {
      set_receiverid(from.receiverid());
    }
    if (from.has_receivername()) {
      set_receivername(from.receivername());
    }
    if (from.has_receiverzoneid()) {
      set_receiverzoneid(from.receiverzoneid());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_background()) {
      set_background(from.background());
    }
    if (from.has_expiretime()) {
      set_expiretime(from.expiretime());
    }
    if (from.has_ret_cost()) {
      set_ret_cost(from.ret_cost());
    }
    if (from.has_cangive()) {
      set_cangive(from.cangive());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
    if (from.has_is_public()) {
      set_is_public(from.is_public());
    }
    if (from.has_quota_cost()) {
      set_quota_cost(from.quota_cost());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogItemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogItemInfo::CopyFrom(const LogItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogItemInfo::IsInitialized() const {

  return true;
}

void LogItemInfo::Swap(LogItemInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(status_, other->status_);
    std::swap(logtype_, other->logtype_);
    std::swap(itemid_, other->itemid_);
    std::swap(refine_lv_, other->refine_lv_);
    std::swap(damage_, other->damage_);
    std::swap(tradetime_, other->tradetime_);
    std::swap(count_, other->count_);
    std::swap(price_, other->price_);
    std::swap(tax_, other->tax_);
    std::swap(getmoney_, other->getmoney_);
    std::swap(costmoney_, other->costmoney_);
    std::swap(failcount_, other->failcount_);
    std::swap(retmoney_, other->retmoney_);
    std::swap(totalcount_, other->totalcount_);
    std::swap(endtime_, other->endtime_);
    std::swap(name_info_, other->name_info_);
    std::swap(is_many_people_, other->is_many_people_);
    std::swap(name_list_, other->name_list_);
    std::swap(itemdata_, other->itemdata_);
    std::swap(receiverid_, other->receiverid_);
    std::swap(receivername_, other->receivername_);
    std::swap(receiverzoneid_, other->receiverzoneid_);
    std::swap(quota_, other->quota_);
    std::swap(background_, other->background_);
    std::swap(expiretime_, other->expiretime_);
    std::swap(ret_cost_, other->ret_cost_);
    std::swap(cangive_, other->cangive_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(is_public_, other->is_public_);
    std::swap(quota_cost_, other->quota_cost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogItemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogItemInfo_descriptor_;
  metadata.reflection = LogItemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MyTradeLogRecordTradeCmd::kCmdFieldNumber;
const int MyTradeLogRecordTradeCmd::kParamFieldNumber;
const int MyTradeLogRecordTradeCmd::kCharidFieldNumber;
const int MyTradeLogRecordTradeCmd::kIndexFieldNumber;
const int MyTradeLogRecordTradeCmd::kTotalPageCountFieldNumber;
const int MyTradeLogRecordTradeCmd::kLogListFieldNumber;
const int MyTradeLogRecordTradeCmd::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

MyTradeLogRecordTradeCmd::MyTradeLogRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.MyTradeLogRecordTradeCmd)
}

void MyTradeLogRecordTradeCmd::InitAsDefaultInstance() {
}

MyTradeLogRecordTradeCmd::MyTradeLogRecordTradeCmd(const MyTradeLogRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.MyTradeLogRecordTradeCmd)
}

void MyTradeLogRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 9;
  charid_ = GOOGLE_ULONGLONG(0);
  index_ = 0u;
  total_page_count_ = 0u;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MyTradeLogRecordTradeCmd::~MyTradeLogRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.MyTradeLogRecordTradeCmd)
  SharedDtor();
}

void MyTradeLogRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MyTradeLogRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MyTradeLogRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MyTradeLogRecordTradeCmd_descriptor_;
}

const MyTradeLogRecordTradeCmd& MyTradeLogRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

MyTradeLogRecordTradeCmd* MyTradeLogRecordTradeCmd::default_instance_ = NULL;

MyTradeLogRecordTradeCmd* MyTradeLogRecordTradeCmd::New() const {
  return new MyTradeLogRecordTradeCmd;
}

void MyTradeLogRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MyTradeLogRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 95) {
    ZR_(charid_, total_page_count_);
    cmd_ = 57;
    param_ = 9;
    trade_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  log_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MyTradeLogRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.MyTradeLogRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_TRADE_LOG_LIST_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_index;
        break;
      }

      // optional uint32 index = 4;
      case 4: {
        if (tag == 32) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_total_page_count;
        break;
      }

      // optional uint32 total_page_count = 5;
      case 5: {
        if (tag == 40) {
         parse_total_page_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_page_count_)));
          set_has_total_page_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_log_list;
        break;
      }

      // repeated .Cmd.LogItemInfo log_list = 6;
      case 6: {
        if (tag == 50) {
         parse_log_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_log_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_log_list;
        if (input->ExpectTag(56)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 7 [default = ETRADETYPE_TRADE];
      case 7: {
        if (tag == 56) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.MyTradeLogRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.MyTradeLogRecordTradeCmd)
  return false;
#undef DO_
}

void MyTradeLogRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.MyTradeLogRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_TRADE_LOG_LIST_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional uint32 index = 4;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->index(), output);
  }

  // optional uint32 total_page_count = 5;
  if (has_total_page_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->total_page_count(), output);
  }

  // repeated .Cmd.LogItemInfo log_list = 6;
  for (int i = 0; i < this->log_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->log_list(i), output);
  }

  // optional .Cmd.ETradeType trade_type = 7 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.MyTradeLogRecordTradeCmd)
}

::google::protobuf::uint8* MyTradeLogRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.MyTradeLogRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_TRADE_LOG_LIST_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional uint32 index = 4;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->index(), target);
  }

  // optional uint32 total_page_count = 5;
  if (has_total_page_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->total_page_count(), target);
  }

  // repeated .Cmd.LogItemInfo log_list = 6;
  for (int i = 0; i < this->log_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->log_list(i), target);
  }

  // optional .Cmd.ETradeType trade_type = 7 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.MyTradeLogRecordTradeCmd)
  return target;
}

int MyTradeLogRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = MY_TRADE_LOG_LIST_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional uint32 index = 4;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional uint32 total_page_count = 5;
    if (has_total_page_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_page_count());
    }

    // optional .Cmd.ETradeType trade_type = 7 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  // repeated .Cmd.LogItemInfo log_list = 6;
  total_size += 1 * this->log_list_size();
  for (int i = 0; i < this->log_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->log_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MyTradeLogRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MyTradeLogRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MyTradeLogRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MyTradeLogRecordTradeCmd::MergeFrom(const MyTradeLogRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  log_list_.MergeFrom(from.log_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_total_page_count()) {
      set_total_page_count(from.total_page_count());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MyTradeLogRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MyTradeLogRecordTradeCmd::CopyFrom(const MyTradeLogRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MyTradeLogRecordTradeCmd::IsInitialized() const {

  return true;
}

void MyTradeLogRecordTradeCmd::Swap(MyTradeLogRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(index_, other->index_);
    std::swap(total_page_count_, other->total_page_count_);
    log_list_.Swap(&other->log_list_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MyTradeLogRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MyTradeLogRecordTradeCmd_descriptor_;
  metadata.reflection = MyTradeLogRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TakeLogCmd::kCmdFieldNumber;
const int TakeLogCmd::kParamFieldNumber;
const int TakeLogCmd::kLogFieldNumber;
const int TakeLogCmd::kSuccessFieldNumber;
#endif  // !_MSC_VER

TakeLogCmd::TakeLogCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.TakeLogCmd)
}

void TakeLogCmd::InitAsDefaultInstance() {
  log_ = const_cast< ::Cmd::LogItemInfo*>(&::Cmd::LogItemInfo::default_instance());
}

TakeLogCmd::TakeLogCmd(const TakeLogCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.TakeLogCmd)
}

void TakeLogCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 27;
  log_ = NULL;
  success_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TakeLogCmd::~TakeLogCmd() {
  // @@protoc_insertion_point(destructor:Cmd.TakeLogCmd)
  SharedDtor();
}

void TakeLogCmd::SharedDtor() {
  if (this != default_instance_) {
    delete log_;
  }
}

void TakeLogCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TakeLogCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TakeLogCmd_descriptor_;
}

const TakeLogCmd& TakeLogCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

TakeLogCmd* TakeLogCmd::default_instance_ = NULL;

TakeLogCmd* TakeLogCmd::New() const {
  return new TakeLogCmd;
}

void TakeLogCmd::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 27;
    if (has_log()) {
      if (log_ != NULL) log_->::Cmd::LogItemInfo::Clear();
    }
    success_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TakeLogCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.TakeLogCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = TAKE_LOG_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_log;
        break;
      }

      // optional .Cmd.LogItemInfo log = 3;
      case 3: {
        if (tag == 26) {
         parse_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_success;
        break;
      }

      // optional bool success = 4;
      case 4: {
        if (tag == 32) {
         parse_success:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.TakeLogCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.TakeLogCmd)
  return false;
#undef DO_
}

void TakeLogCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.TakeLogCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = TAKE_LOG_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.LogItemInfo log = 3;
  if (has_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->log(), output);
  }

  // optional bool success = 4;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->success(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.TakeLogCmd)
}

::google::protobuf::uint8* TakeLogCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.TakeLogCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = TAKE_LOG_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.LogItemInfo log = 3;
  if (has_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->log(), target);
  }

  // optional bool success = 4;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->success(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.TakeLogCmd)
  return target;
}

int TakeLogCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = TAKE_LOG_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.LogItemInfo log = 3;
    if (has_log()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->log());
    }

    // optional bool success = 4;
    if (has_success()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TakeLogCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TakeLogCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TakeLogCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TakeLogCmd::MergeFrom(const TakeLogCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_log()) {
      mutable_log()->::Cmd::LogItemInfo::MergeFrom(from.log());
    }
    if (from.has_success()) {
      set_success(from.success());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TakeLogCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TakeLogCmd::CopyFrom(const TakeLogCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeLogCmd::IsInitialized() const {

  return true;
}

void TakeLogCmd::Swap(TakeLogCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(log_, other->log_);
    std::swap(success_, other->success_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TakeLogCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TakeLogCmd_descriptor_;
  metadata.reflection = TakeLogCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AddNewLog::kCmdFieldNumber;
const int AddNewLog::kParamFieldNumber;
const int AddNewLog::kCharidFieldNumber;
const int AddNewLog::kLogFieldNumber;
const int AddNewLog::kTotalPageCountFieldNumber;
#endif  // !_MSC_VER

AddNewLog::AddNewLog()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.AddNewLog)
}

void AddNewLog::InitAsDefaultInstance() {
  log_ = const_cast< ::Cmd::LogItemInfo*>(&::Cmd::LogItemInfo::default_instance());
}

AddNewLog::AddNewLog(const AddNewLog& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.AddNewLog)
}

void AddNewLog::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 28;
  charid_ = GOOGLE_ULONGLONG(0);
  log_ = NULL;
  total_page_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AddNewLog::~AddNewLog() {
  // @@protoc_insertion_point(destructor:Cmd.AddNewLog)
  SharedDtor();
}

void AddNewLog::SharedDtor() {
  if (this != default_instance_) {
    delete log_;
  }
}

void AddNewLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AddNewLog::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AddNewLog_descriptor_;
}

const AddNewLog& AddNewLog::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

AddNewLog* AddNewLog::default_instance_ = NULL;

AddNewLog* AddNewLog::New() const {
  return new AddNewLog;
}

void AddNewLog::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    cmd_ = 57;
    param_ = 28;
    charid_ = GOOGLE_ULONGLONG(0);
    if (has_log()) {
      if (log_ != NULL) log_->::Cmd::LogItemInfo::Clear();
    }
    total_page_count_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AddNewLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.AddNewLog)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = ADD_NEWLOG_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_log;
        break;
      }

      // optional .Cmd.LogItemInfo log = 4;
      case 4: {
        if (tag == 34) {
         parse_log:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_log()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_total_page_count;
        break;
      }

      // optional uint32 total_page_count = 5;
      case 5: {
        if (tag == 40) {
         parse_total_page_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_page_count_)));
          set_has_total_page_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.AddNewLog)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.AddNewLog)
  return false;
#undef DO_
}

void AddNewLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.AddNewLog)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ADD_NEWLOG_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional .Cmd.LogItemInfo log = 4;
  if (has_log()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->log(), output);
  }

  // optional uint32 total_page_count = 5;
  if (has_total_page_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->total_page_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.AddNewLog)
}

::google::protobuf::uint8* AddNewLog::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.AddNewLog)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ADD_NEWLOG_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional .Cmd.LogItemInfo log = 4;
  if (has_log()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->log(), target);
  }

  // optional uint32 total_page_count = 5;
  if (has_total_page_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->total_page_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.AddNewLog)
  return target;
}

int AddNewLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = ADD_NEWLOG_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.LogItemInfo log = 4;
    if (has_log()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->log());
    }

    // optional uint32 total_page_count = 5;
    if (has_total_page_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_page_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AddNewLog::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AddNewLog* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AddNewLog*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AddNewLog::MergeFrom(const AddNewLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_log()) {
      mutable_log()->::Cmd::LogItemInfo::MergeFrom(from.log());
    }
    if (from.has_total_page_count()) {
      set_total_page_count(from.total_page_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AddNewLog::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AddNewLog::CopyFrom(const AddNewLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddNewLog::IsInitialized() const {

  return true;
}

void AddNewLog::Swap(AddNewLog* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(log_, other->log_);
    std::swap(total_page_count_, other->total_page_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AddNewLog::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AddNewLog_descriptor_;
  metadata.reflection = AddNewLog_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FetchNameInfoCmd::kCmdFieldNumber;
const int FetchNameInfoCmd::kParamFieldNumber;
const int FetchNameInfoCmd::kIdFieldNumber;
const int FetchNameInfoCmd::kTypeFieldNumber;
const int FetchNameInfoCmd::kIndexFieldNumber;
const int FetchNameInfoCmd::kTotalPageCountFieldNumber;
const int FetchNameInfoCmd::kNameListFieldNumber;
#endif  // !_MSC_VER

FetchNameInfoCmd::FetchNameInfoCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.FetchNameInfoCmd)
}

void FetchNameInfoCmd::InitAsDefaultInstance() {
  name_list_ = const_cast< ::Cmd::NameInfoList*>(&::Cmd::NameInfoList::default_instance());
}

FetchNameInfoCmd::FetchNameInfoCmd(const FetchNameInfoCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.FetchNameInfoCmd)
}

void FetchNameInfoCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 29;
  id_ = GOOGLE_ULONGLONG(0);
  type_ = 0;
  index_ = 0u;
  total_page_count_ = 0u;
  name_list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FetchNameInfoCmd::~FetchNameInfoCmd() {
  // @@protoc_insertion_point(destructor:Cmd.FetchNameInfoCmd)
  SharedDtor();
}

void FetchNameInfoCmd::SharedDtor() {
  if (this != default_instance_) {
    delete name_list_;
  }
}

void FetchNameInfoCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FetchNameInfoCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FetchNameInfoCmd_descriptor_;
}

const FetchNameInfoCmd& FetchNameInfoCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

FetchNameInfoCmd* FetchNameInfoCmd::default_instance_ = NULL;

FetchNameInfoCmd* FetchNameInfoCmd::New() const {
  return new FetchNameInfoCmd;
}

void FetchNameInfoCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FetchNameInfoCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(id_, index_);
    cmd_ = 57;
    param_ = 29;
    total_page_count_ = 0u;
    if (has_name_list()) {
      if (name_list_ != NULL) name_list_->::Cmd::NameInfoList::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FetchNameInfoCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.FetchNameInfoCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = FETCH_NAMEINFO_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional uint64 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .Cmd.EOperType type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EOperType_IsValid(value)) {
            set_type(static_cast< ::Cmd::EOperType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_index;
        break;
      }

      // optional uint32 index = 5;
      case 5: {
        if (tag == 40) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_total_page_count;
        break;
      }

      // optional uint32 total_page_count = 6;
      case 6: {
        if (tag == 48) {
         parse_total_page_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_page_count_)));
          set_has_total_page_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_name_list;
        break;
      }

      // optional .Cmd.NameInfoList name_list = 7;
      case 7: {
        if (tag == 58) {
         parse_name_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_name_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.FetchNameInfoCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.FetchNameInfoCmd)
  return false;
#undef DO_
}

void FetchNameInfoCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.FetchNameInfoCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = FETCH_NAMEINFO_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->id(), output);
  }

  // optional .Cmd.EOperType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->index(), output);
  }

  // optional uint32 total_page_count = 6;
  if (has_total_page_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->total_page_count(), output);
  }

  // optional .Cmd.NameInfoList name_list = 7;
  if (has_name_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->name_list(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.FetchNameInfoCmd)
}

::google::protobuf::uint8* FetchNameInfoCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.FetchNameInfoCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = FETCH_NAMEINFO_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->id(), target);
  }

  // optional .Cmd.EOperType type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // optional uint32 index = 5;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->index(), target);
  }

  // optional uint32 total_page_count = 6;
  if (has_total_page_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->total_page_count(), target);
  }

  // optional .Cmd.NameInfoList name_list = 7;
  if (has_name_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->name_list(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.FetchNameInfoCmd)
  return target;
}

int FetchNameInfoCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = FETCH_NAMEINFO_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional .Cmd.EOperType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 index = 5;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // optional uint32 total_page_count = 6;
    if (has_total_page_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_page_count());
    }

    // optional .Cmd.NameInfoList name_list = 7;
    if (has_name_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->name_list());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FetchNameInfoCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FetchNameInfoCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FetchNameInfoCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FetchNameInfoCmd::MergeFrom(const FetchNameInfoCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_total_page_count()) {
      set_total_page_count(from.total_page_count());
    }
    if (from.has_name_list()) {
      mutable_name_list()->::Cmd::NameInfoList::MergeFrom(from.name_list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FetchNameInfoCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FetchNameInfoCmd::CopyFrom(const FetchNameInfoCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FetchNameInfoCmd::IsInitialized() const {

  return true;
}

void FetchNameInfoCmd::Swap(FetchNameInfoCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(index_, other->index_);
    std::swap(total_page_count_, other->total_page_count_);
    std::swap(name_list_, other->name_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FetchNameInfoCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FetchNameInfoCmd_descriptor_;
  metadata.reflection = FetchNameInfoCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqServerPriceRecordTradeCmd::kCmdFieldNumber;
const int ReqServerPriceRecordTradeCmd::kParamFieldNumber;
const int ReqServerPriceRecordTradeCmd::kCharidFieldNumber;
const int ReqServerPriceRecordTradeCmd::kItemDataFieldNumber;
const int ReqServerPriceRecordTradeCmd::kPriceFieldNumber;
const int ReqServerPriceRecordTradeCmd::kIssellFieldNumber;
const int ReqServerPriceRecordTradeCmd::kStatetypeFieldNumber;
const int ReqServerPriceRecordTradeCmd::kCountFieldNumber;
const int ReqServerPriceRecordTradeCmd::kBuyerCountFieldNumber;
const int ReqServerPriceRecordTradeCmd::kEndTimeFieldNumber;
const int ReqServerPriceRecordTradeCmd::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

ReqServerPriceRecordTradeCmd::ReqServerPriceRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ReqServerPriceRecordTradeCmd)
}

void ReqServerPriceRecordTradeCmd::InitAsDefaultInstance() {
  itemdata_ = const_cast< ::Cmd::ItemData*>(&::Cmd::ItemData::default_instance());
}

ReqServerPriceRecordTradeCmd::ReqServerPriceRecordTradeCmd(const ReqServerPriceRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ReqServerPriceRecordTradeCmd)
}

void ReqServerPriceRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 14;
  charid_ = GOOGLE_ULONGLONG(0);
  itemdata_ = NULL;
  price_ = 0u;
  issell_ = false;
  statetype_ = 1;
  count_ = 0u;
  buyer_count_ = 0u;
  end_time_ = 0u;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqServerPriceRecordTradeCmd::~ReqServerPriceRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.ReqServerPriceRecordTradeCmd)
  SharedDtor();
}

void ReqServerPriceRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete itemdata_;
  }
}

void ReqServerPriceRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqServerPriceRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqServerPriceRecordTradeCmd_descriptor_;
}

const ReqServerPriceRecordTradeCmd& ReqServerPriceRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ReqServerPriceRecordTradeCmd* ReqServerPriceRecordTradeCmd::default_instance_ = NULL;

ReqServerPriceRecordTradeCmd* ReqServerPriceRecordTradeCmd::New() const {
  return new ReqServerPriceRecordTradeCmd;
}

void ReqServerPriceRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ReqServerPriceRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(price_, issell_);
    cmd_ = 57;
    param_ = 14;
    charid_ = GOOGLE_ULONGLONG(0);
    if (has_itemdata()) {
      if (itemdata_ != NULL) itemdata_->::Cmd::ItemData::Clear();
    }
    statetype_ = 1;
    count_ = 0u;
  }
  if (_has_bits_[8 / 32] & 1792) {
    ZR_(buyer_count_, end_time_);
    trade_type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqServerPriceRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ReqServerPriceRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_SERVER_PRICE_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_itemData;
        break;
      }

      // optional .Cmd.ItemData itemData = 4;
      case 4: {
        if (tag == 34) {
         parse_itemData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_price;
        break;
      }

      // optional uint32 price = 5;
      case 5: {
        if (tag == 40) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_issell;
        break;
      }

      // optional bool issell = 6 [default = false];
      case 6: {
        if (tag == 48) {
         parse_issell:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &issell_)));
          set_has_issell();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_statetype;
        break;
      }

      // optional .Cmd.StateType statetype = 7;
      case 7: {
        if (tag == 56) {
         parse_statetype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::StateType_IsValid(value)) {
            set_statetype(static_cast< ::Cmd::StateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_count;
        break;
      }

      // optional uint32 count = 8 [default = 0];
      case 8: {
        if (tag == 64) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_buyer_count;
        break;
      }

      // optional uint32 buyer_count = 9 [default = 0];
      case 9: {
        if (tag == 72) {
         parse_buyer_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buyer_count_)));
          set_has_buyer_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_end_time;
        break;
      }

      // optional uint32 end_time = 10 [default = 0];
      case 10: {
        if (tag == 80) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 11 [default = ETRADETYPE_TRADE];
      case 11: {
        if (tag == 88) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(11, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ReqServerPriceRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ReqServerPriceRecordTradeCmd)
  return false;
#undef DO_
}

void ReqServerPriceRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ReqServerPriceRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_SERVER_PRICE_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional .Cmd.ItemData itemData = 4;
  if (has_itemdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->itemdata(), output);
  }

  // optional uint32 price = 5;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->price(), output);
  }

  // optional bool issell = 6 [default = false];
  if (has_issell()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->issell(), output);
  }

  // optional .Cmd.StateType statetype = 7;
  if (has_statetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->statetype(), output);
  }

  // optional uint32 count = 8 [default = 0];
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->count(), output);
  }

  // optional uint32 buyer_count = 9 [default = 0];
  if (has_buyer_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->buyer_count(), output);
  }

  // optional uint32 end_time = 10 [default = 0];
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->end_time(), output);
  }

  // optional .Cmd.ETradeType trade_type = 11 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ReqServerPriceRecordTradeCmd)
}

::google::protobuf::uint8* ReqServerPriceRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ReqServerPriceRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_SERVER_PRICE_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional .Cmd.ItemData itemData = 4;
  if (has_itemdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->itemdata(), target);
  }

  // optional uint32 price = 5;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->price(), target);
  }

  // optional bool issell = 6 [default = false];
  if (has_issell()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->issell(), target);
  }

  // optional .Cmd.StateType statetype = 7;
  if (has_statetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->statetype(), target);
  }

  // optional uint32 count = 8 [default = 0];
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->count(), target);
  }

  // optional uint32 buyer_count = 9 [default = 0];
  if (has_buyer_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->buyer_count(), target);
  }

  // optional uint32 end_time = 10 [default = 0];
  if (has_end_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->end_time(), target);
  }

  // optional .Cmd.ETradeType trade_type = 11 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ReqServerPriceRecordTradeCmd)
  return target;
}

int ReqServerPriceRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_SERVER_PRICE_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.ItemData itemData = 4;
    if (has_itemdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemdata());
    }

    // optional uint32 price = 5;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->price());
    }

    // optional bool issell = 6 [default = false];
    if (has_issell()) {
      total_size += 1 + 1;
    }

    // optional .Cmd.StateType statetype = 7;
    if (has_statetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->statetype());
    }

    // optional uint32 count = 8 [default = 0];
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 buyer_count = 9 [default = 0];
    if (has_buyer_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buyer_count());
    }

    // optional uint32 end_time = 10 [default = 0];
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->end_time());
    }

    // optional .Cmd.ETradeType trade_type = 11 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqServerPriceRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqServerPriceRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqServerPriceRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqServerPriceRecordTradeCmd::MergeFrom(const ReqServerPriceRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_itemdata()) {
      mutable_itemdata()->::Cmd::ItemData::MergeFrom(from.itemdata());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_issell()) {
      set_issell(from.issell());
    }
    if (from.has_statetype()) {
      set_statetype(from.statetype());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_buyer_count()) {
      set_buyer_count(from.buyer_count());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqServerPriceRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqServerPriceRecordTradeCmd::CopyFrom(const ReqServerPriceRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqServerPriceRecordTradeCmd::IsInitialized() const {

  return true;
}

void ReqServerPriceRecordTradeCmd::Swap(ReqServerPriceRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(itemdata_, other->itemdata_);
    std::swap(price_, other->price_);
    std::swap(issell_, other->issell_);
    std::swap(statetype_, other->statetype_);
    std::swap(count_, other->count_);
    std::swap(buyer_count_, other->buyer_count_);
    std::swap(end_time_, other->end_time_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqServerPriceRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqServerPriceRecordTradeCmd_descriptor_;
  metadata.reflection = ReqServerPriceRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BuyItemRecordTradeCmd::kCmdFieldNumber;
const int BuyItemRecordTradeCmd::kParamFieldNumber;
const int BuyItemRecordTradeCmd::kItemInfoFieldNumber;
const int BuyItemRecordTradeCmd::kCharidFieldNumber;
const int BuyItemRecordTradeCmd::kRetFieldNumber;
const int BuyItemRecordTradeCmd::kTypeFieldNumber;
#endif  // !_MSC_VER

BuyItemRecordTradeCmd::BuyItemRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.BuyItemRecordTradeCmd)
}

void BuyItemRecordTradeCmd::InitAsDefaultInstance() {
  item_info_ = const_cast< ::Cmd::TradeItemBaseInfo*>(&::Cmd::TradeItemBaseInfo::default_instance());
}

BuyItemRecordTradeCmd::BuyItemRecordTradeCmd(const BuyItemRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.BuyItemRecordTradeCmd)
}

void BuyItemRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 15;
  item_info_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  ret_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BuyItemRecordTradeCmd::~BuyItemRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.BuyItemRecordTradeCmd)
  SharedDtor();
}

void BuyItemRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete item_info_;
  }
}

void BuyItemRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BuyItemRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BuyItemRecordTradeCmd_descriptor_;
}

const BuyItemRecordTradeCmd& BuyItemRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

BuyItemRecordTradeCmd* BuyItemRecordTradeCmd::default_instance_ = NULL;

BuyItemRecordTradeCmd* BuyItemRecordTradeCmd::New() const {
  return new BuyItemRecordTradeCmd;
}

void BuyItemRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BuyItemRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(charid_, ret_);
    cmd_ = 57;
    param_ = 15;
    if (has_item_info()) {
      if (item_info_ != NULL) item_info_->::Cmd::TradeItemBaseInfo::Clear();
    }
    type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BuyItemRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.BuyItemRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = BUY_ITEM_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item_info;
        break;
      }

      // optional .Cmd.TradeItemBaseInfo item_info = 3;
      case 3: {
        if (tag == 26) {
         parse_item_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ret;
        break;
      }

      // optional .Cmd.ETRADE_RET_CODE ret = 5;
      case 5: {
        if (tag == 40) {
         parse_ret:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETRADE_RET_CODE_IsValid(value)) {
            set_ret(static_cast< ::Cmd::ETRADE_RET_CODE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
      case 6: {
        if (tag == 48) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.BuyItemRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.BuyItemRecordTradeCmd)
  return false;
#undef DO_
}

void BuyItemRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.BuyItemRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BUY_ITEM_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->item_info(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->ret(), output);
  }

  // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.BuyItemRecordTradeCmd)
}

::google::protobuf::uint8* BuyItemRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.BuyItemRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BUY_ITEM_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->item_info(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->ret(), target);
  }

  // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.BuyItemRecordTradeCmd)
  return target;
}

int BuyItemRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = BUY_ITEM_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.TradeItemBaseInfo item_info = 3;
    if (has_item_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item_info());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.ETRADE_RET_CODE ret = 5;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

    // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BuyItemRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BuyItemRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BuyItemRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BuyItemRecordTradeCmd::MergeFrom(const BuyItemRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_item_info()) {
      mutable_item_info()->::Cmd::TradeItemBaseInfo::MergeFrom(from.item_info());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BuyItemRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BuyItemRecordTradeCmd::CopyFrom(const BuyItemRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BuyItemRecordTradeCmd::IsInitialized() const {

  return true;
}

void BuyItemRecordTradeCmd::Swap(BuyItemRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(item_info_, other->item_info_);
    std::swap(charid_, other->charid_);
    std::swap(ret_, other->ret_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BuyItemRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BuyItemRecordTradeCmd_descriptor_;
  metadata.reflection = BuyItemRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SellItemRecordTradeCmd::kCmdFieldNumber;
const int SellItemRecordTradeCmd::kParamFieldNumber;
const int SellItemRecordTradeCmd::kItemInfoFieldNumber;
const int SellItemRecordTradeCmd::kCharidFieldNumber;
const int SellItemRecordTradeCmd::kRetFieldNumber;
const int SellItemRecordTradeCmd::kTypeFieldNumber;
#endif  // !_MSC_VER

SellItemRecordTradeCmd::SellItemRecordTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.SellItemRecordTradeCmd)
}

void SellItemRecordTradeCmd::InitAsDefaultInstance() {
  item_info_ = const_cast< ::Cmd::TradeItemBaseInfo*>(&::Cmd::TradeItemBaseInfo::default_instance());
}

SellItemRecordTradeCmd::SellItemRecordTradeCmd(const SellItemRecordTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.SellItemRecordTradeCmd)
}

void SellItemRecordTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 20;
  item_info_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  ret_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SellItemRecordTradeCmd::~SellItemRecordTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.SellItemRecordTradeCmd)
  SharedDtor();
}

void SellItemRecordTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete item_info_;
  }
}

void SellItemRecordTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SellItemRecordTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SellItemRecordTradeCmd_descriptor_;
}

const SellItemRecordTradeCmd& SellItemRecordTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

SellItemRecordTradeCmd* SellItemRecordTradeCmd::default_instance_ = NULL;

SellItemRecordTradeCmd* SellItemRecordTradeCmd::New() const {
  return new SellItemRecordTradeCmd;
}

void SellItemRecordTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SellItemRecordTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(charid_, ret_);
    cmd_ = 57;
    param_ = 20;
    if (has_item_info()) {
      if (item_info_ != NULL) item_info_->::Cmd::TradeItemBaseInfo::Clear();
    }
    type_ = 1;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SellItemRecordTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.SellItemRecordTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = SELL_ITEM_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item_info;
        break;
      }

      // optional .Cmd.TradeItemBaseInfo item_info = 3;
      case 3: {
        if (tag == 26) {
         parse_item_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ret;
        break;
      }

      // optional .Cmd.ETRADE_RET_CODE ret = 5;
      case 5: {
        if (tag == 40) {
         parse_ret:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETRADE_RET_CODE_IsValid(value)) {
            set_ret(static_cast< ::Cmd::ETRADE_RET_CODE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
      case 6: {
        if (tag == 48) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.SellItemRecordTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.SellItemRecordTradeCmd)
  return false;
#undef DO_
}

void SellItemRecordTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.SellItemRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = SELL_ITEM_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->item_info(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->ret(), output);
  }

  // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.SellItemRecordTradeCmd)
}

::google::protobuf::uint8* SellItemRecordTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.SellItemRecordTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = SELL_ITEM_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->item_info(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->ret(), target);
  }

  // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.SellItemRecordTradeCmd)
  return target;
}

int SellItemRecordTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = SELL_ITEM_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.TradeItemBaseInfo item_info = 3;
    if (has_item_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item_info());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.ETRADE_RET_CODE ret = 5;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

    // optional .Cmd.ETradeType type = 6 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SellItemRecordTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SellItemRecordTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SellItemRecordTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SellItemRecordTradeCmd::MergeFrom(const SellItemRecordTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_item_info()) {
      mutable_item_info()->::Cmd::TradeItemBaseInfo::MergeFrom(from.item_info());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SellItemRecordTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SellItemRecordTradeCmd::CopyFrom(const SellItemRecordTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SellItemRecordTradeCmd::IsInitialized() const {

  return true;
}

void SellItemRecordTradeCmd::Swap(SellItemRecordTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(item_info_, other->item_info_);
    std::swap(charid_, other->charid_);
    std::swap(ret_, other->ret_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SellItemRecordTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SellItemRecordTradeCmd_descriptor_;
  metadata.reflection = SellItemRecordTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CancelItemRecordTrade::kCmdFieldNumber;
const int CancelItemRecordTrade::kParamFieldNumber;
const int CancelItemRecordTrade::kItemInfoFieldNumber;
const int CancelItemRecordTrade::kCharidFieldNumber;
const int CancelItemRecordTrade::kRetFieldNumber;
const int CancelItemRecordTrade::kOrderIdFieldNumber;
const int CancelItemRecordTrade::kTypeFieldNumber;
const int CancelItemRecordTrade::kQuotaFieldNumber;
#endif  // !_MSC_VER

CancelItemRecordTrade::CancelItemRecordTrade()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.CancelItemRecordTrade)
}

void CancelItemRecordTrade::InitAsDefaultInstance() {
  item_info_ = const_cast< ::Cmd::TradeItemBaseInfo*>(&::Cmd::TradeItemBaseInfo::default_instance());
}

CancelItemRecordTrade::CancelItemRecordTrade(const CancelItemRecordTrade& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.CancelItemRecordTrade)
}

void CancelItemRecordTrade::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 22;
  item_info_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  ret_ = 0;
  order_id_ = GOOGLE_ULONGLONG(0);
  type_ = 1;
  quota_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CancelItemRecordTrade::~CancelItemRecordTrade() {
  // @@protoc_insertion_point(destructor:Cmd.CancelItemRecordTrade)
  SharedDtor();
}

void CancelItemRecordTrade::SharedDtor() {
  if (this != default_instance_) {
    delete item_info_;
  }
}

void CancelItemRecordTrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CancelItemRecordTrade::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CancelItemRecordTrade_descriptor_;
}

const CancelItemRecordTrade& CancelItemRecordTrade::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

CancelItemRecordTrade* CancelItemRecordTrade::default_instance_ = NULL;

CancelItemRecordTrade* CancelItemRecordTrade::New() const {
  return new CancelItemRecordTrade;
}

void CancelItemRecordTrade::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CancelItemRecordTrade*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(charid_, ret_);
    cmd_ = 57;
    param_ = 22;
    if (has_item_info()) {
      if (item_info_ != NULL) item_info_->::Cmd::TradeItemBaseInfo::Clear();
    }
    type_ = 1;
    quota_ = GOOGLE_ULONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CancelItemRecordTrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.CancelItemRecordTrade)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = CANCEL_PENDING_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item_info;
        break;
      }

      // optional .Cmd.TradeItemBaseInfo item_info = 3;
      case 3: {
        if (tag == 26) {
         parse_item_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ret;
        break;
      }

      // optional .Cmd.ETRADE_RET_CODE ret = 5;
      case 5: {
        if (tag == 40) {
         parse_ret:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETRADE_RET_CODE_IsValid(value)) {
            set_ret(static_cast< ::Cmd::ETRADE_RET_CODE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_order_id;
        break;
      }

      // optional uint64 order_id = 6;
      case 6: {
        if (tag == 48) {
         parse_order_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
      case 7: {
        if (tag == 56) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_quota;
        break;
      }

      // optional uint64 quota = 8;
      case 8: {
        if (tag == 64) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.CancelItemRecordTrade)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.CancelItemRecordTrade)
  return false;
#undef DO_
}

void CancelItemRecordTrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.CancelItemRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = CANCEL_PENDING_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->item_info(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->ret(), output);
  }

  // optional uint64 order_id = 6;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->order_id(), output);
  }

  // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->type(), output);
  }

  // optional uint64 quota = 8;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->quota(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.CancelItemRecordTrade)
}

::google::protobuf::uint8* CancelItemRecordTrade::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.CancelItemRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = CANCEL_PENDING_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->item_info(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->ret(), target);
  }

  // optional uint64 order_id = 6;
  if (has_order_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->order_id(), target);
  }

  // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->type(), target);
  }

  // optional uint64 quota = 8;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->quota(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.CancelItemRecordTrade)
  return target;
}

int CancelItemRecordTrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = CANCEL_PENDING_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.TradeItemBaseInfo item_info = 3;
    if (has_item_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item_info());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.ETRADE_RET_CODE ret = 5;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

    // optional uint64 order_id = 6;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->order_id());
    }

    // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 quota = 8;
    if (has_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CancelItemRecordTrade::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CancelItemRecordTrade* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CancelItemRecordTrade*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CancelItemRecordTrade::MergeFrom(const CancelItemRecordTrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_item_info()) {
      mutable_item_info()->::Cmd::TradeItemBaseInfo::MergeFrom(from.item_info());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CancelItemRecordTrade::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CancelItemRecordTrade::CopyFrom(const CancelItemRecordTrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelItemRecordTrade::IsInitialized() const {

  return true;
}

void CancelItemRecordTrade::Swap(CancelItemRecordTrade* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(item_info_, other->item_info_);
    std::swap(charid_, other->charid_);
    std::swap(ret_, other->ret_);
    std::swap(order_id_, other->order_id_);
    std::swap(type_, other->type_);
    std::swap(quota_, other->quota_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CancelItemRecordTrade::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CancelItemRecordTrade_descriptor_;
  metadata.reflection = CancelItemRecordTrade_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResellPendingRecordTrade::kCmdFieldNumber;
const int ResellPendingRecordTrade::kParamFieldNumber;
const int ResellPendingRecordTrade::kItemInfoFieldNumber;
const int ResellPendingRecordTrade::kCharidFieldNumber;
const int ResellPendingRecordTrade::kRetFieldNumber;
const int ResellPendingRecordTrade::kOrderIdFieldNumber;
const int ResellPendingRecordTrade::kTypeFieldNumber;
const int ResellPendingRecordTrade::kQuotaFieldNumber;
#endif  // !_MSC_VER

ResellPendingRecordTrade::ResellPendingRecordTrade()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ResellPendingRecordTrade)
}

void ResellPendingRecordTrade::InitAsDefaultInstance() {
  item_info_ = const_cast< ::Cmd::TradeItemBaseInfo*>(&::Cmd::TradeItemBaseInfo::default_instance());
}

ResellPendingRecordTrade::ResellPendingRecordTrade(const ResellPendingRecordTrade& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ResellPendingRecordTrade)
}

void ResellPendingRecordTrade::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 23;
  item_info_ = NULL;
  charid_ = GOOGLE_ULONGLONG(0);
  ret_ = 0;
  order_id_ = GOOGLE_ULONGLONG(0);
  type_ = 1;
  quota_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResellPendingRecordTrade::~ResellPendingRecordTrade() {
  // @@protoc_insertion_point(destructor:Cmd.ResellPendingRecordTrade)
  SharedDtor();
}

void ResellPendingRecordTrade::SharedDtor() {
  if (this != default_instance_) {
    delete item_info_;
  }
}

void ResellPendingRecordTrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResellPendingRecordTrade::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResellPendingRecordTrade_descriptor_;
}

const ResellPendingRecordTrade& ResellPendingRecordTrade::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ResellPendingRecordTrade* ResellPendingRecordTrade::default_instance_ = NULL;

ResellPendingRecordTrade* ResellPendingRecordTrade::New() const {
  return new ResellPendingRecordTrade;
}

void ResellPendingRecordTrade::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ResellPendingRecordTrade*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(charid_, ret_);
    cmd_ = 57;
    param_ = 23;
    if (has_item_info()) {
      if (item_info_ != NULL) item_info_->::Cmd::TradeItemBaseInfo::Clear();
    }
    type_ = 1;
    quota_ = GOOGLE_ULONGLONG(0);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResellPendingRecordTrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ResellPendingRecordTrade)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = RESELL_PENDING_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_item_info;
        break;
      }

      // optional .Cmd.TradeItemBaseInfo item_info = 3;
      case 3: {
        if (tag == 26) {
         parse_item_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 4;
      case 4: {
        if (tag == 32) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ret;
        break;
      }

      // optional .Cmd.ETRADE_RET_CODE ret = 5;
      case 5: {
        if (tag == 40) {
         parse_ret:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETRADE_RET_CODE_IsValid(value)) {
            set_ret(static_cast< ::Cmd::ETRADE_RET_CODE >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_order_id;
        break;
      }

      // optional uint64 order_id = 6;
      case 6: {
        if (tag == 48) {
         parse_order_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &order_id_)));
          set_has_order_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
      case 7: {
        if (tag == 56) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_quota;
        break;
      }

      // optional uint64 quota = 8;
      case 8: {
        if (tag == 64) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ResellPendingRecordTrade)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ResellPendingRecordTrade)
  return false;
#undef DO_
}

void ResellPendingRecordTrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ResellPendingRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = RESELL_PENDING_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->item_info(), output);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->charid(), output);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->ret(), output);
  }

  // optional uint64 order_id = 6;
  if (has_order_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->order_id(), output);
  }

  // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->type(), output);
  }

  // optional uint64 quota = 8;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->quota(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ResellPendingRecordTrade)
}

::google::protobuf::uint8* ResellPendingRecordTrade::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ResellPendingRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = RESELL_PENDING_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.TradeItemBaseInfo item_info = 3;
  if (has_item_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->item_info(), target);
  }

  // optional uint64 charid = 4;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->charid(), target);
  }

  // optional .Cmd.ETRADE_RET_CODE ret = 5;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->ret(), target);
  }

  // optional uint64 order_id = 6;
  if (has_order_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->order_id(), target);
  }

  // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->type(), target);
  }

  // optional uint64 quota = 8;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->quota(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ResellPendingRecordTrade)
  return target;
}

int ResellPendingRecordTrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = RESELL_PENDING_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.TradeItemBaseInfo item_info = 3;
    if (has_item_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item_info());
    }

    // optional uint64 charid = 4;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.ETRADE_RET_CODE ret = 5;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ret());
    }

    // optional uint64 order_id = 6;
    if (has_order_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->order_id());
    }

    // optional .Cmd.ETradeType type = 7 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 quota = 8;
    if (has_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResellPendingRecordTrade::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResellPendingRecordTrade* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResellPendingRecordTrade*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResellPendingRecordTrade::MergeFrom(const ResellPendingRecordTrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_item_info()) {
      mutable_item_info()->::Cmd::TradeItemBaseInfo::MergeFrom(from.item_info());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_order_id()) {
      set_order_id(from.order_id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResellPendingRecordTrade::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResellPendingRecordTrade::CopyFrom(const ResellPendingRecordTrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResellPendingRecordTrade::IsInitialized() const {

  return true;
}

void ResellPendingRecordTrade::Swap(ResellPendingRecordTrade* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(item_info_, other->item_info_);
    std::swap(charid_, other->charid_);
    std::swap(ret_, other->ret_);
    std::swap(order_id_, other->order_id_);
    std::swap(type_, other->type_);
    std::swap(quota_, other->quota_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResellPendingRecordTrade::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResellPendingRecordTrade_descriptor_;
  metadata.reflection = ResellPendingRecordTrade_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PanelRecordTrade::kCmdFieldNumber;
const int PanelRecordTrade::kParamFieldNumber;
const int PanelRecordTrade::kCharidFieldNumber;
const int PanelRecordTrade::kOperFieldNumber;
const int PanelRecordTrade::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

PanelRecordTrade::PanelRecordTrade()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.PanelRecordTrade)
}

void PanelRecordTrade::InitAsDefaultInstance() {
}

PanelRecordTrade::PanelRecordTrade(const PanelRecordTrade& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.PanelRecordTrade)
}

void PanelRecordTrade::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 24;
  charid_ = GOOGLE_ULONGLONG(0);
  oper_ = 1;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PanelRecordTrade::~PanelRecordTrade() {
  // @@protoc_insertion_point(destructor:Cmd.PanelRecordTrade)
  SharedDtor();
}

void PanelRecordTrade::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PanelRecordTrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PanelRecordTrade::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PanelRecordTrade_descriptor_;
}

const PanelRecordTrade& PanelRecordTrade::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

PanelRecordTrade* PanelRecordTrade::default_instance_ = NULL;

PanelRecordTrade* PanelRecordTrade::New() const {
  return new PanelRecordTrade;
}

void PanelRecordTrade::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    cmd_ = 57;
    param_ = 24;
    charid_ = GOOGLE_ULONGLONG(0);
    oper_ = 1;
    trade_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PanelRecordTrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.PanelRecordTrade)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = PANEL_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_oper;
        break;
      }

      // optional .Cmd.EPanelOperType oper = 4;
      case 4: {
        if (tag == 32) {
         parse_oper:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EPanelOperType_IsValid(value)) {
            set_oper(static_cast< ::Cmd::EPanelOperType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
      case 5: {
        if (tag == 40) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.PanelRecordTrade)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.PanelRecordTrade)
  return false;
#undef DO_
}

void PanelRecordTrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.PanelRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = PANEL_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional .Cmd.EPanelOperType oper = 4;
  if (has_oper()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->oper(), output);
  }

  // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.PanelRecordTrade)
}

::google::protobuf::uint8* PanelRecordTrade::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.PanelRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = PANEL_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional .Cmd.EPanelOperType oper = 4;
  if (has_oper()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->oper(), target);
  }

  // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.PanelRecordTrade)
  return target;
}

int PanelRecordTrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = PANEL_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.EPanelOperType oper = 4;
    if (has_oper()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->oper());
    }

    // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PanelRecordTrade::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PanelRecordTrade* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PanelRecordTrade*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PanelRecordTrade::MergeFrom(const PanelRecordTrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_oper()) {
      set_oper(from.oper());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PanelRecordTrade::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PanelRecordTrade::CopyFrom(const PanelRecordTrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PanelRecordTrade::IsInitialized() const {

  return true;
}

void PanelRecordTrade::Swap(PanelRecordTrade* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(oper_, other->oper_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PanelRecordTrade::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PanelRecordTrade_descriptor_;
  metadata.reflection = PanelRecordTrade_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ListNtfRecordTrade::kCmdFieldNumber;
const int ListNtfRecordTrade::kParamFieldNumber;
const int ListNtfRecordTrade::kCharidFieldNumber;
const int ListNtfRecordTrade::kTypeFieldNumber;
const int ListNtfRecordTrade::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

ListNtfRecordTrade::ListNtfRecordTrade()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ListNtfRecordTrade)
}

void ListNtfRecordTrade::InitAsDefaultInstance() {
}

ListNtfRecordTrade::ListNtfRecordTrade(const ListNtfRecordTrade& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ListNtfRecordTrade)
}

void ListNtfRecordTrade::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 25;
  charid_ = GOOGLE_ULONGLONG(0);
  type_ = 1;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ListNtfRecordTrade::~ListNtfRecordTrade() {
  // @@protoc_insertion_point(destructor:Cmd.ListNtfRecordTrade)
  SharedDtor();
}

void ListNtfRecordTrade::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ListNtfRecordTrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ListNtfRecordTrade::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ListNtfRecordTrade_descriptor_;
}

const ListNtfRecordTrade& ListNtfRecordTrade::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ListNtfRecordTrade* ListNtfRecordTrade::default_instance_ = NULL;

ListNtfRecordTrade* ListNtfRecordTrade::New() const {
  return new ListNtfRecordTrade;
}

void ListNtfRecordTrade::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    cmd_ = 57;
    param_ = 25;
    charid_ = GOOGLE_ULONGLONG(0);
    type_ = 1;
    trade_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ListNtfRecordTrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ListNtfRecordTrade)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = LIST_NTF_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .Cmd.EListNtfType type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EListNtfType_IsValid(value)) {
            set_type(static_cast< ::Cmd::EListNtfType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
      case 5: {
        if (tag == 40) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ListNtfRecordTrade)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ListNtfRecordTrade)
  return false;
#undef DO_
}

void ListNtfRecordTrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ListNtfRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = LIST_NTF_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional .Cmd.EListNtfType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ListNtfRecordTrade)
}

::google::protobuf::uint8* ListNtfRecordTrade::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ListNtfRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = LIST_NTF_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional .Cmd.EListNtfType type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ListNtfRecordTrade)
  return target;
}

int ListNtfRecordTrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = LIST_NTF_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.EListNtfType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .Cmd.ETradeType trade_type = 5 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ListNtfRecordTrade::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ListNtfRecordTrade* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ListNtfRecordTrade*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ListNtfRecordTrade::MergeFrom(const ListNtfRecordTrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ListNtfRecordTrade::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ListNtfRecordTrade::CopyFrom(const ListNtfRecordTrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ListNtfRecordTrade::IsInitialized() const {

  return true;
}

void ListNtfRecordTrade::Swap(ListNtfRecordTrade* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(type_, other->type_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ListNtfRecordTrade::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ListNtfRecordTrade_descriptor_;
  metadata.reflection = ListNtfRecordTrade_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HotItemidRecordTrade::kCmdFieldNumber;
const int HotItemidRecordTrade::kParamFieldNumber;
const int HotItemidRecordTrade::kCharidFieldNumber;
const int HotItemidRecordTrade::kJobFieldNumber;
const int HotItemidRecordTrade::kPubListsFieldNumber;
const int HotItemidRecordTrade::kListsFieldNumber;
#endif  // !_MSC_VER

HotItemidRecordTrade::HotItemidRecordTrade()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.HotItemidRecordTrade)
}

void HotItemidRecordTrade::InitAsDefaultInstance() {
}

HotItemidRecordTrade::HotItemidRecordTrade(const HotItemidRecordTrade& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.HotItemidRecordTrade)
}

void HotItemidRecordTrade::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 26;
  charid_ = GOOGLE_ULONGLONG(0);
  job_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HotItemidRecordTrade::~HotItemidRecordTrade() {
  // @@protoc_insertion_point(destructor:Cmd.HotItemidRecordTrade)
  SharedDtor();
}

void HotItemidRecordTrade::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HotItemidRecordTrade::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HotItemidRecordTrade::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HotItemidRecordTrade_descriptor_;
}

const HotItemidRecordTrade& HotItemidRecordTrade::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

HotItemidRecordTrade* HotItemidRecordTrade::default_instance_ = NULL;

HotItemidRecordTrade* HotItemidRecordTrade::New() const {
  return new HotItemidRecordTrade;
}

void HotItemidRecordTrade::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 26;
    charid_ = GOOGLE_ULONGLONG(0);
    job_ = 0u;
  }
  pub_lists_.Clear();
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HotItemidRecordTrade::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.HotItemidRecordTrade)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = HOT_ITEMID_RECORDTRADE];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_job;
        break;
      }

      // optional uint32 job = 4;
      case 4: {
        if (tag == 32) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pub_lists;
        break;
      }

      // repeated uint32 pub_lists = 5;
      case 5: {
        if (tag == 40) {
         parse_pub_lists:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 40, input, this->mutable_pub_lists())));
        } else if (tag == 42) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_pub_lists())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pub_lists;
        if (input->ExpectTag(48)) goto parse_lists;
        break;
      }

      // repeated uint32 lists = 6;
      case 6: {
        if (tag == 48) {
         parse_lists:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_lists())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_lists())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.HotItemidRecordTrade)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.HotItemidRecordTrade)
  return false;
#undef DO_
}

void HotItemidRecordTrade::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.HotItemidRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = HOT_ITEMID_RECORDTRADE];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional uint32 job = 4;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->job(), output);
  }

  // repeated uint32 pub_lists = 5;
  for (int i = 0; i < this->pub_lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      5, this->pub_lists(i), output);
  }

  // repeated uint32 lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.HotItemidRecordTrade)
}

::google::protobuf::uint8* HotItemidRecordTrade::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.HotItemidRecordTrade)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = HOT_ITEMID_RECORDTRADE];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional uint32 job = 4;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->job(), target);
  }

  // repeated uint32 pub_lists = 5;
  for (int i = 0; i < this->pub_lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(5, this->pub_lists(i), target);
  }

  // repeated uint32 lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(6, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.HotItemidRecordTrade)
  return target;
}

int HotItemidRecordTrade::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = HOT_ITEMID_RECORDTRADE];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional uint32 job = 4;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->job());
    }

  }
  // repeated uint32 pub_lists = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->pub_lists_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->pub_lists(i));
    }
    total_size += 1 * this->pub_lists_size() + data_size;
  }

  // repeated uint32 lists = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->lists_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->lists(i));
    }
    total_size += 1 * this->lists_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HotItemidRecordTrade::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HotItemidRecordTrade* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HotItemidRecordTrade*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HotItemidRecordTrade::MergeFrom(const HotItemidRecordTrade& from) {
  GOOGLE_CHECK_NE(&from, this);
  pub_lists_.MergeFrom(from.pub_lists_);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HotItemidRecordTrade::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HotItemidRecordTrade::CopyFrom(const HotItemidRecordTrade& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HotItemidRecordTrade::IsInitialized() const {

  return true;
}

void HotItemidRecordTrade::Swap(HotItemidRecordTrade* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(job_, other->job_);
    pub_lists_.Swap(&other->pub_lists_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HotItemidRecordTrade::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HotItemidRecordTrade_descriptor_;
  metadata.reflection = HotItemidRecordTrade_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NtfCanTakeCountTradeCmd::kCmdFieldNumber;
const int NtfCanTakeCountTradeCmd::kParamFieldNumber;
const int NtfCanTakeCountTradeCmd::kCountFieldNumber;
const int NtfCanTakeCountTradeCmd::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

NtfCanTakeCountTradeCmd::NtfCanTakeCountTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.NtfCanTakeCountTradeCmd)
}

void NtfCanTakeCountTradeCmd::InitAsDefaultInstance() {
}

NtfCanTakeCountTradeCmd::NtfCanTakeCountTradeCmd(const NtfCanTakeCountTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.NtfCanTakeCountTradeCmd)
}

void NtfCanTakeCountTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 30;
  count_ = 0u;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NtfCanTakeCountTradeCmd::~NtfCanTakeCountTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.NtfCanTakeCountTradeCmd)
  SharedDtor();
}

void NtfCanTakeCountTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NtfCanTakeCountTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NtfCanTakeCountTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NtfCanTakeCountTradeCmd_descriptor_;
}

const NtfCanTakeCountTradeCmd& NtfCanTakeCountTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

NtfCanTakeCountTradeCmd* NtfCanTakeCountTradeCmd::default_instance_ = NULL;

NtfCanTakeCountTradeCmd* NtfCanTakeCountTradeCmd::New() const {
  return new NtfCanTakeCountTradeCmd;
}

void NtfCanTakeCountTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 30;
    count_ = 0u;
    trade_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NtfCanTakeCountTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.NtfCanTakeCountTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = NTF_CAN_TAKE_COUNT_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 4 [default = ETRADETYPE_TRADE];
      case 4: {
        if (tag == 32) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.NtfCanTakeCountTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.NtfCanTakeCountTradeCmd)
  return false;
#undef DO_
}

void NtfCanTakeCountTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.NtfCanTakeCountTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = NTF_CAN_TAKE_COUNT_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  // optional .Cmd.ETradeType trade_type = 4 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.NtfCanTakeCountTradeCmd)
}

::google::protobuf::uint8* NtfCanTakeCountTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.NtfCanTakeCountTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = NTF_CAN_TAKE_COUNT_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  // optional .Cmd.ETradeType trade_type = 4 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.NtfCanTakeCountTradeCmd)
  return target;
}

int NtfCanTakeCountTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = NTF_CAN_TAKE_COUNT_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional .Cmd.ETradeType trade_type = 4 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NtfCanTakeCountTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NtfCanTakeCountTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NtfCanTakeCountTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NtfCanTakeCountTradeCmd::MergeFrom(const NtfCanTakeCountTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NtfCanTakeCountTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NtfCanTakeCountTradeCmd::CopyFrom(const NtfCanTakeCountTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NtfCanTakeCountTradeCmd::IsInitialized() const {

  return true;
}

void NtfCanTakeCountTradeCmd::Swap(NtfCanTakeCountTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(count_, other->count_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NtfCanTakeCountTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NtfCanTakeCountTradeCmd_descriptor_;
  metadata.reflection = NtfCanTakeCountTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GiveTradeCmd::kCmdFieldNumber;
const int GiveTradeCmd::kParamFieldNumber;
const int GiveTradeCmd::kIdFieldNumber;
const int GiveTradeCmd::kLogtypeFieldNumber;
const int GiveTradeCmd::kFriendidFieldNumber;
const int GiveTradeCmd::kContentFieldNumber;
const int GiveTradeCmd::kAnonymousFieldNumber;
const int GiveTradeCmd::kBackgroundFieldNumber;
const int GiveTradeCmd::kSuccessFieldNumber;
#endif  // !_MSC_VER

GiveTradeCmd::GiveTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.GiveTradeCmd)
}

void GiveTradeCmd::InitAsDefaultInstance() {
}

GiveTradeCmd::GiveTradeCmd(const GiveTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.GiveTradeCmd)
}

void GiveTradeCmd::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 31;
  id_ = GOOGLE_ULONGLONG(0);
  logtype_ = 0;
  friendid_ = GOOGLE_ULONGLONG(0);
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  anonymous_ = false;
  background_ = 0u;
  success_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GiveTradeCmd::~GiveTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.GiveTradeCmd)
  SharedDtor();
}

void GiveTradeCmd::SharedDtor() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (this != default_instance_) {
  }
}

void GiveTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GiveTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GiveTradeCmd_descriptor_;
}

const GiveTradeCmd& GiveTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

GiveTradeCmd* GiveTradeCmd::default_instance_ = NULL;

GiveTradeCmd* GiveTradeCmd::New() const {
  return new GiveTradeCmd;
}

void GiveTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GiveTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, friendid_);
    ZR_(logtype_, anonymous_);
    cmd_ = 57;
    param_ = 31;
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
  }
  success_ = false;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GiveTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.GiveTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = GIVE_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional uint64 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_logtype;
        break;
      }

      // optional .Cmd.EOperType logtype = 4;
      case 4: {
        if (tag == 32) {
         parse_logtype:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EOperType_IsValid(value)) {
            set_logtype(static_cast< ::Cmd::EOperType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_friendid;
        break;
      }

      // optional uint64 friendid = 5;
      case 5: {
        if (tag == 40) {
         parse_friendid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &friendid_)));
          set_has_friendid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_content;
        break;
      }

      // optional string content = 6;
      case 6: {
        if (tag == 50) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->content().data(), this->content().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "content");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_anonymous;
        break;
      }

      // optional bool anonymous = 7;
      case 7: {
        if (tag == 56) {
         parse_anonymous:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &anonymous_)));
          set_has_anonymous();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_background;
        break;
      }

      // optional uint32 background = 8;
      case 8: {
        if (tag == 64) {
         parse_background:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &background_)));
          set_has_background();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_success;
        break;
      }

      // optional bool success = 9;
      case 9: {
        if (tag == 72) {
         parse_success:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.GiveTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.GiveTradeCmd)
  return false;
#undef DO_
}

void GiveTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.GiveTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = GIVE_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->id(), output);
  }

  // optional .Cmd.EOperType logtype = 4;
  if (has_logtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->logtype(), output);
  }

  // optional uint64 friendid = 5;
  if (has_friendid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->friendid(), output);
  }

  // optional string content = 6;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->content(), output);
  }

  // optional bool anonymous = 7;
  if (has_anonymous()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->anonymous(), output);
  }

  // optional uint32 background = 8;
  if (has_background()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->background(), output);
  }

  // optional bool success = 9;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->success(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.GiveTradeCmd)
}

::google::protobuf::uint8* GiveTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.GiveTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = GIVE_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->id(), target);
  }

  // optional .Cmd.EOperType logtype = 4;
  if (has_logtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->logtype(), target);
  }

  // optional uint64 friendid = 5;
  if (has_friendid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->friendid(), target);
  }

  // optional string content = 6;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->content(), target);
  }

  // optional bool anonymous = 7;
  if (has_anonymous()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->anonymous(), target);
  }

  // optional uint32 background = 8;
  if (has_background()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->background(), target);
  }

  // optional bool success = 9;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->success(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.GiveTradeCmd)
  return target;
}

int GiveTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = GIVE_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional .Cmd.EOperType logtype = 4;
    if (has_logtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->logtype());
    }

    // optional uint64 friendid = 5;
    if (has_friendid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->friendid());
    }

    // optional string content = 6;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional bool anonymous = 7;
    if (has_anonymous()) {
      total_size += 1 + 1;
    }

    // optional uint32 background = 8;
    if (has_background()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->background());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool success = 9;
    if (has_success()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GiveTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GiveTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GiveTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GiveTradeCmd::MergeFrom(const GiveTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_logtype()) {
      set_logtype(from.logtype());
    }
    if (from.has_friendid()) {
      set_friendid(from.friendid());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_anonymous()) {
      set_anonymous(from.anonymous());
    }
    if (from.has_background()) {
      set_background(from.background());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GiveTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GiveTradeCmd::CopyFrom(const GiveTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GiveTradeCmd::IsInitialized() const {

  return true;
}

void GiveTradeCmd::Swap(GiveTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(id_, other->id_);
    std::swap(logtype_, other->logtype_);
    std::swap(friendid_, other->friendid_);
    std::swap(content_, other->content_);
    std::swap(anonymous_, other->anonymous_);
    std::swap(background_, other->background_);
    std::swap(success_, other->success_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GiveTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GiveTradeCmd_descriptor_;
  metadata.reflection = GiveTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AcceptTradeCmd::kCmdFieldNumber;
const int AcceptTradeCmd::kParamFieldNumber;
const int AcceptTradeCmd::kIdFieldNumber;
const int AcceptTradeCmd::kSuccessFieldNumber;
#endif  // !_MSC_VER

AcceptTradeCmd::AcceptTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.AcceptTradeCmd)
}

void AcceptTradeCmd::InitAsDefaultInstance() {
}

AcceptTradeCmd::AcceptTradeCmd(const AcceptTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.AcceptTradeCmd)
}

void AcceptTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 33;
  id_ = GOOGLE_ULONGLONG(0);
  success_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AcceptTradeCmd::~AcceptTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.AcceptTradeCmd)
  SharedDtor();
}

void AcceptTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AcceptTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AcceptTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AcceptTradeCmd_descriptor_;
}

const AcceptTradeCmd& AcceptTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

AcceptTradeCmd* AcceptTradeCmd::default_instance_ = NULL;

AcceptTradeCmd* AcceptTradeCmd::New() const {
  return new AcceptTradeCmd;
}

void AcceptTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AcceptTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(id_, success_);
    cmd_ = 57;
    param_ = 33;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AcceptTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.AcceptTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = ACCEPT_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional uint64 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_success;
        break;
      }

      // optional bool success = 4;
      case 4: {
        if (tag == 32) {
         parse_success:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.AcceptTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.AcceptTradeCmd)
  return false;
#undef DO_
}

void AcceptTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.AcceptTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ACCEPT_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->id(), output);
  }

  // optional bool success = 4;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->success(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.AcceptTradeCmd)
}

::google::protobuf::uint8* AcceptTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.AcceptTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = ACCEPT_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->id(), target);
  }

  // optional bool success = 4;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->success(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.AcceptTradeCmd)
  return target;
}

int AcceptTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = ACCEPT_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional bool success = 4;
    if (has_success()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AcceptTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AcceptTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AcceptTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AcceptTradeCmd::MergeFrom(const AcceptTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_success()) {
      set_success(from.success());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AcceptTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AcceptTradeCmd::CopyFrom(const AcceptTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcceptTradeCmd::IsInitialized() const {

  return true;
}

void AcceptTradeCmd::Swap(AcceptTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(id_, other->id_);
    std::swap(success_, other->success_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AcceptTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AcceptTradeCmd_descriptor_;
  metadata.reflection = AcceptTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RefuseTradeCmd::kCmdFieldNumber;
const int RefuseTradeCmd::kParamFieldNumber;
const int RefuseTradeCmd::kIdFieldNumber;
const int RefuseTradeCmd::kSuccessFieldNumber;
#endif  // !_MSC_VER

RefuseTradeCmd::RefuseTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.RefuseTradeCmd)
}

void RefuseTradeCmd::InitAsDefaultInstance() {
}

RefuseTradeCmd::RefuseTradeCmd(const RefuseTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.RefuseTradeCmd)
}

void RefuseTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 34;
  id_ = GOOGLE_ULONGLONG(0);
  success_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RefuseTradeCmd::~RefuseTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.RefuseTradeCmd)
  SharedDtor();
}

void RefuseTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RefuseTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RefuseTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RefuseTradeCmd_descriptor_;
}

const RefuseTradeCmd& RefuseTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

RefuseTradeCmd* RefuseTradeCmd::default_instance_ = NULL;

RefuseTradeCmd* RefuseTradeCmd::New() const {
  return new RefuseTradeCmd;
}

void RefuseTradeCmd::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RefuseTradeCmd*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(id_, success_);
    cmd_ = 57;
    param_ = 34;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RefuseTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.RefuseTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = REFUSE_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional uint64 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_success;
        break;
      }

      // optional bool success = 4;
      case 4: {
        if (tag == 32) {
         parse_success:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.RefuseTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.RefuseTradeCmd)
  return false;
#undef DO_
}

void RefuseTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.RefuseTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REFUSE_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->id(), output);
  }

  // optional bool success = 4;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->success(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.RefuseTradeCmd)
}

::google::protobuf::uint8* RefuseTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.RefuseTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REFUSE_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->id(), target);
  }

  // optional bool success = 4;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->success(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.RefuseTradeCmd)
  return target;
}

int RefuseTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = REFUSE_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional bool success = 4;
    if (has_success()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RefuseTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RefuseTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RefuseTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RefuseTradeCmd::MergeFrom(const RefuseTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_success()) {
      set_success(from.success());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RefuseTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RefuseTradeCmd::CopyFrom(const RefuseTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RefuseTradeCmd::IsInitialized() const {

  return true;
}

void RefuseTradeCmd::Swap(RefuseTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(id_, other->id_);
    std::swap(success_, other->success_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RefuseTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RefuseTradeCmd_descriptor_;
  metadata.reflection = RefuseTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GiveItemInfo::kIdFieldNumber;
const int GiveItemInfo::kStatusFieldNumber;
const int GiveItemInfo::kItemidFieldNumber;
const int GiveItemInfo::kCountFieldNumber;
const int GiveItemInfo::kItemdataFieldNumber;
const int GiveItemInfo::kSenderidFieldNumber;
const int GiveItemInfo::kSendernameFieldNumber;
const int GiveItemInfo::kAnonymousFieldNumber;
const int GiveItemInfo::kExpiretimeFieldNumber;
const int GiveItemInfo::kContentFieldNumber;
const int GiveItemInfo::kQuotaFieldNumber;
const int GiveItemInfo::kReceivernameFieldNumber;
const int GiveItemInfo::kBackgroundFieldNumber;
#endif  // !_MSC_VER

GiveItemInfo::GiveItemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.GiveItemInfo)
}

void GiveItemInfo::InitAsDefaultInstance() {
  itemdata_ = const_cast< ::Cmd::ItemData*>(&::Cmd::ItemData::default_instance());
}

GiveItemInfo::GiveItemInfo(const GiveItemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.GiveItemInfo)
}

void GiveItemInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  status_ = 0;
  itemid_ = 0u;
  count_ = 0u;
  itemdata_ = NULL;
  senderid_ = GOOGLE_ULONGLONG(0);
  sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  anonymous_ = false;
  expiretime_ = 0u;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  quota_ = GOOGLE_ULONGLONG(0);
  receivername_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  background_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GiveItemInfo::~GiveItemInfo() {
  // @@protoc_insertion_point(destructor:Cmd.GiveItemInfo)
  SharedDtor();
}

void GiveItemInfo::SharedDtor() {
  if (sendername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sendername_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (receivername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete receivername_;
  }
  if (this != default_instance_) {
    delete itemdata_;
  }
}

void GiveItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GiveItemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GiveItemInfo_descriptor_;
}

const GiveItemInfo& GiveItemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

GiveItemInfo* GiveItemInfo::default_instance_ = NULL;

GiveItemInfo* GiveItemInfo::New() const {
  return new GiveItemInfo;
}

void GiveItemInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GiveItemInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, itemid_);
    ZR_(senderid_, anonymous_);
    if (has_itemdata()) {
      if (itemdata_ != NULL) itemdata_->::Cmd::ItemData::Clear();
    }
    if (has_sendername()) {
      if (sendername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sendername_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(quota_, background_);
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
    if (has_receivername()) {
      if (receivername_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        receivername_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GiveItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.GiveItemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // optional .Cmd.ETakeStatus status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETakeStatus_IsValid(value)) {
            set_status(static_cast< ::Cmd::ETakeStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_itemid;
        break;
      }

      // optional uint32 itemid = 3;
      case 3: {
        if (tag == 24) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional uint32 count = 4;
      case 4: {
        if (tag == 32) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_itemdata;
        break;
      }

      // optional .Cmd.ItemData itemdata = 5;
      case 5: {
        if (tag == 42) {
         parse_itemdata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_itemdata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_senderid;
        break;
      }

      // optional uint64 senderid = 6;
      case 6: {
        if (tag == 48) {
         parse_senderid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &senderid_)));
          set_has_senderid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_sendername;
        break;
      }

      // optional string sendername = 7;
      case 7: {
        if (tag == 58) {
         parse_sendername:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sendername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sendername().data(), this->sendername().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "sendername");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_anonymous;
        break;
      }

      // optional bool anonymous = 8;
      case 8: {
        if (tag == 64) {
         parse_anonymous:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &anonymous_)));
          set_has_anonymous();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_expiretime;
        break;
      }

      // optional uint32 expiretime = 9;
      case 9: {
        if (tag == 72) {
         parse_expiretime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiretime_)));
          set_has_expiretime();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_content;
        break;
      }

      // optional string content = 10;
      case 10: {
        if (tag == 82) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->content().data(), this->content().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "content");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_quota;
        break;
      }

      // optional uint64 quota = 11;
      case 11: {
        if (tag == 88) {
         parse_quota:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_)));
          set_has_quota();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_receivername;
        break;
      }

      // optional string receivername = 12;
      case 12: {
        if (tag == 98) {
         parse_receivername:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_receivername()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->receivername().data(), this->receivername().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "receivername");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_background;
        break;
      }

      // optional uint32 background = 13;
      case 13: {
        if (tag == 104) {
         parse_background:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &background_)));
          set_has_background();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.GiveItemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.GiveItemInfo)
  return false;
#undef DO_
}

void GiveItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.GiveItemInfo)
  // optional uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // optional .Cmd.ETakeStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional uint32 itemid = 3;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->itemid(), output);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->count(), output);
  }

  // optional .Cmd.ItemData itemdata = 5;
  if (has_itemdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->itemdata(), output);
  }

  // optional uint64 senderid = 6;
  if (has_senderid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->senderid(), output);
  }

  // optional string sendername = 7;
  if (has_sendername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sendername().data(), this->sendername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sendername");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->sendername(), output);
  }

  // optional bool anonymous = 8;
  if (has_anonymous()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->anonymous(), output);
  }

  // optional uint32 expiretime = 9;
  if (has_expiretime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->expiretime(), output);
  }

  // optional string content = 10;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->content(), output);
  }

  // optional uint64 quota = 11;
  if (has_quota()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->quota(), output);
  }

  // optional string receivername = 12;
  if (has_receivername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->receivername().data(), this->receivername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "receivername");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->receivername(), output);
  }

  // optional uint32 background = 13;
  if (has_background()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->background(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.GiveItemInfo)
}

::google::protobuf::uint8* GiveItemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.GiveItemInfo)
  // optional uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // optional .Cmd.ETakeStatus status = 2;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->status(), target);
  }

  // optional uint32 itemid = 3;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->itemid(), target);
  }

  // optional uint32 count = 4;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->count(), target);
  }

  // optional .Cmd.ItemData itemdata = 5;
  if (has_itemdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->itemdata(), target);
  }

  // optional uint64 senderid = 6;
  if (has_senderid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->senderid(), target);
  }

  // optional string sendername = 7;
  if (has_sendername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sendername().data(), this->sendername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sendername");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->sendername(), target);
  }

  // optional bool anonymous = 8;
  if (has_anonymous()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->anonymous(), target);
  }

  // optional uint32 expiretime = 9;
  if (has_expiretime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->expiretime(), target);
  }

  // optional string content = 10;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->content(), target);
  }

  // optional uint64 quota = 11;
  if (has_quota()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->quota(), target);
  }

  // optional string receivername = 12;
  if (has_receivername()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->receivername().data(), this->receivername().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "receivername");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        12, this->receivername(), target);
  }

  // optional uint32 background = 13;
  if (has_background()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(13, this->background(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.GiveItemInfo)
  return target;
}

int GiveItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional .Cmd.ETakeStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional uint32 itemid = 3;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // optional uint32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional .Cmd.ItemData itemdata = 5;
    if (has_itemdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->itemdata());
    }

    // optional uint64 senderid = 6;
    if (has_senderid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->senderid());
    }

    // optional string sendername = 7;
    if (has_sendername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sendername());
    }

    // optional bool anonymous = 8;
    if (has_anonymous()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 expiretime = 9;
    if (has_expiretime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiretime());
    }

    // optional string content = 10;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional uint64 quota = 11;
    if (has_quota()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->quota());
    }

    // optional string receivername = 12;
    if (has_receivername()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->receivername());
    }

    // optional uint32 background = 13;
    if (has_background()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->background());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GiveItemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GiveItemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GiveItemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GiveItemInfo::MergeFrom(const GiveItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_itemdata()) {
      mutable_itemdata()->::Cmd::ItemData::MergeFrom(from.itemdata());
    }
    if (from.has_senderid()) {
      set_senderid(from.senderid());
    }
    if (from.has_sendername()) {
      set_sendername(from.sendername());
    }
    if (from.has_anonymous()) {
      set_anonymous(from.anonymous());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_expiretime()) {
      set_expiretime(from.expiretime());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_quota()) {
      set_quota(from.quota());
    }
    if (from.has_receivername()) {
      set_receivername(from.receivername());
    }
    if (from.has_background()) {
      set_background(from.background());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GiveItemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GiveItemInfo::CopyFrom(const GiveItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GiveItemInfo::IsInitialized() const {

  return true;
}

void GiveItemInfo::Swap(GiveItemInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(status_, other->status_);
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(itemdata_, other->itemdata_);
    std::swap(senderid_, other->senderid_);
    std::swap(sendername_, other->sendername_);
    std::swap(anonymous_, other->anonymous_);
    std::swap(expiretime_, other->expiretime_);
    std::swap(content_, other->content_);
    std::swap(quota_, other->quota_);
    std::swap(receivername_, other->receivername_);
    std::swap(background_, other->background_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GiveItemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GiveItemInfo_descriptor_;
  metadata.reflection = GiveItemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqGiveItemInfoCmd::kCmdFieldNumber;
const int ReqGiveItemInfoCmd::kParamFieldNumber;
const int ReqGiveItemInfoCmd::kIdFieldNumber;
const int ReqGiveItemInfoCmd::kIteminfoFieldNumber;
#endif  // !_MSC_VER

ReqGiveItemInfoCmd::ReqGiveItemInfoCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ReqGiveItemInfoCmd)
}

void ReqGiveItemInfoCmd::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::Cmd::GiveItemInfo*>(&::Cmd::GiveItemInfo::default_instance());
}

ReqGiveItemInfoCmd::ReqGiveItemInfoCmd(const ReqGiveItemInfoCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ReqGiveItemInfoCmd)
}

void ReqGiveItemInfoCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 32;
  id_ = GOOGLE_ULONGLONG(0);
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqGiveItemInfoCmd::~ReqGiveItemInfoCmd() {
  // @@protoc_insertion_point(destructor:Cmd.ReqGiveItemInfoCmd)
  SharedDtor();
}

void ReqGiveItemInfoCmd::SharedDtor() {
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void ReqGiveItemInfoCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqGiveItemInfoCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqGiveItemInfoCmd_descriptor_;
}

const ReqGiveItemInfoCmd& ReqGiveItemInfoCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ReqGiveItemInfoCmd* ReqGiveItemInfoCmd::default_instance_ = NULL;

ReqGiveItemInfoCmd* ReqGiveItemInfoCmd::New() const {
  return new ReqGiveItemInfoCmd;
}

void ReqGiveItemInfoCmd::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 32;
    id_ = GOOGLE_ULONGLONG(0);
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::Cmd::GiveItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqGiveItemInfoCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ReqGiveItemInfoCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_GIVE_ITEM_INFO_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional uint64 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_iteminfo;
        break;
      }

      // optional .Cmd.GiveItemInfo iteminfo = 4;
      case 4: {
        if (tag == 34) {
         parse_iteminfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ReqGiveItemInfoCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ReqGiveItemInfoCmd)
  return false;
#undef DO_
}

void ReqGiveItemInfoCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ReqGiveItemInfoCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_GIVE_ITEM_INFO_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->id(), output);
  }

  // optional .Cmd.GiveItemInfo iteminfo = 4;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ReqGiveItemInfoCmd)
}

::google::protobuf::uint8* ReqGiveItemInfoCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ReqGiveItemInfoCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_GIVE_ITEM_INFO_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->id(), target);
  }

  // optional .Cmd.GiveItemInfo iteminfo = 4;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ReqGiveItemInfoCmd)
  return target;
}

int ReqGiveItemInfoCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = REQ_GIVE_ITEM_INFO_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional .Cmd.GiveItemInfo iteminfo = 4;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqGiveItemInfoCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqGiveItemInfoCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqGiveItemInfoCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqGiveItemInfoCmd::MergeFrom(const ReqGiveItemInfoCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::Cmd::GiveItemInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqGiveItemInfoCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqGiveItemInfoCmd::CopyFrom(const ReqGiveItemInfoCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqGiveItemInfoCmd::IsInitialized() const {

  return true;
}

void ReqGiveItemInfoCmd::Swap(ReqGiveItemInfoCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(id_, other->id_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqGiveItemInfoCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqGiveItemInfoCmd_descriptor_;
  metadata.reflection = ReqGiveItemInfoCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckPackageSizeTradeCmd::kCmdFieldNumber;
const int CheckPackageSizeTradeCmd::kParamFieldNumber;
const int CheckPackageSizeTradeCmd::kItemsFieldNumber;
const int CheckPackageSizeTradeCmd::kRetFieldNumber;
#endif  // !_MSC_VER

CheckPackageSizeTradeCmd::CheckPackageSizeTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.CheckPackageSizeTradeCmd)
}

void CheckPackageSizeTradeCmd::InitAsDefaultInstance() {
}

CheckPackageSizeTradeCmd::CheckPackageSizeTradeCmd(const CheckPackageSizeTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.CheckPackageSizeTradeCmd)
}

void CheckPackageSizeTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 35;
  ret_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckPackageSizeTradeCmd::~CheckPackageSizeTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.CheckPackageSizeTradeCmd)
  SharedDtor();
}

void CheckPackageSizeTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckPackageSizeTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckPackageSizeTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckPackageSizeTradeCmd_descriptor_;
}

const CheckPackageSizeTradeCmd& CheckPackageSizeTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

CheckPackageSizeTradeCmd* CheckPackageSizeTradeCmd::default_instance_ = NULL;

CheckPackageSizeTradeCmd* CheckPackageSizeTradeCmd::New() const {
  return new CheckPackageSizeTradeCmd;
}

void CheckPackageSizeTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 11) {
    cmd_ = 57;
    param_ = 35;
    ret_ = false;
  }
  items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckPackageSizeTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.CheckPackageSizeTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = CHECK_PACKAGE_SIZE_TRADE_CMD];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_items;
        break;
      }

      // repeated .Cmd.ItemInfo items = 3;
      case 3: {
        if (tag == 26) {
         parse_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_items;
        if (input->ExpectTag(32)) goto parse_ret;
        break;
      }

      // optional bool ret = 4;
      case 4: {
        if (tag == 32) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.CheckPackageSizeTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.CheckPackageSizeTradeCmd)
  return false;
#undef DO_
}

void CheckPackageSizeTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.CheckPackageSizeTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = CHECK_PACKAGE_SIZE_TRADE_CMD];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // repeated .Cmd.ItemInfo items = 3;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->items(i), output);
  }

  // optional bool ret = 4;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.CheckPackageSizeTradeCmd)
}

::google::protobuf::uint8* CheckPackageSizeTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.CheckPackageSizeTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = CHECK_PACKAGE_SIZE_TRADE_CMD];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // repeated .Cmd.ItemInfo items = 3;
  for (int i = 0; i < this->items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->items(i), target);
  }

  // optional bool ret = 4;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.CheckPackageSizeTradeCmd)
  return target;
}

int CheckPackageSizeTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = CHECK_PACKAGE_SIZE_TRADE_CMD];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional bool ret = 4;
    if (has_ret()) {
      total_size += 1 + 1;
    }

  }
  // repeated .Cmd.ItemInfo items = 3;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckPackageSizeTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckPackageSizeTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckPackageSizeTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckPackageSizeTradeCmd::MergeFrom(const CheckPackageSizeTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckPackageSizeTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckPackageSizeTradeCmd::CopyFrom(const CheckPackageSizeTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPackageSizeTradeCmd::IsInitialized() const {

  return true;
}

void CheckPackageSizeTradeCmd::Swap(CheckPackageSizeTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    items_.Swap(&other->items_);
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckPackageSizeTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckPackageSizeTradeCmd_descriptor_;
  metadata.reflection = CheckPackageSizeTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QucikTakeLogTradeCmd::kCmdFieldNumber;
const int QucikTakeLogTradeCmd::kParamFieldNumber;
const int QucikTakeLogTradeCmd::kTradeTypeFieldNumber;
#endif  // !_MSC_VER

QucikTakeLogTradeCmd::QucikTakeLogTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.QucikTakeLogTradeCmd)
}

void QucikTakeLogTradeCmd::InitAsDefaultInstance() {
}

QucikTakeLogTradeCmd::QucikTakeLogTradeCmd(const QucikTakeLogTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.QucikTakeLogTradeCmd)
}

void QucikTakeLogTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 36;
  trade_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QucikTakeLogTradeCmd::~QucikTakeLogTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.QucikTakeLogTradeCmd)
  SharedDtor();
}

void QucikTakeLogTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void QucikTakeLogTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QucikTakeLogTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QucikTakeLogTradeCmd_descriptor_;
}

const QucikTakeLogTradeCmd& QucikTakeLogTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

QucikTakeLogTradeCmd* QucikTakeLogTradeCmd::default_instance_ = NULL;

QucikTakeLogTradeCmd* QucikTakeLogTradeCmd::New() const {
  return new QucikTakeLogTradeCmd;
}

void QucikTakeLogTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    cmd_ = 57;
    param_ = 36;
    trade_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QucikTakeLogTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.QucikTakeLogTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = QUICK_TAKE_LOG_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_trade_type;
        break;
      }

      // optional .Cmd.ETradeType trade_type = 3 [default = ETRADETYPE_TRADE];
      case 3: {
        if (tag == 24) {
         parse_trade_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_trade_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.QucikTakeLogTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.QucikTakeLogTradeCmd)
  return false;
#undef DO_
}

void QucikTakeLogTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.QucikTakeLogTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUICK_TAKE_LOG_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.ETradeType trade_type = 3 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->trade_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.QucikTakeLogTradeCmd)
}

::google::protobuf::uint8* QucikTakeLogTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.QucikTakeLogTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUICK_TAKE_LOG_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.ETradeType trade_type = 3 [default = ETRADETYPE_TRADE];
  if (has_trade_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->trade_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.QucikTakeLogTradeCmd)
  return target;
}

int QucikTakeLogTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = QUICK_TAKE_LOG_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.ETradeType trade_type = 3 [default = ETRADETYPE_TRADE];
    if (has_trade_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trade_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QucikTakeLogTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QucikTakeLogTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QucikTakeLogTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QucikTakeLogTradeCmd::MergeFrom(const QucikTakeLogTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_trade_type()) {
      set_trade_type(from.trade_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QucikTakeLogTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QucikTakeLogTradeCmd::CopyFrom(const QucikTakeLogTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QucikTakeLogTradeCmd::IsInitialized() const {

  return true;
}

void QucikTakeLogTradeCmd::Swap(QucikTakeLogTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(trade_type_, other->trade_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QucikTakeLogTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QucikTakeLogTradeCmd_descriptor_;
  metadata.reflection = QucikTakeLogTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ItemCount::kItemidFieldNumber;
const int ItemCount::kCountFieldNumber;
#endif  // !_MSC_VER

ItemCount::ItemCount()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.ItemCount)
}

void ItemCount::InitAsDefaultInstance() {
}

ItemCount::ItemCount(const ItemCount& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.ItemCount)
}

void ItemCount::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0u;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ItemCount::~ItemCount() {
  // @@protoc_insertion_point(destructor:Cmd.ItemCount)
  SharedDtor();
}

void ItemCount::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ItemCount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ItemCount::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemCount_descriptor_;
}

const ItemCount& ItemCount::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

ItemCount* ItemCount::default_instance_ = NULL;

ItemCount* ItemCount::New() const {
  return new ItemCount;
}

void ItemCount::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ItemCount*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(itemid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ItemCount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.ItemCount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 itemid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional uint32 count = 2;
      case 2: {
        if (tag == 16) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.ItemCount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.ItemCount)
  return false;
#undef DO_
}

void ItemCount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.ItemCount)
  // optional uint32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->itemid(), output);
  }

  // optional uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.ItemCount)
}

::google::protobuf::uint8* ItemCount::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.ItemCount)
  // optional uint32 itemid = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->itemid(), target);
  }

  // optional uint32 count = 2;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.ItemCount)
  return target;
}

int ItemCount::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->itemid());
    }

    // optional uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ItemCount::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ItemCount* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ItemCount*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ItemCount::MergeFrom(const ItemCount& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ItemCount::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ItemCount::CopyFrom(const ItemCount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ItemCount::IsInitialized() const {

  return true;
}

void ItemCount::Swap(ItemCount* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ItemCount::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ItemCount_descriptor_;
  metadata.reflection = ItemCount_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int QueryItemCountTradeCmd::kCmdFieldNumber;
const int QueryItemCountTradeCmd::kParamFieldNumber;
const int QueryItemCountTradeCmd::kCharidFieldNumber;
const int QueryItemCountTradeCmd::kItemsFieldNumber;
const int QueryItemCountTradeCmd::kResItemsFieldNumber;
#endif  // !_MSC_VER

QueryItemCountTradeCmd::QueryItemCountTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.QueryItemCountTradeCmd)
}

void QueryItemCountTradeCmd::InitAsDefaultInstance() {
}

QueryItemCountTradeCmd::QueryItemCountTradeCmd(const QueryItemCountTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.QueryItemCountTradeCmd)
}

void QueryItemCountTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 37;
  charid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryItemCountTradeCmd::~QueryItemCountTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.QueryItemCountTradeCmd)
  SharedDtor();
}

void QueryItemCountTradeCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void QueryItemCountTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* QueryItemCountTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return QueryItemCountTradeCmd_descriptor_;
}

const QueryItemCountTradeCmd& QueryItemCountTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

QueryItemCountTradeCmd* QueryItemCountTradeCmd::default_instance_ = NULL;

QueryItemCountTradeCmd* QueryItemCountTradeCmd::New() const {
  return new QueryItemCountTradeCmd;
}

void QueryItemCountTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    cmd_ = 57;
    param_ = 37;
    charid_ = GOOGLE_ULONGLONG(0);
  }
  items_.Clear();
  res_items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool QueryItemCountTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.QueryItemCountTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_ITEM_COUNT_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_items;
        break;
      }

      // repeated .Cmd.ItemCount items = 4;
      case 4: {
        if (tag == 34) {
         parse_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_items;
        if (input->ExpectTag(42)) goto parse_res_items;
        break;
      }

      // repeated .Cmd.TradeItemBaseInfo res_items = 5;
      case 5: {
        if (tag == 42) {
         parse_res_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_res_items()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_res_items;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.QueryItemCountTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.QueryItemCountTradeCmd)
  return false;
#undef DO_
}

void QueryItemCountTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.QueryItemCountTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_ITEM_COUNT_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // repeated .Cmd.ItemCount items = 4;
  for (int i = 0; i < this->items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->items(i), output);
  }

  // repeated .Cmd.TradeItemBaseInfo res_items = 5;
  for (int i = 0; i < this->res_items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->res_items(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.QueryItemCountTradeCmd)
}

::google::protobuf::uint8* QueryItemCountTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.QueryItemCountTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_ITEM_COUNT_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // repeated .Cmd.ItemCount items = 4;
  for (int i = 0; i < this->items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->items(i), target);
  }

  // repeated .Cmd.TradeItemBaseInfo res_items = 5;
  for (int i = 0; i < this->res_items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->res_items(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.QueryItemCountTradeCmd)
  return target;
}

int QueryItemCountTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_ITEM_COUNT_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

  }
  // repeated .Cmd.ItemCount items = 4;
  total_size += 1 * this->items_size();
  for (int i = 0; i < this->items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->items(i));
  }

  // repeated .Cmd.TradeItemBaseInfo res_items = 5;
  total_size += 1 * this->res_items_size();
  for (int i = 0; i < this->res_items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->res_items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryItemCountTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const QueryItemCountTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const QueryItemCountTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void QueryItemCountTradeCmd::MergeFrom(const QueryItemCountTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  items_.MergeFrom(from.items_);
  res_items_.MergeFrom(from.res_items_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void QueryItemCountTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QueryItemCountTradeCmd::CopyFrom(const QueryItemCountTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryItemCountTradeCmd::IsInitialized() const {

  return true;
}

void QueryItemCountTradeCmd::Swap(QueryItemCountTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    items_.Swap(&other->items_);
    res_items_.Swap(&other->res_items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata QueryItemCountTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = QueryItemCountTradeCmd_descriptor_;
  metadata.reflection = QueryItemCountTradeCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LotteryGiveInfo::kYearFieldNumber;
const int LotteryGiveInfo::kMonthFieldNumber;
const int LotteryGiveInfo::kCountFieldNumber;
const int LotteryGiveInfo::kContentFieldNumber;
const int LotteryGiveInfo::kConfigidFieldNumber;
const int LotteryGiveInfo::kReceiveridFieldNumber;
#endif  // !_MSC_VER

LotteryGiveInfo::LotteryGiveInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.LotteryGiveInfo)
}

void LotteryGiveInfo::InitAsDefaultInstance() {
}

LotteryGiveInfo::LotteryGiveInfo(const LotteryGiveInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.LotteryGiveInfo)
}

void LotteryGiveInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  year_ = 0u;
  month_ = 0u;
  count_ = 0u;
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  configid_ = 0u;
  receiverid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LotteryGiveInfo::~LotteryGiveInfo() {
  // @@protoc_insertion_point(destructor:Cmd.LotteryGiveInfo)
  SharedDtor();
}

void LotteryGiveInfo::SharedDtor() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (this != default_instance_) {
  }
}

void LotteryGiveInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LotteryGiveInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LotteryGiveInfo_descriptor_;
}

const LotteryGiveInfo& LotteryGiveInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

LotteryGiveInfo* LotteryGiveInfo::default_instance_ = NULL;

LotteryGiveInfo* LotteryGiveInfo::New() const {
  return new LotteryGiveInfo;
}

void LotteryGiveInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LotteryGiveInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(year_, month_);
    ZR_(count_, receiverid_);
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LotteryGiveInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.LotteryGiveInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 year = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &year_)));
          set_has_year();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_month;
        break;
      }

      // optional uint32 month = 2;
      case 2: {
        if (tag == 16) {
         parse_month:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &month_)));
          set_has_month();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_count;
        break;
      }

      // optional uint32 count = 3;
      case 3: {
        if (tag == 24) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_content;
        break;
      }

      // optional string content = 4;
      case 4: {
        if (tag == 34) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->content().data(), this->content().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "content");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_configid;
        break;
      }

      // optional uint32 configid = 5;
      case 5: {
        if (tag == 40) {
         parse_configid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &configid_)));
          set_has_configid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_receiverid;
        break;
      }

      // optional uint64 receiverid = 6;
      case 6: {
        if (tag == 48) {
         parse_receiverid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &receiverid_)));
          set_has_receiverid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.LotteryGiveInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.LotteryGiveInfo)
  return false;
#undef DO_
}

void LotteryGiveInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.LotteryGiveInfo)
  // optional uint32 year = 1;
  if (has_year()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->year(), output);
  }

  // optional uint32 month = 2;
  if (has_month()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->month(), output);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->count(), output);
  }

  // optional string content = 4;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->content(), output);
  }

  // optional uint32 configid = 5;
  if (has_configid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->configid(), output);
  }

  // optional uint64 receiverid = 6;
  if (has_receiverid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->receiverid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.LotteryGiveInfo)
}

::google::protobuf::uint8* LotteryGiveInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.LotteryGiveInfo)
  // optional uint32 year = 1;
  if (has_year()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->year(), target);
  }

  // optional uint32 month = 2;
  if (has_month()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->month(), target);
  }

  // optional uint32 count = 3;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->count(), target);
  }

  // optional string content = 4;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->content(), target);
  }

  // optional uint32 configid = 5;
  if (has_configid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->configid(), target);
  }

  // optional uint64 receiverid = 6;
  if (has_receiverid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->receiverid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.LotteryGiveInfo)
  return target;
}

int LotteryGiveInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 year = 1;
    if (has_year()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->year());
    }

    // optional uint32 month = 2;
    if (has_month()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->month());
    }

    // optional uint32 count = 3;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

    // optional string content = 4;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional uint32 configid = 5;
    if (has_configid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->configid());
    }

    // optional uint64 receiverid = 6;
    if (has_receiverid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->receiverid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LotteryGiveInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LotteryGiveInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LotteryGiveInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LotteryGiveInfo::MergeFrom(const LotteryGiveInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_year()) {
      set_year(from.year());
    }
    if (from.has_month()) {
      set_month(from.month());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_configid()) {
      set_configid(from.configid());
    }
    if (from.has_receiverid()) {
      set_receiverid(from.receiverid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LotteryGiveInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LotteryGiveInfo::CopyFrom(const LotteryGiveInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LotteryGiveInfo::IsInitialized() const {

  return true;
}

void LotteryGiveInfo::Swap(LotteryGiveInfo* other) {
  if (other != this) {
    std::swap(year_, other->year_);
    std::swap(month_, other->month_);
    std::swap(count_, other->count_);
    std::swap(content_, other->content_);
    std::swap(configid_, other->configid_);
    std::swap(receiverid_, other->receiverid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LotteryGiveInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LotteryGiveInfo_descriptor_;
  metadata.reflection = LotteryGiveInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LotteryGiveCmd::kCmdFieldNumber;
const int LotteryGiveCmd::kParamFieldNumber;
const int LotteryGiveCmd::kIteminfoFieldNumber;
#endif  // !_MSC_VER

LotteryGiveCmd::LotteryGiveCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.LotteryGiveCmd)
}

void LotteryGiveCmd::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::Cmd::LotteryGiveInfo*>(&::Cmd::LotteryGiveInfo::default_instance());
}

LotteryGiveCmd::LotteryGiveCmd(const LotteryGiveCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.LotteryGiveCmd)
}

void LotteryGiveCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 38;
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LotteryGiveCmd::~LotteryGiveCmd() {
  // @@protoc_insertion_point(destructor:Cmd.LotteryGiveCmd)
  SharedDtor();
}

void LotteryGiveCmd::SharedDtor() {
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void LotteryGiveCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LotteryGiveCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LotteryGiveCmd_descriptor_;
}

const LotteryGiveCmd& LotteryGiveCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

LotteryGiveCmd* LotteryGiveCmd::default_instance_ = NULL;

LotteryGiveCmd* LotteryGiveCmd::New() const {
  return new LotteryGiveCmd;
}

void LotteryGiveCmd::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    cmd_ = 57;
    param_ = 38;
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::Cmd::LotteryGiveInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LotteryGiveCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.LotteryGiveCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_LOTTERY_GIVE_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_iteminfo;
        break;
      }

      // optional .Cmd.LotteryGiveInfo iteminfo = 3;
      case 3: {
        if (tag == 26) {
         parse_iteminfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.LotteryGiveCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.LotteryGiveCmd)
  return false;
#undef DO_
}

void LotteryGiveCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.LotteryGiveCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_LOTTERY_GIVE_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.LotteryGiveInfo iteminfo = 3;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.LotteryGiveCmd)
}

::google::protobuf::uint8* LotteryGiveCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.LotteryGiveCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_LOTTERY_GIVE_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.LotteryGiveInfo iteminfo = 3;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.LotteryGiveCmd)
  return target;
}

int LotteryGiveCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_LOTTERY_GIVE_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.LotteryGiveInfo iteminfo = 3;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LotteryGiveCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LotteryGiveCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LotteryGiveCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LotteryGiveCmd::MergeFrom(const LotteryGiveCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::Cmd::LotteryGiveInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LotteryGiveCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LotteryGiveCmd::CopyFrom(const LotteryGiveCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LotteryGiveCmd::IsInitialized() const {

  return true;
}

void LotteryGiveCmd::Swap(LotteryGiveCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LotteryGiveCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LotteryGiveCmd_descriptor_;
  metadata.reflection = LotteryGiveCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TodayFinanceItem::kItemIdFieldNumber;
const int TodayFinanceItem::kRatioFieldNumber;
const int TodayFinanceItem::kTimeFieldNumber;
#endif  // !_MSC_VER

TodayFinanceItem::TodayFinanceItem()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.TodayFinanceItem)
}

void TodayFinanceItem::InitAsDefaultInstance() {
}

TodayFinanceItem::TodayFinanceItem(const TodayFinanceItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.TodayFinanceItem)
}

void TodayFinanceItem::SharedCtor() {
  _cached_size_ = 0;
  item_id_ = 0u;
  ratio_ = 0u;
  time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TodayFinanceItem::~TodayFinanceItem() {
  // @@protoc_insertion_point(destructor:Cmd.TodayFinanceItem)
  SharedDtor();
}

void TodayFinanceItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TodayFinanceItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TodayFinanceItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TodayFinanceItem_descriptor_;
}

const TodayFinanceItem& TodayFinanceItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

TodayFinanceItem* TodayFinanceItem::default_instance_ = NULL;

TodayFinanceItem* TodayFinanceItem::New() const {
  return new TodayFinanceItem;
}

void TodayFinanceItem::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TodayFinanceItem*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(item_id_, time_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TodayFinanceItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.TodayFinanceItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 item_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ratio;
        break;
      }

      // optional uint32 ratio = 2;
      case 2: {
        if (tag == 16) {
         parse_ratio:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ratio_)));
          set_has_ratio();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time;
        break;
      }

      // optional uint32 time = 3;
      case 3: {
        if (tag == 24) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.TodayFinanceItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.TodayFinanceItem)
  return false;
#undef DO_
}

void TodayFinanceItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.TodayFinanceItem)
  // optional uint32 item_id = 1;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->item_id(), output);
  }

  // optional uint32 ratio = 2;
  if (has_ratio()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ratio(), output);
  }

  // optional uint32 time = 3;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.TodayFinanceItem)
}

::google::protobuf::uint8* TodayFinanceItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.TodayFinanceItem)
  // optional uint32 item_id = 1;
  if (has_item_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->item_id(), target);
  }

  // optional uint32 ratio = 2;
  if (has_ratio()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ratio(), target);
  }

  // optional uint32 time = 3;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.TodayFinanceItem)
  return target;
}

int TodayFinanceItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 item_id = 1;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // optional uint32 ratio = 2;
    if (has_ratio()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ratio());
    }

    // optional uint32 time = 3;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TodayFinanceItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TodayFinanceItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TodayFinanceItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TodayFinanceItem::MergeFrom(const TodayFinanceItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_ratio()) {
      set_ratio(from.ratio());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TodayFinanceItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TodayFinanceItem::CopyFrom(const TodayFinanceItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TodayFinanceItem::IsInitialized() const {

  return true;
}

void TodayFinanceItem::Swap(TodayFinanceItem* other) {
  if (other != this) {
    std::swap(item_id_, other->item_id_);
    std::swap(ratio_, other->ratio_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TodayFinanceItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TodayFinanceItem_descriptor_;
  metadata.reflection = TodayFinanceItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TodayFinanceRank::kCmdFieldNumber;
const int TodayFinanceRank::kParamFieldNumber;
const int TodayFinanceRank::kRankTypeFieldNumber;
const int TodayFinanceRank::kDateTypeFieldNumber;
const int TodayFinanceRank::kListsFieldNumber;
#endif  // !_MSC_VER

TodayFinanceRank::TodayFinanceRank()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.TodayFinanceRank)
}

void TodayFinanceRank::InitAsDefaultInstance() {
}

TodayFinanceRank::TodayFinanceRank(const TodayFinanceRank& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.TodayFinanceRank)
}

void TodayFinanceRank::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 39;
  rank_type_ = 1;
  date_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TodayFinanceRank::~TodayFinanceRank() {
  // @@protoc_insertion_point(destructor:Cmd.TodayFinanceRank)
  SharedDtor();
}

void TodayFinanceRank::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TodayFinanceRank::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TodayFinanceRank::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TodayFinanceRank_descriptor_;
}

const TodayFinanceRank& TodayFinanceRank::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

TodayFinanceRank* TodayFinanceRank::default_instance_ = NULL;

TodayFinanceRank* TodayFinanceRank::New() const {
  return new TodayFinanceRank;
}

void TodayFinanceRank::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    cmd_ = 57;
    param_ = 39;
    rank_type_ = 1;
    date_type_ = 1;
  }
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TodayFinanceRank::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.TodayFinanceRank)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_RANK];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_rank_type;
        break;
      }

      // optional .Cmd.EFinanceRankType rank_type = 3 [default = EFINANCE_RANK_DEALCOUNT];
      case 3: {
        if (tag == 24) {
         parse_rank_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EFinanceRankType_IsValid(value)) {
            set_rank_type(static_cast< ::Cmd::EFinanceRankType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_date_type;
        break;
      }

      // optional .Cmd.EFinanceDateType date_type = 4 [default = EFINANCE_DATE_THREE];
      case 4: {
        if (tag == 32) {
         parse_date_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EFinanceDateType_IsValid(value)) {
            set_date_type(static_cast< ::Cmd::EFinanceDateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_lists;
        break;
      }

      // repeated .Cmd.TodayFinanceItem lists = 5;
      case 5: {
        if (tag == 42) {
         parse_lists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lists()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.TodayFinanceRank)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.TodayFinanceRank)
  return false;
#undef DO_
}

void TodayFinanceRank::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.TodayFinanceRank)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_RANK];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional .Cmd.EFinanceRankType rank_type = 3 [default = EFINANCE_RANK_DEALCOUNT];
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->rank_type(), output);
  }

  // optional .Cmd.EFinanceDateType date_type = 4 [default = EFINANCE_DATE_THREE];
  if (has_date_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->date_type(), output);
  }

  // repeated .Cmd.TodayFinanceItem lists = 5;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.TodayFinanceRank)
}

::google::protobuf::uint8* TodayFinanceRank::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.TodayFinanceRank)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_RANK];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional .Cmd.EFinanceRankType rank_type = 3 [default = EFINANCE_RANK_DEALCOUNT];
  if (has_rank_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->rank_type(), target);
  }

  // optional .Cmd.EFinanceDateType date_type = 4 [default = EFINANCE_DATE_THREE];
  if (has_date_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->date_type(), target);
  }

  // repeated .Cmd.TodayFinanceItem lists = 5;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.TodayFinanceRank)
  return target;
}

int TodayFinanceRank::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_RANK];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional .Cmd.EFinanceRankType rank_type = 3 [default = EFINANCE_RANK_DEALCOUNT];
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rank_type());
    }

    // optional .Cmd.EFinanceDateType date_type = 4 [default = EFINANCE_DATE_THREE];
    if (has_date_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->date_type());
    }

  }
  // repeated .Cmd.TodayFinanceItem lists = 5;
  total_size += 1 * this->lists_size();
  for (int i = 0; i < this->lists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TodayFinanceRank::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TodayFinanceRank* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TodayFinanceRank*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TodayFinanceRank::MergeFrom(const TodayFinanceRank& from) {
  GOOGLE_CHECK_NE(&from, this);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
    if (from.has_date_type()) {
      set_date_type(from.date_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TodayFinanceRank::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TodayFinanceRank::CopyFrom(const TodayFinanceRank& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TodayFinanceRank::IsInitialized() const {

  return true;
}

void TodayFinanceRank::Swap(TodayFinanceRank* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(rank_type_, other->rank_type_);
    std::swap(date_type_, other->date_type_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TodayFinanceRank::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TodayFinanceRank_descriptor_;
  metadata.reflection = TodayFinanceRank_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TodayFinanceDetail::kCmdFieldNumber;
const int TodayFinanceDetail::kParamFieldNumber;
const int TodayFinanceDetail::kItemIdFieldNumber;
const int TodayFinanceDetail::kRankTypeFieldNumber;
const int TodayFinanceDetail::kDateTypeFieldNumber;
const int TodayFinanceDetail::kListsFieldNumber;
#endif  // !_MSC_VER

TodayFinanceDetail::TodayFinanceDetail()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.TodayFinanceDetail)
}

void TodayFinanceDetail::InitAsDefaultInstance() {
}

TodayFinanceDetail::TodayFinanceDetail(const TodayFinanceDetail& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.TodayFinanceDetail)
}

void TodayFinanceDetail::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 40;
  item_id_ = 0u;
  rank_type_ = 1;
  date_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TodayFinanceDetail::~TodayFinanceDetail() {
  // @@protoc_insertion_point(destructor:Cmd.TodayFinanceDetail)
  SharedDtor();
}

void TodayFinanceDetail::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TodayFinanceDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TodayFinanceDetail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TodayFinanceDetail_descriptor_;
}

const TodayFinanceDetail& TodayFinanceDetail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

TodayFinanceDetail* TodayFinanceDetail::default_instance_ = NULL;

TodayFinanceDetail* TodayFinanceDetail::New() const {
  return new TodayFinanceDetail;
}

void TodayFinanceDetail::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    cmd_ = 57;
    param_ = 40;
    item_id_ = 0u;
    rank_type_ = 1;
    date_type_ = 1;
  }
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TodayFinanceDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.TodayFinanceDetail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_DETAIL];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_item_id;
        break;
      }

      // optional uint32 item_id = 3;
      case 3: {
        if (tag == 24) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_rank_type;
        break;
      }

      // optional .Cmd.EFinanceRankType rank_type = 4 [default = EFINANCE_RANK_DEALCOUNT];
      case 4: {
        if (tag == 32) {
         parse_rank_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EFinanceRankType_IsValid(value)) {
            set_rank_type(static_cast< ::Cmd::EFinanceRankType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_date_type;
        break;
      }

      // optional .Cmd.EFinanceDateType date_type = 5 [default = EFINANCE_DATE_THREE];
      case 5: {
        if (tag == 40) {
         parse_date_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::EFinanceDateType_IsValid(value)) {
            set_date_type(static_cast< ::Cmd::EFinanceDateType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_lists;
        break;
      }

      // repeated .Cmd.TodayFinanceItem lists = 6;
      case 6: {
        if (tag == 50) {
         parse_lists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lists()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.TodayFinanceDetail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.TodayFinanceDetail)
  return false;
#undef DO_
}

void TodayFinanceDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.TodayFinanceDetail)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_DETAIL];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint32 item_id = 3;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->item_id(), output);
  }

  // optional .Cmd.EFinanceRankType rank_type = 4 [default = EFINANCE_RANK_DEALCOUNT];
  if (has_rank_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->rank_type(), output);
  }

  // optional .Cmd.EFinanceDateType date_type = 5 [default = EFINANCE_DATE_THREE];
  if (has_date_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->date_type(), output);
  }

  // repeated .Cmd.TodayFinanceItem lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.TodayFinanceDetail)
}

::google::protobuf::uint8* TodayFinanceDetail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.TodayFinanceDetail)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_DETAIL];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint32 item_id = 3;
  if (has_item_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->item_id(), target);
  }

  // optional .Cmd.EFinanceRankType rank_type = 4 [default = EFINANCE_RANK_DEALCOUNT];
  if (has_rank_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->rank_type(), target);
  }

  // optional .Cmd.EFinanceDateType date_type = 5 [default = EFINANCE_DATE_THREE];
  if (has_date_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->date_type(), target);
  }

  // repeated .Cmd.TodayFinanceItem lists = 6;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.TodayFinanceDetail)
  return target;
}

int TodayFinanceDetail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = QUERY_SERVANT_FINANCE_DETAIL];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint32 item_id = 3;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->item_id());
    }

    // optional .Cmd.EFinanceRankType rank_type = 4 [default = EFINANCE_RANK_DEALCOUNT];
    if (has_rank_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rank_type());
    }

    // optional .Cmd.EFinanceDateType date_type = 5 [default = EFINANCE_DATE_THREE];
    if (has_date_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->date_type());
    }

  }
  // repeated .Cmd.TodayFinanceItem lists = 6;
  total_size += 1 * this->lists_size();
  for (int i = 0; i < this->lists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TodayFinanceDetail::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TodayFinanceDetail* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TodayFinanceDetail*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TodayFinanceDetail::MergeFrom(const TodayFinanceDetail& from) {
  GOOGLE_CHECK_NE(&from, this);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_rank_type()) {
      set_rank_type(from.rank_type());
    }
    if (from.has_date_type()) {
      set_date_type(from.date_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TodayFinanceDetail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TodayFinanceDetail::CopyFrom(const TodayFinanceDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TodayFinanceDetail::IsInitialized() const {

  return true;
}

void TodayFinanceDetail::Swap(TodayFinanceDetail* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(item_id_, other->item_id_);
    std::swap(rank_type_, other->rank_type_);
    std::swap(date_type_, other->date_type_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TodayFinanceDetail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TodayFinanceDetail_descriptor_;
  metadata.reflection = TodayFinanceDetail_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BoothPlayerPendingListCmd::kCmdFieldNumber;
const int BoothPlayerPendingListCmd::kParamFieldNumber;
const int BoothPlayerPendingListCmd::kCharidFieldNumber;
const int BoothPlayerPendingListCmd::kListsFieldNumber;
#endif  // !_MSC_VER

BoothPlayerPendingListCmd::BoothPlayerPendingListCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.BoothPlayerPendingListCmd)
}

void BoothPlayerPendingListCmd::InitAsDefaultInstance() {
}

BoothPlayerPendingListCmd::BoothPlayerPendingListCmd(const BoothPlayerPendingListCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.BoothPlayerPendingListCmd)
}

void BoothPlayerPendingListCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 41;
  charid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BoothPlayerPendingListCmd::~BoothPlayerPendingListCmd() {
  // @@protoc_insertion_point(destructor:Cmd.BoothPlayerPendingListCmd)
  SharedDtor();
}

void BoothPlayerPendingListCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BoothPlayerPendingListCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BoothPlayerPendingListCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BoothPlayerPendingListCmd_descriptor_;
}

const BoothPlayerPendingListCmd& BoothPlayerPendingListCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

BoothPlayerPendingListCmd* BoothPlayerPendingListCmd::default_instance_ = NULL;

BoothPlayerPendingListCmd* BoothPlayerPendingListCmd::New() const {
  return new BoothPlayerPendingListCmd;
}

void BoothPlayerPendingListCmd::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    cmd_ = 57;
    param_ = 41;
    charid_ = GOOGLE_ULONGLONG(0);
  }
  lists_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BoothPlayerPendingListCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.BoothPlayerPendingListCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = BOOTH_PLAYER_PENDING_LIST];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_lists;
        break;
      }

      // repeated .Cmd.TradeItemBaseInfo lists = 4;
      case 4: {
        if (tag == 34) {
         parse_lists:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lists()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_lists;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.BoothPlayerPendingListCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.BoothPlayerPendingListCmd)
  return false;
#undef DO_
}

void BoothPlayerPendingListCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.BoothPlayerPendingListCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BOOTH_PLAYER_PENDING_LIST];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 4;
  for (int i = 0; i < this->lists_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->lists(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.BoothPlayerPendingListCmd)
}

::google::protobuf::uint8* BoothPlayerPendingListCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.BoothPlayerPendingListCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = BOOTH_PLAYER_PENDING_LIST];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // repeated .Cmd.TradeItemBaseInfo lists = 4;
  for (int i = 0; i < this->lists_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->lists(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.BoothPlayerPendingListCmd)
  return target;
}

int BoothPlayerPendingListCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = BOOTH_PLAYER_PENDING_LIST];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

  }
  // repeated .Cmd.TradeItemBaseInfo lists = 4;
  total_size += 1 * this->lists_size();
  for (int i = 0; i < this->lists_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lists(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BoothPlayerPendingListCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BoothPlayerPendingListCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BoothPlayerPendingListCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BoothPlayerPendingListCmd::MergeFrom(const BoothPlayerPendingListCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  lists_.MergeFrom(from.lists_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BoothPlayerPendingListCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BoothPlayerPendingListCmd::CopyFrom(const BoothPlayerPendingListCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BoothPlayerPendingListCmd::IsInitialized() const {

  return true;
}

void BoothPlayerPendingListCmd::Swap(BoothPlayerPendingListCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    lists_.Swap(&other->lists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BoothPlayerPendingListCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BoothPlayerPendingListCmd_descriptor_;
  metadata.reflection = BoothPlayerPendingListCmd_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateOrderTradeCmd::kCmdFieldNumber;
const int UpdateOrderTradeCmd::kParamFieldNumber;
const int UpdateOrderTradeCmd::kCharidFieldNumber;
const int UpdateOrderTradeCmd::kInfoFieldNumber;
const int UpdateOrderTradeCmd::kTypeFieldNumber;
#endif  // !_MSC_VER

UpdateOrderTradeCmd::UpdateOrderTradeCmd()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Cmd.UpdateOrderTradeCmd)
}

void UpdateOrderTradeCmd::InitAsDefaultInstance() {
  info_ = const_cast< ::Cmd::TradeItemBaseInfo*>(&::Cmd::TradeItemBaseInfo::default_instance());
}

UpdateOrderTradeCmd::UpdateOrderTradeCmd(const UpdateOrderTradeCmd& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:Cmd.UpdateOrderTradeCmd)
}

void UpdateOrderTradeCmd::SharedCtor() {
  _cached_size_ = 0;
  cmd_ = 57;
  param_ = 42;
  charid_ = GOOGLE_ULONGLONG(0);
  info_ = NULL;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateOrderTradeCmd::~UpdateOrderTradeCmd() {
  // @@protoc_insertion_point(destructor:Cmd.UpdateOrderTradeCmd)
  SharedDtor();
}

void UpdateOrderTradeCmd::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void UpdateOrderTradeCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpdateOrderTradeCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpdateOrderTradeCmd_descriptor_;
}

const UpdateOrderTradeCmd& UpdateOrderTradeCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_RecordTrade_2eproto();
  return *default_instance_;
}

UpdateOrderTradeCmd* UpdateOrderTradeCmd::default_instance_ = NULL;

UpdateOrderTradeCmd* UpdateOrderTradeCmd::New() const {
  return new UpdateOrderTradeCmd;
}

void UpdateOrderTradeCmd::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    cmd_ = 57;
    param_ = 42;
    charid_ = GOOGLE_ULONGLONG(0);
    if (has_info()) {
      if (info_ != NULL) info_->::Cmd::TradeItemBaseInfo::Clear();
    }
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpdateOrderTradeCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Cmd.UpdateOrderTradeCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::Command_IsValid(value)) {
            set_cmd(static_cast< ::Cmd::Command >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_param;
        break;
      }

      // optional .Cmd.RecordUserTradeParam param = 2 [default = UPDATE_ORDER_TRADE_PARAM];
      case 2: {
        if (tag == 16) {
         parse_param:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::RecordUserTradeParam_IsValid(value)) {
            set_param(static_cast< ::Cmd::RecordUserTradeParam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional uint64 charid = 3;
      case 3: {
        if (tag == 24) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_info;
        break;
      }

      // optional .Cmd.TradeItemBaseInfo info = 4;
      case 4: {
        if (tag == 34) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional .Cmd.ETradeType type = 5 [default = ETRADETYPE_TRADE];
      case 5: {
        if (tag == 40) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Cmd::ETradeType_IsValid(value)) {
            set_type(static_cast< ::Cmd::ETradeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Cmd.UpdateOrderTradeCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Cmd.UpdateOrderTradeCmd)
  return false;
#undef DO_
}

void UpdateOrderTradeCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Cmd.UpdateOrderTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->cmd(), output);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = UPDATE_ORDER_TRADE_PARAM];
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->param(), output);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->charid(), output);
  }

  // optional .Cmd.TradeItemBaseInfo info = 4;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->info(), output);
  }

  // optional .Cmd.ETradeType type = 5 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Cmd.UpdateOrderTradeCmd)
}

::google::protobuf::uint8* UpdateOrderTradeCmd::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:Cmd.UpdateOrderTradeCmd)
  // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
  if (has_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->cmd(), target);
  }

  // optional .Cmd.RecordUserTradeParam param = 2 [default = UPDATE_ORDER_TRADE_PARAM];
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->param(), target);
  }

  // optional uint64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->charid(), target);
  }

  // optional .Cmd.TradeItemBaseInfo info = 4;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->info(), target);
  }

  // optional .Cmd.ETradeType type = 5 [default = ETRADETYPE_TRADE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Cmd.UpdateOrderTradeCmd)
  return target;
}

int UpdateOrderTradeCmd::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Cmd.Command cmd = 1 [default = RECORD_USER_TRADE_PROTOCMD];
    if (has_cmd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->cmd());
    }

    // optional .Cmd.RecordUserTradeParam param = 2 [default = UPDATE_ORDER_TRADE_PARAM];
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->param());
    }

    // optional uint64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

    // optional .Cmd.TradeItemBaseInfo info = 4;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

    // optional .Cmd.ETradeType type = 5 [default = ETRADETYPE_TRADE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateOrderTradeCmd::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpdateOrderTradeCmd* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpdateOrderTradeCmd*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpdateOrderTradeCmd::MergeFrom(const UpdateOrderTradeCmd& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_info()) {
      mutable_info()->::Cmd::TradeItemBaseInfo::MergeFrom(from.info());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpdateOrderTradeCmd::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpdateOrderTradeCmd::CopyFrom(const UpdateOrderTradeCmd& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateOrderTradeCmd::IsInitialized() const {

  return true;
}

void UpdateOrderTradeCmd::Swap(UpdateOrderTradeCmd* other) {
  if (other != this) {
    std::swap(cmd_, other->cmd_);
    std::swap(param_, other->param_);
    std::swap(charid_, other->charid_);
    std::swap(info_, other->info_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpdateOrderTradeCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpdateOrderTradeCmd_descriptor_;
  metadata.reflection = UpdateOrderTradeCmd_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Cmd

// @@protoc_insertion_point(global_scope)
